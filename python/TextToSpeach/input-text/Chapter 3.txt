Capítulo 3

As ferramentas básicas
Todo criador começa sua jornada com um conjunto básico de ferramentas de boa qualidade. Um marceneiro pode precisar de regras, medidores, duas serras, alguns bons aviões, cinzéis finos, exercícios e aparelhos, marretas e grampos. Essas ferramentas serão escolhidas com amor, serão construídas para durar, realizarão trabalhos específicos com pouca sobreposição com outras ferramentas e, talvez o mais importante, parecerão corretas nas mãos do trabalhador de madeira.

Em seguida, começa um processo de aprendizado e adaptação. Cada ferramenta terá sua própria personalidade e peculiaridades e precisará de seu próprio manuseio especial. Cada um deve ser afiado de uma maneira única, ou mantida exatamente assim. Com o tempo, cada um se desgastará de acordo com o uso, até que a aderência pareça um molde das mãos do marceneiro e a superfície de corte se alinhe perfeitamente com o ângulo no qual a ferramenta é mantida. Nesse ponto, as ferramentas se tornam condutas do cérebro do fabricante até o produto acabado - elas se tornaram extensões de suas mãos. Com o tempo, o trabalhador da madeira adicionará novas ferramentas, como cortadores de biscoitos, serras de mitra guiadas a laser, gabaritos de cauda-todas as maravilhosas peças de tecnologia. Mas você pode apostar que eles ficarão mais felizes com uma dessas ferramentas originais na mão, sentindo o avião cantar enquanto desliza pela madeira.

As ferramentas amplificam seu talento. Quanto melhores suas ferramentas e melhor você souber usá -las, mais produtiva poderá ser. Comece com um conjunto básico de ferramentas geralmente aplicáveis. À medida que você ganha experiência e, ao encontrar requisitos especiais, adicionará a esse conjunto básico. Como o fabricante, espere adicionar à sua caixa de ferramentas regularmente. Sempre esteja à procura de maneiras melhores de fazer as coisas. Se você se deparar com uma situação em que sente que suas ferramentas atuais não podem cortá -la, anote -se para procurar algo diferente ou mais poderoso que teria ajudado. Vamos precisar dirigir suas aquisições.

Muitos novos programadores cometem o erro de adotar uma única ferramenta elétrica, como um ambiente de desenvolvimento integrado específico (IDE), e nunca deixa sua interface aconchegante. Isso realmente é um erro. Você precisa se sentir confortável além dos limites impostos por um IDE. A única maneira de fazer isso é manter o conjunto básico de ferramentas nítido e pronto para uso.

Neste capítulo, falaremos sobre investir em sua própria caixa de ferramentas básica. Como em qualquer boa discussão sobre ferramentas, começaremos (no tópico 16, o poder do texto simples) observando suas matérias -primas, as coisas que você estará moldando. A partir daí, mudaremos para a bancada de trabalho ou, no nosso caso, o computador. Como você pode usar seu computador para tirar o máximo proveito das ferramentas que você usa? Discutiremos isso no tópico 17, jogos de shell. Agora que temos material e um banco para trabalhar, voltaremos para a ferramenta que você provavelmente usará mais do que qualquer outro, seu editor. No tópico 18, edição de energia, sugerimos maneiras de torná -lo mais eficiente.

Para garantir que nunca perdemos nenhum dos nossos preciosos trabalhos, devemos sempre usar um tópico 19, sistema de controle de versão - mesmo para coisas pessoais, como receitas ou notas. E, como Murphy era realmente um otimista, você não pode ser um ótimo programador até se tornar altamente qualificado no tópico 20, depuração.

Você precisará de alguma cola para unir grande parte da magia. Discutimos algumas possibilidades no tópico 21, manipulação de texto.

Finalmente, a tinta mais palestra ainda é melhor que a melhor memória. Acompanhe seus pensamentos e sua história, como descrevemos no tópico 22, Engenharia Daybooks.

Passe algum tempo aprendendo a usar essas ferramentas e, em algum momento, você ficará surpreso ao descobrir seus dedos se movendo sobre o teclado, manipulando texto sem pensamento consciente. As ferramentas se tornarão extensões de suas mãos.



Tópico 16 - O poder do texto simples

Como programadores pragmáticos, nosso material base não é madeira ou ferro, é conhecimento. Reunimos os requisitos como conhecimento e, em seguida, expressamos esse conhecimento em nossos projetos, implementações, testes e documentos. E acreditamos que o melhor formato para armazenar conhecimento persistentemente é um texto simples. Com o texto simples, nos damos a capacidade de manipular o conhecimento, tanto manual quanto programaticamente, usando praticamente todas as ferramentas à nossa disposição.

O problema com a maioria dos formatos binários é que o contexto necessário para entender os dados é separado dos próprios dados. Você está se divorciando artificialmente dos dados de seu significado. Os dados também podem ser criptografados; É absolutamente sem sentido sem a lógica do aplicativo analisá -la. Com o texto simples, no entanto, você pode obter um fluxo de dados auto-descrito que é independente do aplicativo que criou
isto.

O que é texto simples?
O texto simples é composto de caracteres imprimíveis em um formulário que transmite informações. Pode ser tão simples quanto uma lista de compras:

* Leite
* Alface
* Café

ou tão complexo quanto a fonte deste livro (sim, está em texto simples, para grande desgosto do editor, que queria que usássemos um processador de texto).

A parte da informação é importante. 

O leitor não tem idéia de qual pode ser o significado do 467ABE. Gostamos que nosso texto simples seja compreensível para os seres humanos.

Dica 25 Mantenha o conhecimento em texto simples
O poder do texto
O texto simples não significa que o texto não seja estruturado; HTML, JSON, YAML E assim por diante são todos os texto simples. O mesmo acontece com a maioria dos protocolos fundamentais na rede, como HTTP, SMTP, IMAP e assim por diante. E isso é por alguns bons motivos:

Seguro contra obsolescência
Aproveite as ferramentas existentes
Testes mais fáceis
Seguro contra obsolescência
Formas de dados legíveis por humanos e dados de auto-descrição sobreviverão a todas as outras formas de dados e os aplicativos que os criaram. Período. Enquanto os dados sobreviverem, você terá a chance de usá -los - potencialmente muito tempo depois do aplicativo original que o escreveu é extinto.

Você pode analisar esse arquivo com apenas conhecimento parcial de seu formato; Com a maioria dos arquivos binários, você deve conhecer todos os detalhes de todo o formato para analisá -lo com sucesso.

Considere um arquivo de dados de algum sistema herdado que você recebe. [24] Você sabe pouco sobre o aplicativo original; Tudo o que é importante para você é que ele manteve uma lista dos números de seguridade social dos clientes, que você precisa encontrar e extrair. 

Reconhecendo o formato de um número de previdência social, você pode escrever rapidamente um pequeno programa para extrair esses dados - mesmo que você não tenha informações sobre mais nada no arquivo.

Mas imagine se o arquivo tivesse sido formatado desta maneira:

Você pode não ter reconhecido o significado dos números com a mesma facilidade. Essa é a diferença entre o humano legível e o humano compreensível.

Enquanto estamos nisso, Field10 também não ajuda muito. Algo como

Torna o exercício um acéfalo-e garante que os dados sobrevilem a qualquer projeto que o criasse.

Aproveitar
Praticamente todas as ferramentas no universo de computação, desde sistemas de controle de versão a editores e ferramentas de linha de comando, podem operar em texto sem formatação.

A filosofia do UNIX
A Unix é famosa por ser projetada em torno da filosofia de pequenas ferramentas afiadas, cada uma pretendia fazer uma coisa bem. Essa filosofia é ativada usando um formato subjacente comum-o arquivo de texto simples, orientado a linha. Os bancos de dados usados para administração do sistema (usuários e senhas, configuração de rede e assim por diante) são mantidos como arquivos de texto simples. (Alguns sistemas também mantêm uma forma binária de determinados bancos de dados como uma otimização de desempenho. A versão de texto simples é mantido como uma interface para a versão binária.)

Quando um sistema trava, você pode enfrentar apenas um ambiente mínimo para restaurá -lo (talvez não consiga acessar drivers gráficos, por exemplo). Situações como essa podem realmente fazer você apreciar a simplicidade do texto simples.

O texto simples também é mais fácil de pesquisar. Se você não consegue se lembrar de qual arquivo de configuração gerencia os backups do sistema, um backup rápido de grep -r /etc. deve dizer.

Por exemplo, suponha que você tenha uma implantação de produção de um grande aplicativo com um arquivo de configuração específico do site complexo. Se este arquivo estiver em texto simples, você pode colocá -lo em um sistema de controle de versão (consulte o tópico 19, controle de versão), para manter automaticamente um histórico de todas as alterações. Ferramentas de comparação de arquivos, como DIFF e FC, permitem que você veja de relance quais mudanças foram feitas, enquanto a SUM permite gerar uma soma de verificação para monitorar o arquivo para modificação acidental (ou maliciosa).

Testes mais fáceis
Se você usar texto simples para criar dados sintéticos para direcionar testes do sistema, é uma questão simples de adicionar, atualizar ou modificar os dados de teste sem precisar criar nenhuma ferramenta especial para fazê -lo. Da mesma forma, a saída de texto simples dos testes de regressão pode ser analisado trivialmente com comandos de shell ou um script simples.

Denominador comum mais baixo
Mesmo no futuro dos agentes inteligentes baseados em blockchain que viajam pela Internet selvagem e perigosa da Internet, negociando o intercâmbio de dados entre si, o onipresente arquivo de texto ainda estará lá. De fato, em ambientes heterogêneos, as vantagens do texto simples podem superar todas as desvantagens. Você precisa garantir que todas as partes possam se comunicar usando um padrão comum. Texto simples é isso
padrão.

Seções relacionadas incluem
Tópico 17, jogos de shell
Tópico 21, manipulação de texto
Tópico 32, configuração
Desafios
Projete um pequeno banco de dados de livro de endereços (nome, número de telefone e assim por diante) usando uma representação binária direta em seu idioma de escolha. Faça isso antes de ler o resto deste desafio.

Traduza esse formato em um formato de texto simples usando XML ou JSON.

Para cada versão, adicione um novo campo de comprimento variável chamado instruções nas quais você pode inserir instruções para a casa de cada pessoa.

Que problemas surgem em relação ao versão e extensibilidade? Qual forma era mais fácil de modificar? Que tal converter dados existentes?




Dica 25 - Mantenha o conhecimento em texto simples

O poder do texto

O texto simples não significa que o texto não seja estruturado; HTML, JSON, YAML E assim por diante são todos os texto simples. O mesmo acontece com a maioria dos protocolos fundamentais na rede, como HTTP, SMTP, IMAP e assim por diante. E isso é por alguns bons motivos:

Seguro contra obsolescência
Aproveite as ferramentas existentes
Testes mais fáceis
Seguro contra obsolescência
Formas de dados legíveis por humanos e dados de auto-descrição sobreviverão a todas as outras formas de dados e os aplicativos que os criaram. Período. Enquanto os dados sobreviverem, você terá a chance de usá -los - potencialmente muito tempo depois do aplicativo original que o escreveu é extinto.

Você pode analisar esse arquivo com apenas conhecimento parcial de seu formato; Com a maioria dos arquivos binários, você deve conhecer todos os detalhes de todo o formato para analisá -lo com sucesso.

Considere um arquivo de dados de algum sistema herdado que você recebe. [24] Você sabe pouco sobre o aplicativo original; Tudo o que é importante para você é que ele manteve uma lista dos números de seguridade social dos clientes, que você precisa encontrar e extrair. Entre os dados, você vê

Reconhecendo o formato de um número de previdência social, você pode escrever rapidamente um pequeno programa para extrair esses dados - mesmo que você não tenha informações sobre mais nada no arquivo.

Mas imagine se o arquivo tivesse sido formatado desta maneira:

Você pode não ter reconhecido o significado dos números com a mesma facilidade. Essa é a diferença entre o humano legível e o humano compreensível.

Enquanto estamos nisso, Field10 também não ajuda muito. Algo como


Torna o exercício um acéfalo-e garante que os dados sobrevilem a qualquer projeto que o criasse.

Aproveitar
Praticamente todas as ferramentas no universo de computação, desde sistemas de controle de versão a editores e ferramentas de linha de comando, podem operar em texto sem formatação.

A filosofia do UNIX
A Unix é famosa por ser projetada em torno da filosofia de pequenas ferramentas afiadas, cada uma pretendia fazer uma coisa bem. Essa filosofia é ativada usando um formato subjacente comum-o arquivo de texto simples, orientado a linha. Os bancos de dados usados para administração do sistema (usuários e senhas, configuração de rede e assim por diante) são mantidos como arquivos de texto simples. (Alguns sistemas também mantêm uma forma binária de determinados bancos de dados como uma otimização de desempenho. A versão de texto simples é mantido como uma interface para a versão binária.)

Quando um sistema trava, você pode enfrentar apenas um ambiente mínimo para restaurá -lo (talvez não consiga acessar drivers gráficos, por exemplo). Situações como essa podem realmente fazer você apreciar a simplicidade do texto simples.

O texto simples também é mais fácil de pesquisar. Se você não consegue se lembrar de qual arquivo de configuração gerencia os backups do sistema, um backup rápido de grep -r /etc. deve dizer.

Por exemplo, suponha que você tenha uma implantação de produção de um grande aplicativo com um arquivo de configuração específico do site complexo. Se este arquivo estiver em texto simples, você pode colocá -lo em um sistema de controle de versão (consulte o tópico 19, controle de versão), para manter automaticamente um histórico de todas as alterações. Ferramentas de comparação de arquivos, como DIFF e FC, permitem que você veja de relance quais mudanças foram feitas, enquanto a SUM permite gerar uma soma de verificação para monitorar o arquivo para modificação acidental (ou maliciosa).

Testes mais fáceis
Se você usar texto simples para criar dados sintéticos para direcionar testes do sistema, é uma questão simples de adicionar, atualizar ou modificar os dados de teste sem precisar criar nenhuma ferramenta especial para fazê -lo. Da mesma forma, a saída de texto simples dos testes de regressão pode ser analisado trivialmente com comandos de shell ou um script simples.

Denominador comum mais baixo
Mesmo no futuro dos agentes inteligentes baseados em blockchain que viajam pela Internet selvagem e perigosa da Internet, negociando o intercâmbio de dados entre si, o onipresente arquivo de texto ainda estará lá. Na verdade,
Em ambientes heterogêneos, as vantagens do texto simples podem superar todas as desvantagens. Você precisa garantir que todas as partes possam se comunicar usando um padrão comum. Texto simples é esse padrão.

Seções relacionadas incluem
Tópico 17, jogos de shell
Tópico 21, manipulação de texto
Tópico 32, configuração

Desafios

Projete um pequeno banco de dados de livro de endereços (nome, número de telefone e assim por diante) usando uma representação binária direta em seu idioma de escolha. Faça isso antes de ler o resto deste desafio.

Traduza esse formato em um formato de texto simples usando XML ou JSON.

Para cada versão, adicione um novo campo de comprimento variável chamado instruções nas quais você pode inserir instruções para a casa de cada pessoa.

Que problemas surgem em relação ao versão e extensibilidade? Qual forma era mais fácil de modificar? Que tal converter dados existentes?



Tópico 17 - jogos de shell

Todo marceneiro precisa de uma bancada boa, sólida e confiável, em algum lugar para manter peças de trabalho em uma altura conveniente enquanto estão sendo moldadas. A bancada se torna o centro da oficina, o fabricante retornando a ele uma e outra vez quando uma peça toma forma.

Para um programador manipulando arquivos de texto, esse workbench é o shell de comando. No prompt do Shell, você pode invocar todo o seu repertório de ferramentas, usando tubos para combiná -los de maneiras nunca sonhadas por seus desenvolvedores originais. Do shell, você pode lançar aplicativos, depuradores, navegadores, editores e serviços públicos. Você pode pesquisar arquivos, consultar o status do sistema e filtrar a saída. E ao programar o shell, você pode criar comandos macro complexos para atividades que executam com frequência.

Para programadores criados em interfaces da GUI e ambientes de desenvolvimento integrado (IDES), isso pode parecer uma posição extrema. Afinal, você não pode fazer tudo igualmente bem apontando e clicando?

A resposta simples é “não '' 'as interfaces da GUI são maravilhosas e podem ser mais rápidas e mais convenientes para algumas operações simples. Mover arquivos, ler e escrever email e construir e implantar seu projeto são tudo o que você pode fazer em que você não pode fazer o seu ambiente. Para combinar suas ferramentas para criar ferramentas de macro personalizadas.

Os ambientes da GUI são normalmente limitados aos recursos que seus designers pretendiam. Se você precisar ir além do modelo que o designer forneceu, geralmente está sem sorte - e na maioria das vezes, precisa ir além do modelo. Os programadores pragmáticos não apenas cortam código, ou desenvolvem modelos de objetos, ou escrevem documentação ou automatizam o processo de construção - fazemos todas essas coisas. O escopo de qualquer ferramenta geralmente é limitado às tarefas que a ferramenta deve executar. Por exemplo, suponha que você precise integrar um pré-processador de código (para implementar o design por contrato, ou Pragmas com vários processos, ou algo assim) no seu IDE. A menos que o designer do IDE tenha fornecido explicitamente ganchos para essa capacidade, você não pode fazê -lo.

Dica 26 Use o poder dos shells de comando
Fique familiarizado com a concha e você encontrará sua produtividade crescente. Precisa criar uma lista de todos os nomes exclusivos de pacotes explicitamente importados pelo seu código Java? Os seguintes armazenam em um arquivo chamado “List '':

Se você não passou muito tempo explorando os recursos do shell de comando nos sistemas que você usa, isso pode parecer assustador. No entanto, invista alguma energia para se familiarizar com sua concha e as coisas em breve começarão a se encaixar. Brinque com o seu shell de comando e você ficará surpreso com o quanto mais produtivo o torna.

Uma concha própria
Da mesma forma que um trabalhador marceneiro personalizará seu espaço de trabalho, um desenvolvedor deve personalizar seu shell. Isso normalmente também envolve alterar a configuração do programa de terminal que você usa.

As mudanças comuns incluem:

Definir temas de cores. Muitas, muitas horas podem ser gastas experimentando todos os temas disponíveis on -line para o seu shell específico.

Configurando um prompt. O aviso que informa que o shell está pronto para que você digite um comando pode ser configurado para exibir praticamente qualquer informação que você queira (e um monte de coisas que você nunca desejaria). As preferências pessoais são tudo aqui: tendemos a gostar de simples
Prompts, com um nome de diretório atual e o status de controle de versão junto com o tempo.

Aliases e funções da concha. Simplifique seu fluxo de trabalho transformando os comandos que você usa muito em aliases simples. Talvez você atualize regularmente sua caixa Linux, mas nunca se lembra se você atualiza e atualiza ou atualiza e atualiza. Crie um pseudônimo:

Alias apt-up = 'sudo apt-get update && sudo apt-get upgrade'
Talvez você tenha excluído acidentalmente arquivos com o comando rm apenas uma vez. Escreva um pseudônimo para que sempre solicite no futuro:

Alias rm = 'rm -iv'
Conclusão de comando. A maioria dos shells completará os nomes de comandos e arquivos: digite os primeiros caracteres, pressione a guia e preencherá o que pode. Mas você pode levar isso muito mais longe, configurando o shell para reconhecer o comando que você está inserindo e oferecer conclusões específicas do contexto. Alguns até personalizam a conclusão, dependendo do diretório atual.

Você passará muito tempo vivendo em uma dessas conchas. Seja como um caranguejo eremita e faça com que seja sua própria casa.

Seções relacionadas incluem
Tópico 13, protótipos e notas post-it
Tópico 16, o poder do texto simples
Tópico 21, manipulação de texto
Tópico 30, transformando a programação
Tópico 51, kit iniciante pragmático

Desafios

Existem coisas que você está fazendo manualmente em uma GUI? Você já passa instruções para colegas que envolvem vários etapas individuais de “clique neste botão”, “selecione este item”? Isso poderia ser automatizado?

Sempre que você se mudar para um novo ambiente, faça um ponto de descobrir quais conchas estão disponíveis. Veja se você pode trazer sua concha atual com você.

Investigue alternativas ao seu shell atual. Se você se deparar com um problema que seu shell não pode resolver, verifique se um shell alternativo seria melhor lidar.




Tópico 18 - Edição de energia

Já conversamos antes sobre as ferramentas serem uma extensão da sua mão. Bem, isso se aplica aos editores mais do que a qualquer outra ferramenta de software. Você precisa ser capaz de manipular o texto da maneira mais fácil possível, porque o texto é a matéria -prima básica da programação.

Na primeira edição deste livro, recomendamos o uso de um único editor para tudo: código, documentação, memorandos, administração do sistema e assim por diante. Nós amolecemos um pouco essa posição. Estamos felizes por você usar quantos editores quiser. Gostaríamos que você trabalhasse em direção à fluência em cada um.

DICA 27 - ALCHE

Por que isso é um grande negócio? Estamos dizendo que você economizará muito tempo? Na verdade, sim: ao longo de um ano, você pode realmente ganhar uma semana adicional se tornar sua edição apenas 4% mais eficiente e editar por 20 horas por semana.

Mas esse não é o benefício real. Não, o grande ganho é que, ao se tornar fluente, você não precisa mais pensar na mecânica da edição. A distância entre pensar em algo e fazê -lo aparecer em um buffer de editor cair. Seus pensamentos fluirão e sua programação se beneficiará. (Se você já ensinou alguém a dirigir, entenderá a diferença entre alguém que tem que pensar em todas as ações que tomam e um motorista mais experiente que controla o carro instintivamente.)

O que significa "fluente"?
O que conta como sendo fluente? Aqui está a lista de desafios:

Ao editar o texto, mova e faça seleções por personagem, palavra, linha e parágrafo.

Ao editar o código, mova -se por várias unidades sintáticas (correspondentes delimitadores, funções, módulos,…).

Código de reindicação após alterações.

Comentários e bloqueios de descomamento de código com um único comando.

Desfazer e refazer mudanças.

Divida a janela do editor em vários painéis e navegue entre eles.

Navegue para um número de linha específico.

Classificar linhas selecionadas.

Pesquise as cordas e expressões regulares e repita as pesquisas anteriores.

Crie temporariamente vários cursores com base em uma seleção ou em uma correspondência de padrão e edite o texto em cada um em paralelo.

Exibir erros de compilação no projeto atual.

Execute os testes do projeto atual.

Você pode fazer tudo isso sem usar um mouse/trackpad?

Você pode dizer que seu editor atual não pode fazer algumas dessas coisas. Talvez seja hora de mudar?

Movendo -se em direção à fluência
Duvidamos que haja mais do que um punhado de pessoas que conhecem todos os comandos em qualquer editor poderoso em particular. Também não esperamos que você o faça. Em vez disso, sugerimos uma abordagem mais pragmática: aprenda os comandos que facilitam sua vida.

A receita para isso é bastante simples.

Primeiro, olhe para si mesmo enquanto você está editando. Toda vez que você se vê fazendo algo repetitivo, entre
O hábito de pensar "deve haver uma maneira melhor". Em seguida, encontre -o.

Depois de descobrir um recurso novo e útil, agora você precisa instalá -lo na memória muscular, para que você possa usá -lo sem pensar. A única maneira de fazer isso é através da repetição. Conscientemente, procure oportunidades de usar sua nova superpotência, idealmente muitas vezes por dia. Depois de uma semana, você descobrirá que o usa sem pensar.

Cultivando seu editor
A maioria dos poderosos editores de código é construída em torno de um núcleo básico que é aumentado através de extensões. Muitos são fornecidos com o editor e outros podem ser adicionados posteriormente.

Quando você se deparar com uma aparente limitação do editor que você está usando, procure uma extensão que fará o trabalho. As chances são de que você não esteja sozinho precisando dessa capacidade e, se você tiver sorte, outra pessoa terá publicado sua solução.

Dê isso um passo adiante. Cavar a linguagem de extensão do seu editor. Descubra como usá -lo para automatizar algumas das coisas repetitivas que você faz. Muitas vezes, você precisará apenas de uma ou duas linhas de código.

Às vezes, você pode levá-lo ainda mais ainda, e você se encontrará escrevendo uma extensão completa. Nesse caso, publique -o: se você precisar, outras pessoas também.

Seções relacionadas incluem

Tópico 7, comunique!

Desafios

Não há mais autor de automóveis.

Todo mundo faz isso: você precisa excluir a última palavra que digitou, então pressiona o backspace e aguarda o início do AutoRepeat. Na verdade, apostamos que seu cérebro fez isso tanto que você pode julgar exatamente quando liberar a chave.

Portanto, desligue o AutorePeat e aprenda as seqüências de chave para mover, selecionar e excluir por caracteres, palavras, linhas e blocos.

Este vai doer.

Perca o mouse/trackpad. Por uma semana inteira, edite usando apenas o teclado. Você descobrirá um monte de coisas que você não pode fazer sem apontar e clicar, então agora é a hora de aprender. Mantenha as anotações (recomendamos ir à velha escola e usar lápis e papel) das principais seqüências que você aprende.

Você levará uma produtividade por alguns dias. Mas, ao aprender a fazer coisas sem afastar as mãos da posição inicial, você descobrirá que sua edição se torna mais rápida e mais fluente do que nunca no passado.

Procure integrações. Ao escrever este capítulo, Dave se perguntou se poderia visualizar o layout final (um arquivo PDF) em um buffer do editor. Um download mais tarde, o layout está sentado ao lado do texto original, tudo no editor. Mantenha uma lista de coisas que você gostaria de trazer para o seu editor e procure -as.

Um pouco mais ambiciosamente, se você não conseguir encontrar um plug -in ou extensão que faça o que quiser, escreva um. Andy gosta de fazer plugins wiki locais baseados em arquivos personalizados para seus editores favoritos. Se você não conseguir encontrá -lo, construa!




Tópico 19 - Controle de versão

O progresso, longe de consistir na mudança, depende da retenção. Aqueles que não conseguem se lembrar do passado são condenados a repeti -lo.

George Santayana, vida da razão
Uma das coisas importantes que procuramos em uma interface do usuário é a chave de desfazer - um botão único que nos perdoa nossos erros. É ainda melhor se o ambiente suportar vários níveis de desfazer e refazer, para que você possa voltar e se recuperar de algo que aconteceu alguns minutos atrás.

Mas e se o erro acontecesse na semana passada, e você desligue o computador dez vezes desde então? Bem, esse é um dos muitos benefícios do uso de um sistema de controle de versão (VCS): é uma chave gigante de desfazer-uma máquina do tempo em todo o projeto que pode devolvê-lo a esses dias de Halcyon da semana passada, quando o código realmente compilou e executou.

Para muitas pessoas, esse é o limite do uso do VCS. Essas pessoas estão perdendo um mundo totalmente maior de colaboração, pipelines de implantação, rastreamento de problemas e interação geral da equipe.

Então, vamos dar uma olhada no VCS, primeiro como um repositório de mudanças e depois como um local de encontro central para sua equipe e seu código.

Diretórios compartilhados não são controle de versão
Ainda encontramos a equipe ocasional que compartilha seus arquivos de origem do projeto em uma rede: internamente ou usando algum tipo de armazenamento em nuvem.

Isso não é viável.

As equipes que fazem isso estão constantemente atrapalhando o trabalho um do outro, perdendo mudanças, quebrando construções e entrando em brigas no estacionamento. É como escrever código simultâneo com dados compartilhados e nenhum mecanismo de sincronização. Use o controle da versão.

Mas há mais! Algumas pessoas usam o controle de versão e mantêm seu repositório principal em uma rede de rede ou nuvem. Eles argumentam isso
Este é o melhor dos dois mundos: seus arquivos são acessíveis em qualquer lugar e (no caso do armazenamento em nuvem), é o backup fora do local.

Acontece que isso é ainda pior e você corre o risco de perder tudo. O software de controle de versão usa um conjunto de arquivos e diretórios de interação. Se duas instâncias fizeram alterações simultaneamente, o estado geral poderá ser corrompido e não há como dizer quanto dano será causado. E ninguém gosta de ver os desenvolvedores chorarem.

Começa na fonte
Os sistemas de controle de versão acompanham todas as alterações que você faz em seu código -fonte e documentação. Com um sistema de controle de código fonte configurado corretamente, você sempre pode voltar a uma versão anterior do seu software.

Mas um sistema de controle de versão faz muito mais do que os erros. Um bom VCS permitirá rastrear alterações, respondendo a perguntas como: quem fez alterações nessa linha de código? Qual é a diferença entre a versão atual e a da semana passada? Quantas linhas de código mudamos nesta versão? Quais arquivos são alterados com mais frequência? Esse tipo de informação é inestimável para fins de rastreamento, auditoria, desempenho e qualidade de insetos.

Um VCS também permitirá que você identifique os lançamentos do seu software. Uma vez identificado, você sempre poderá voltar e regenerar a liberação, independentemente das alterações que podem ter ocorrido posteriormente.

Os sistemas de controle de versão podem manter os arquivos que mantêm em um repositório central - um ótimo candidato para o arquivamento.

Por fim, os sistemas de controle de versão permitem que dois ou mais usuários trabalhem simultaneamente no mesmo conjunto de arquivos, até fazendo alterações simultâneas no mesmo arquivo. O sistema gerencia a fusão dessas alterações quando os arquivos são enviados de volta ao repositório. Embora aparentemente arriscados, esses sistemas funcionam bem na prática em projetos de todos os tamanhos.

Dica 28 Sempre use o controle da versão
Sempre. Mesmo se você é uma equipe de uma única pessoa em um projeto de uma semana. Mesmo que seja um protótipo "arremessado". Mesmo que o material em que você esteja trabalhando não seja o código-fonte. Verifique se tudo está sob controle da versão: documentação, listas de números de telefone, memorandos para fornecedores, makefiles, construir e liberar procedimentos, que não se trata de que todos os que estão em que se retenhamos um pouco de que o que é o que se reúne), incluindo um pouco de que o que se reeve. repositório.

Ramificando -se
Os sistemas de controle de versão não mantêm apenas um único histórico do seu projeto. Uma de suas características mais poderosas e úteis é a maneira como eles permitem que você isole ilhas de desenvolvimento em coisas chamadas ramos. Você pode criar uma filial a qualquer momento da história do seu projeto, e qualquer trabalho que você fizer nessa filial será isolado de todas as outras agências. Em algum momento, no futuro, você pode mesclar a filial em que está trabalhando em outra filial, para que o ramo de destino agora contenha as alterações que você fez em sua filial. Várias pessoas podem até trabalhar em uma filial: de certa forma, as filiais são como pequenos projetos de clones.

Um benefício dos ramos é o isolamento que eles lhe dão. Se você desenvolver o recurso A em uma filial e um companheiro de equipe trabalha no recurso B em outro, você não vai interferir entre si.

Um segundo benefício, o que pode ser surpreendente, é que as filiais geralmente estão no centro do fluxo de trabalho do projeto de uma equipe.

E é aqui que as coisas ficam um pouco confusas. As filiais de controle de versão e a organização de testes têm algo em comum: ambos têm milhares de pessoas por aí dizendo como você deve fazê -lo. E esse conselho é em grande parte sem sentido, porque o que eles estão realmente dizendo é "isso é o que funcionou para mim".

Portanto, use o controle da versão em seu projeto e, se você encontrar problemas de fluxo de trabalho, procure possíveis soluções. E lembre -se de revisar e ajustar o que você está fazendo ao ganhar experiência.

Um experimento de pensamento
Derrame uma xícara inteira de chá (café da manhã inglês, com um pouco de leite) no teclado do laptop. Leve a máquina para a barra de pessoa inteligente e peça a eles tut e franzir a testa. Compre um novo computador. Leve para casa.

Quanto tempo levaria para levar a máquina de volta ao mesmo estado em que estava (com todas as teclas SSH, configuração do editor, configuração do shell, aplicativos instalados etc.) no ponto em que você levantou a primeira Copa fatídica? Este foi um problema que um de nós enfrentou recentemente.

Quase tudo o que definiu a configuração e o uso da máquina original foi armazenado no controle de versão, incluindo:

Todas as preferências do usuário e dotfiles
A configuração do editor
A lista de
software instalado usando homebrew
O script Ansible usado para configurar aplicativos
Todos os projetos atuais
A máquina foi restaurada até o final da tarde.

Controle de versão como um hub de projeto
Embora o controle de versão seja incrivelmente útil em projetos pessoais, ele realmente se aproxima ao trabalhar com uma equipe. E grande parte desse valor vem de como você hospeda seu repositório.

Agora, muitos sistemas de controle de versão não precisam de nenhuma hospedagem. Eles são completamente descentralizados, com cada desenvolvedor cooperando em uma base ponto a ponto. Mas mesmo com esses sistemas, vale a pena ter um repositório central, porque, uma vez que você o fizer, você pode aproveitar uma tonelada de integrações para facilitar o fluxo do projeto.

Muitos dos sistemas de repositório são de código aberto, para que você possa instalá -los e executá -los em sua empresa. Mas essa não é realmente sua linha de negócios, então recomendamos que a maioria das pessoas hospede com terceiros. Procure recursos como:

Boa segurança e controle de acesso
UI intuitiva
A capacidade de fazer tudo da linha de comando também (porque você pode precisar automatizá -la)
Construções e testes automatizados
Bom suporte para a fusão da filial (às vezes chamado de solicitações de tração)
Gerenciamento de problemas (idealmente integrado às comissões e fumegas, para que você possa manter as métricas)
Bons relatórios (uma exibição de questões e tarefas pendentes de tabuleiro Kanban pode ser muito útil)
Boas comunicações de equipe: e -mails ou outras notificações sobre mudanças, um wiki e assim por diante
Muitas equipes têm seus VCs configurados para que um impulso para uma filial específica construa automaticamente o sistema, execute os testes e se for bem -sucedido implantar o novo código na produção.

Parece assustador? Não quando você percebe que está usando o controle da versão. Você sempre pode rolar de volta.

Seções relacionadas incluem
Tópico 11, reversibilidade
Tópico 49, equipes pragmáticas
Tópico 51, kit iniciante pragmático
Desafios
Saber que você pode voltar a qualquer estado anterior usando o VCS é uma coisa, mas você pode realmente fazer isso? Você conhece os comandos para fazê -lo corretamente? Aprenda -os agora, não quando ocorre o desastre e você estará sob pressão.

Passe algum tempo pensando em recuperar seu próprio ambiente de laptop em caso de desastre. O que você precisaria se recuperar? Muitas das coisas que você precisa são apenas arquivos de texto. Se eles não estiverem em um VCS (hospedado no seu laptop), encontre uma maneira de adicioná -los. Em seguida, pense nas outras coisas: aplicativos instalados, configuração do sistema e assim por diante. Como você pode expressar tudo isso nos arquivos de texto para que também possa ser salvo?

Um experimento interessante, depois de fazer algum progresso, é encontrar um computador antigo que você não usa mais e ver se seu novo sistema pode ser usado para configurá -lo.

Explore conscientemente os recursos do seu VCS atual e do provedor de hospedagem que você não está usando. Se sua equipe não estiver usando ramificações de recursos, experimente apresentá -las. O mesmo com solicitações de puxar/mesclagem. Integração contínua. Construir pipelines. Até mesmo implantação contínua. Olhe para as ferramentas de comunicação da equipe também: wikis, Kanban Boards e similares.

Você não precisa usar nada disso. Mas você precisa saber o que faz para que você possa tomar essa decisão.

Use o controle da versão para coisas sem projeto também.







Tópico 20 - Depuração

É uma coisa dolorosa
Olhar para o seu próprio problema e saber
Que você mesmo e ninguém mais fez isso
Sófocles, Ajax

A palavra bug tem sido usada para descrever um “objeto de terror '' desde o século XIV. O almirante traseiro Dr. Grace Hopper, o inventor de COBOL, é creditado por observar o primeiro bug do computador - literalmente, uma trapaça capturada em um relé em um sistema de computador. Livro de registro.

Lamentavelmente, ainda temos bugs no sistema, embora não do tipo voador. Mas o significado do século XIV - um bicho -papão - talvez seja ainda mais aplicável agora do que era então. Os defeitos de software se manifestam de várias maneiras, de requisitos incompreendidos a erros de codificação. Infelizmente, os sistemas de computador modernos ainda se limitam a fazer o que você diz para eles, não necessariamente o que você quer que eles façam.

Ninguém escreve software perfeito, por isso é certo que a depuração ocupará uma grande parte do seu dia. Vejamos algumas das questões envolvidas na depuração e algumas estratégias gerais para encontrar bugs indescritíveis.

Psicologia da depuração
A depuração é um assunto sensível e emocional para muitos desenvolvedores. Em vez de atacá -lo como um quebra -cabeça para ser
Resolvido, você pode encontrar negação, apontar o dedo, desculpas coxas ou simplesmente apatia.

Abrace o fato de que a depuração é apenas a solução de problemas e atacá -la como tal.

Tendo encontrado o bug de outra pessoa, você pode gastar tempo e energia culpar o culpado imundo que o criou. Em alguns locais de trabalho, isso faz parte da cultura e pode ser catártico. No entanto, na arena técnica, você deseja se concentrar em corrigir o problema, não a culpa.

Dica 29 Corrija o problema, não a culpa
Realmente não importa se o bug é sua culpa ou de outra pessoa. Ainda é o seu problema.

Uma mentalidade de depuração
Antes de começar a depurar, é importante adotar a mentalidade certa. Você precisa desligar muitas das defesas que você usa todos os dias para proteger seu ego, ajustar as pressões do projeto que você estará e se sinta confortável. Acima de tudo, lembre -se da primeira regra de depuração:

Dica 30 não entre em pânico
É fácil entrar em pânico, especialmente se você estiver enfrentando um prazo ou tiver um chefe nervoso ou o cliente respirando seu pescoço enquanto estiver tentando encontrar a causa do bug. Mas é muito importante recuar e pensar no que poderia estar causando os sintomas que você acredita indicar um bug.

Se sua primeira reação ao testemunhar um bug ou ver um relatório de bug é "isso é impossível", você está claramente errado. Não desperdice um único neurônio na linha de pensamento que começa "mas isso não pode acontecer" porque claramente pode, e tem.

Cuidado com a miopia ao depurar. Resista ao desejo de corrigir apenas os sintomas que você vê: é mais provável que a falha real possa ser várias etapas removidas do que você está observando e pode envolver várias outras coisas relacionadas. Sempre tente descobrir a causa raiz de um problema, não apenas essa aparência específica.

Por onde começar
Antes de começar a olhar para o bug, verifique se você está trabalhando no código que construiu de maneira limpa - sem avisos. Rotineiramente, definimos os níveis de aviso do compilador o mais alto possível. Não faz sentido perder tempo tentando encontrar um problema que o computador possa encontrar para você! Precisamos nos concentrar nos problemas mais difíceis em questão.

Ao tentar resolver qualquer problema, você precisa reunir todos os dados relevantes. Infelizmente, o relatório de bugs não é uma ciência exata. É fácil ser enganado por coincidências, e você não pode se dar ao luxo de perder tempo depurando coincidências. Você primeiro precisa ser preciso em suas observações.

A precisão nos relatórios de bugs diminui ainda mais quando eles passam por terceiros - você pode realmente precisar assistir ao usuário que relatou o bug em ação para obter um nível de detalhe suficiente.

Andy já trabalhou em um grande aplicativo gráfico. No final da liberação, os testadores relataram que o aplicativo travava toda vez que pintava um golpe com um pincel específico. O programador responsável argumentou que não havia nada de errado nisso; Ele tentou pintar com ele, e funcionou muito bem. Esse diálogo voltou e voltou por vários dias, com os ânimos aumentando rapidamente.

Finalmente, nós os reunimos na mesma sala. O testador selecionou a ferramenta de pincel e pintou um golpe no canto superior direito até o canto inferior esquerdo. O aplicativo explodiu. "Oh", disse o programador, em uma pequena voz, que então admitiu timidamente que havia feito traços de teste apenas do canto inferior esquerdo para o canto superior direito, o que não expôs o bug.

Há dois pontos nesta história:

Pode ser necessário entrevistar o usuário que relatou o bug para coletar mais dados do que você foi fornecido inicialmente.

Testes artificiais (como a pincelada única do programador de baixo para cima) não exercem um aplicativo suficiente. Você deve testar brutalmente as condições de contorno e os padrões realistas de uso do usuário final. Você precisa fazer isso sistematicamente (consulte testes cruéis e contínuos).

Estratégias de depuração
Depois de pensar que sabe o que está acontecendo, é hora de descobrir o que o programa pensa que está acontecendo.

Reproduzindo bugs
Não, nossos bugs não estão realmente se multiplicando (embora alguns deles provavelmente tenham idade suficiente para fazê -lo legalmente). Estamos falando de um tipo diferente de reprodução.

A melhor maneira de começar a corrigir um bug é torná -lo reproduzível. Afinal, se você não pode reproduzi -lo, como saberá se já foi corrigido?

Mas queremos mais do que um bug que pode ser reproduzido seguindo algumas longas séries de etapas; Queremos um bug que possa ser reproduzido com um único comando. É muito mais difícil corrigir um bug se você precisar seguir 15 etapas para chegar ao ponto em que o bug mostra
acima.

Então, aqui está a regra mais importante de depuração:

Dica 31 Teste de falha antes de corrigir o código
Às vezes, forçando -se a isolar as circunstâncias que exibem o bug, você até obterá uma visão de como corrigi -lo. O ato de escrever o teste informa a solução.

Codificador em uma terra estranha
Toda essa conversa sobre o isolamento do bug é boa, quando se depara com 50.000 linhas de código e um relógio, o que um pobre codificador deve fazer?

Primeiro, veja o problema. É um acidente? É sempre surpreendente quando ensinamos cursos que envolvem a programação de quantos desenvolvedores veem uma exceção aparecer em vermelho e imediatamente procurar no código.

Dica 32 Leia a maldita mensagem de erro
Nuf disse.

Resultados ruins
E se não for um acidente? E se for apenas um resultado ruim?

Entre lá com um depurador e use seu teste de falha para acionar o problema.

Antes de qualquer outra coisa, verifique se você também está vendo o valor incorreto no depurador. Nós dois perdemos horas tentando rastrear um bug apenas para descobrir que essa execução específica do código funcionou bem.

Às vezes, o problema é óbvio: o interesse_rate é 4,5 e deve ser 0,045. Mais frequentemente, você deve parecer mais profundo para descobrir por que o valor está errado em primeiro lugar. Certifique -se de saber como subir e descer a pilha de chamadas e examinar o ambiente de pilha local.

Achamos que muitas vezes ajuda a manter a caneta e o papel por perto, para que possamos anotar as notas. Em particular, frequentemente encontramos uma pista e a perseguimos, apenas para descobrir que não deu certo. Se não anoçássemos onde estávamos quando começamos a perseguição, poderíamos perder muito tempo voltando para lá.

Às vezes você está olhando para um rastreamento de pilha que parece rolar para sempre. Nesse caso, muitas vezes há uma maneira mais rápida de encontrar o problema do que examinar cada quadro de pilha: use uma costeleta binária. Mas antes de discutirmos isso, vejamos dois outros cenários comuns de insetos.

Sensibilidade aos valores de entrada
Você esteve lá. Seu programa funciona bem com todos os dados do teste e sobrevive à sua primeira semana em produção com honra. Então ele trava de repente quando alimentado um conjunto de dados específico.

Você pode tentar olhar para o local em que trava e trabalha para trás. Mas às vezes é mais fácil começar com os dados. Obtenha uma cópia do conjunto de dados e alimente -o através de uma cópia em execução localmente do aplicativo, certificando -se de que ele ainda trava. Em seguida, corte os dados binários até que você isole exatamente quais valores de entrada estão levando ao acidente.

Regressões entre lançamentos
Você está em uma boa equipe e libera seu software na produção. Em algum momento, um bug aparece no código que funcionou bem há uma semana. Não seria bom se você pudesse identificar a mudança específica que a introduziu? Adivinha? Tempo binário de corte.

A costeleta binária
Cada estudante de graduação do CS foi forçada a codificar uma costeleta binária (às vezes chamada de pesquisa binária). A ideia é simples. Você está procurando um valor específico em uma matriz classificada. Você pode apenas olhar para cada valor por sua vez, mas acabaria olhando para aproximadamente metade das entradas, em média, até encontrar o valor que queria ou encontrou um valor maior que ele, o que significaria que o valor não está na matriz.

Mas é mais rápido usar uma abordagem de divisão e conquista. Escolha um valor no meio da matriz. Se é o que você está procurando, pare. Caso contrário, você pode cortar a matriz em dois. Se o valor encontrado for maior que o alvo, você sabe que ele deve estar na primeira metade da matriz, caso contrário, será no segundo tempo. Repita o procedimento no subarray apropriado e, em pouco tempo, você terá um resultado. (Como veremos quando falamos sobre a notação Big-O, uma pesquisa linear é superior para parênteses esquerdos e parênteses direito, e uma costeleta binária é superior para parênteses esquerdo e parênteses direita parênteses).

Portanto, a costeleta binária é muito mais rápida em qualquer problema de tamanho decente. Vamos ver como aplicá -lo na depuração.

Quando você está enfrentando um enorme stacktrace e está tentando descobrir exatamente qual função mutilou o valor em erro, você faz um corte escolhendo um quadro de pilha em algum lugar do meio e vendo se o erro é manifesto lá. Se for, você saberá se concentrar nos quadros antes, caso contrário, o problema estará nos quadros depois. Pique novamente. Mesmo se você tiver 64 quadros no Stacktrace, essa abordagem fornecerá uma resposta depois de no máximo seis tentativas.

Se você encontrar bugs que aparecem em determinados conjuntos de dados, poderá fazer a mesma coisa. Divida o conjunto de dados em dois e veja se o problema ocorre se você alimentar um ou outro através do aplicativo. Continue dividindo os dados até obter um mínimo
conjunto de valores que exibem o problema.

Se sua equipe introduziu um bug durante um conjunto de lançamentos, você poderá usar o mesmo tipo de técnica. Crie um teste que faça com que a liberação atual falhe. Em seguida, escolha um lançamento metade do caminho entre agora e a última versão de trabalho conhecida. Execute o teste novamente e decida como restringir sua pesquisa. Ser capaz de fazer isso é apenas um dos muitos benefícios de ter um bom controle de versão em seus projetos. De fato, muitos sistemas de controle de versão levarão isso adiante e automatizarão o processo, escolhendo versões para você, dependendo do resultado do teste.

Registro e/ou rastreamento
Debuggers geralmente se concentram no estado do programa agora. Às vezes, você precisa de mais - você precisa assistir ao estado de um programa ou estrutura de dados ao longo do tempo. Ver um rastreamento de pilha só pode dizer como você chegou diretamente aqui. Normalmente, não pode dizer o que você estava fazendo antes dessa cadeia de chamadas, especialmente em sistemas baseados em eventos. [25]

As declarações de rastreamento são aquelas pequenas mensagens de diagnóstico que você imprime na tela ou em um arquivo que dizem coisas como "Get aqui" e "Valor de x = 2". É uma técnica primitiva em comparação com os depuradores no estilo IDE, mas é particularmente eficaz no diagnóstico de várias classes de erros que os depuradores não podem. O rastreamento é inestimável em qualquer sistema em que o tempo em si seja um fator: processos simultâneos, sistemas em tempo real e aplicativos baseados em eventos.

Você pode usar instruções de rastreamento para perfurar o código. Ou seja, você pode adicionar declarações de rastreamento ao descer a árvore de chamadas.

As mensagens de rastreamento devem estar em um formato regular e consistente, pois você pode analisá -las automaticamente. Por exemplo, se você precisava rastrear um vazamento de recursos (como o arquivo desequilibrado abre/fecha), você pode rastrear cada um aberto e cada um fechado em um arquivo de log. Ao processar o arquivo de log com ferramentas de processamento de texto ou comandos de shell, você pode identificar facilmente onde o aberto ofensivo estava ocorrendo.

Borracha se esquivando
Uma técnica muito simples, mas particularmente útil, para encontrar a causa de um problema, é simplesmente explicá -la a outra pessoa. A outra pessoa deve olhar por cima do ombro na tela e acenar com a cabeça constantemente (como um pato de borracha balançando para cima e para baixo em uma banheira). Eles não precisam dizer uma palavra; O simples ato de explicar, passo a passo, o que o código deve fazer geralmente faz com que o problema salte da tela e se anuncia. [26]

Parece simples, mas, ao explicar o problema para outra pessoa, você deve declarar explicitamente as coisas que você pode dar como certo ao passar pelo código. Ao ter que verbalizar algumas dessas suposições, você pode de repente obter uma nova visão do problema. E se você não tem uma pessoa, um pato de borracha ou ursinho de pelúcia, ou planta em vaso servirá. [27]

Processo de eliminação
Na maioria dos projetos, o código que você está depuração pode ser uma mistura de código de aplicativo escrito por você e outras pessoas em sua equipe de projeto, produtos de terceiros (banco de dados, conectividade, estrutura da web, comunicações ou algoritmos especializados e assim por diante) e o ambiente da plataforma (sistema operacional, bibliotecas de sistemas e compiladores).

É possível que exista um bug no sistema operacional, no compilador ou em um produto de terceiros-mas esse não deve ser o seu primeiro pensamento. É muito mais provável que o bug exista no código do aplicativo em desenvolvimento. Geralmente, é mais lucrativo supor que o código do aplicativo está entrando incorretamente em uma biblioteca do que assumir que a própria biblioteca está quebrada. Mesmo que o problema esteja com terceiros, você ainda precisará eliminar seu código antes de enviar o relatório de bug.

Trabalhamos em um projeto em que um engenheiro sênior estava convencido de que a chamada do sistema selecionada foi quebrada em um sistema UNIX. Nenhuma quantidade de persuasão ou lógica poderia mudar de idéia (o fato de que qualquer outro aplicativo de rede na caixa funcionou bem era irrelevante). Ele passou semanas escrevendo soluções alternativas, o que, por algum motivo estranho, não parecia resolver o problema. Quando finalmente forçado a sentar e ler a documentação em Select, ele descobriu o problema e o corrigiu em questão de minutos. Agora usamos a frase “Select está quebrado '' como um lembrete suave sempre que um de nós começa a culpar o sistema por uma falha que provavelmente será nossa.

Dica 33 "Selecionar" não está quebrada
Lembre -se, se você vir impressão de casco, pense em cavalos - não zebras. O sistema operacional provavelmente não está quebrado. E selecionar provavelmente está bem.

Se você "mudou apenas uma coisa" e o sistema parou de funcionar, é provável que uma coisa seja
Responsável, direta ou indiretamente, não importa o quão exagerado pareça. Às vezes, o que mudou está fora do seu controle: novas versões do sistema operacional, compilador, banco de dados ou outro software de terceiros podem causar estragos no código correto anteriormente. Novos bugs podem aparecer. Os insetos para os quais você teve uma solução alternativa é consertada, quebrando a solução alternativa. Mudança de APIs, mudanças de funcionalidade; Em suma, é um jogo totalmente novo de bola e você deve testar novamente o sistema nessas novas condições. Portanto, fique de olho no cronograma ao considerar uma atualização; Você pode esperar até depois do próximo lançamento.

O elemento de surpresa
Quando você se surpreende com um bug (talvez até murmurando "isso é impossível", debaixo da sua respiração, onde não podemos ouvi -lo), você deve reavaliar as verdades que você tem caro. Nesse algoritmo de cálculo de desconto - aquele que você conhecia era à prova de balas e não poderia ser a causa desse bug - você testou todas as condições de contorno? Esse outro código que você está usando há anos - ainda não poderia ter um bug. Poderia?

Claro que pode. A quantidade de surpresa que você sente quando algo dá errado é proporcional à quantidade de confiança e fé que você tem no código que está sendo executado. É por isso que, quando confrontado com uma falha "surpreendente", você deve aceitar que uma ou mais de suas suposições estejam erradas. Não encomende uma rotina ou um código envolvido no bug, porque você "sabe" que funciona. Prove isso. Prove nesse contexto, com esses dados, com essas condições de limite.

Dica 34 Não assuma isso - forneça
Quando você se depara com um bug surpresa, além de apenas corrigi -lo, precisa determinar por que essa falha não foi pega mais cedo. Considere se você precisa alterar a unidade ou outros testes para que eles o tenham pego.

Além disso, se o bug for o resultado de dados ruins que foram propagados através de alguns níveis antes de causar a explosão, veja se a melhor verificação de parâmetros nessas rotinas o isolaria anteriormente (consulte as discussões sobre travamento cedo e afirmações aqui e aqui, respectivamente).

Enquanto você está nisso, existem outros lugares no código que podem ser suscetíveis a esse mesmo bug? Agora é a hora de encontrá -los e consertá -los. Certifique -se de que o que acontecesse, você saberá se isso acontecer novamente.

Se demorou muito tempo para corrigir esse bug, pergunte a si mesmo. Há algo que você possa fazer para facilitar a fixação desse bug na próxima vez? Talvez você possa criar melhores ganchos de teste ou escrever um analisador de arquivos de log.

Finalmente, se o bug é o resultado da suposição errada de alguém, discuta o problema com toda a equipe: se uma pessoa não entende, é possível que muitas pessoas o façam.

Faça tudo isso e espero que você não fique surpreso na próxima vez.

Lista de verificação de depuração
O problema é relatado como resultado direto do bug subjacente, ou apenas um sintoma?

O bug está realmente na estrutura que você está usando? Está no sistema operacional? Ou está no seu código?

Se você explicasse esse problema em detalhes a um colega de trabalho, o que você diria?

Se o código suspeito passar em seus testes de unidade, os testes serão completos o suficiente? O que acontece se você executar os testes com esses dados?

As condições que causaram esse bug existem em qualquer outro lugar do sistema? Ainda existem outros bugs no estágio larval, apenas esperando para eclodir?

Seções relacionadas incluem
Tópico 24, programas mortos não contam mentiras
Desafios
A depuração é um desafio o suficiente.





Tópico 21 - Manipulação de texto

Programadores pragmáticos manipulam o texto da mesma maneira que os trabalhadores de madeira moldam madeira. Nas seções anteriores, discutimos algumas ferramentas específicas - cascas, editores, depuradores - que usamos. Estes são semelhantes aos formadores, serras e aviões de um trabalhador de madeira - ferramentas especializadas para fazer bem um ou dois empregos. No entanto, de vez em quando precisamos executar alguma transformação não prontamente tratada pelo conjunto de ferramentas básicas. Precisamos de uma ferramenta de manipulação de texto de uso geral.

As linguagens de manipulação de texto devem programar o que os roteadores [28] são para trabalhar madeira. Eles são barulhentos, bagunçados e um tanto brutos. Começa erros com eles, e peças inteiras podem ser arruinadas. Algumas pessoas juram que não têm lugar na caixa de ferramentas. Mas nas mãos certas, os roteadores e as linguagens de manipulação de texto podem ser incrivelmente poderosas e versáteis. Você pode aparar rapidamente algo em forma, fazer articulações e esculpir. Usados corretamente, essas ferramentas têm uma delicadeza e sutileza surpreendente. Mas eles levam tempo para dominar.

Felizmente, existem várias ótimas linguagens de manipulação de texto. Desenvolvedores da Unix (e incluímos usuários de macos aqui) geralmente gostam de usar
O poder de seus conchas de comando, aumentado com ferramentas como awk e sed. As pessoas que preferem uma ferramenta mais estruturada podem preferir idiomas como Python ou Ruby.

Esses idiomas são importantes tecnologias de habilitação. Usando -os, você pode invadir rapidamente os utilitários e as idéias de protótipo - jobs que podem levar cinco ou dez vezes mais tempo usando idiomas convencionais. E esse fator de multiplicação é crucialmente importante para o tipo de experimentação que fazemos. Passar 30 minutos experimentando uma idéia maluca é muito melhor do que passar cinco horas. Passar um dia automatizando componentes importantes de um projeto é aceitável; Passar uma semana pode não ser. Em seu livro The Practice of Programming [KP99], Kernighan e Pike construíram o mesmo programa em cinco idiomas diferentes. A versão Perl foi a mais curta (17 linhas, em comparação com os 150 de C de C). Com o Perl, você pode manipular texto, interagir com programas, conversar sobre redes, dirigir páginas da web, executar aritmética de precisão arbitrária e escrever programas que parecem jusos bisbilhotivos.

Dica 35 Aprenda uma linguagem de manipulação de texto
Para mostrar a ampla aplicabilidade das linguagens de manipulação de texto, aqui está uma amostra de algumas coisas que fizemos com Ruby e Python relacionados à criação deste livro:

Construindo o livro
O sistema de construção para a estante pragmática é escrito em Ruby. Autores, editores, pessoas de layout e apoio às pessoas usam tarefas de rake para coordenar a construção de PDFs e eBooks.

Inclusão de código e destaque
Achamos que é importante que qualquer código apresentado em um livro tenha sido testado primeiro. A maior parte do código deste livro foi. No entanto, usando o princípio seco (consulte o tópico 9, seco - os males da duplicação), não queríamos copiar e colar linhas de código dos programas testados no livro. Isso significaria que estaríamos duplicando o código, praticamente garantindo que esqueceremos de atualizar um exemplo quando o programa correspondente foi alterado. Para alguns exemplos, também não queríamos aborrecê -lo com todo o código da estrutura necessário para fazer nosso exemplo compilar e executar. Nos viramos para Ruby. Um script relativamente simples é chamado quando formatamos o livro - extrai um segmento nomeado de um arquivo de origem, faz destaque da sintaxe e converte o resultado no idioma do tipoTenting que usamos.

Atualização do site
Temos um script simples que faz uma criação de livros parciais, extrai o índice e depois o carrega para a página do livro em nosso site. Também temos um script que extrai seções de um livro e as carrega como amostras.

Incluindo equações
Há um script python que converte a marcação matemática do látex em texto bem formatado.

Geração de índice
A maioria dos índices é criada como documentos separados (o que dificulta a manutenção deles se um documento mudar). O nosso é marcado no próprio texto, e um script rubi coloca e formata as entradas.

E assim por diante. De uma maneira muito real, a estante pragmática é construída em torno da manipulação de texto. E se você seguir nosso conselho para manter as coisas em texto simples, o uso desses idiomas para manipular esse texto trará uma série de benefícios.

Seções relacionadas incluem
Tópico 16, o poder do texto simples
Tópico 17, jogos de shell





Tópico 22 - Daybooks de engenharia

Dave trabalhou uma vez para um pequeno fabricante de computadores, o que significava trabalhar ao lado de engenheiros eletrônicos e às vezes mecânicos.

Muitos deles andavam com um caderno de papel, normalmente com uma caneta enfiada na coluna. De vez em quando, quando estávamos conversando, eles abriam o caderno e rabiscariam alguma coisa.

Eventualmente, Dave fez a pergunta óbvia. Aconteceu que eles foram treinados para manter um dia de engenharia, uma espécie de diário em que registraram o que fizeram, coisas que aprenderam, esboços de idéias, leituras de medidores: basicamente qualquer coisa a ver com seu trabalho. Quando o caderno ficou cheio, eles escrevem o intervalo de data na coluna e o colocavam na prateleira ao lado dos diários anteriores. Pode ter havido uma concorrência gentil, para cujo conjunto de livros ocupou o espaço mais prateado.

Utilizamos diários para fazer anotações em reuniões, para anotar o que estamos trabalhando, para observar valores variáveis ao depurar, deixar lembretes onde colocamos as coisas, para gravar idéias selvagens e, às vezes, apenas para rabiscar. [29]

O diário tem três benefícios principais:

É mais confiável que a memória. As pessoas podem perguntar: “Qual era o nome daquela empresa que você ligou na semana passada sobre o problema da fonte de alimentação?” E você pode voltar uma página ou mais e dar o nome e o número.

Dá -lhe um lugar para armazenar
idéias que não são imediatamente relevantes para a tarefa em questão. Dessa forma, você pode continuar se concentrando no que está fazendo, sabendo que a grande idéia não será esquecida.

Ele atua como uma espécie de pato de borracha (descrito aqui). Quando você para para escrever algo, seu cérebro pode trocar de marcha, quase como se converse com alguém - uma grande chance de refletir. Você pode começar a anotar e, de repente, percebe que o que você acabou de fazer, o tópico da nota, está simplesmente errado.

Também há um benefício adicional. De vez em quando, você pode olhar para o que estava fazendo, tão muitos anos-e pensar nas pessoas, nos projetos e nas terríveis roupas e penteados.

Então, tente manter um diário de engenharia. Use papel, não um arquivo ou um wiki: há algo especial no ato de escrever em comparação com a digitação. Dê um mês e veja se você está obtendo algum benefício.

Se nada mais, facilitará a redação de suas memórias quando você é rico e famoso.

Seções relacionadas incluem
Tópico 6, seu portfólio de conhecimento
Tópico 37, ouça seu cérebro de lagarto