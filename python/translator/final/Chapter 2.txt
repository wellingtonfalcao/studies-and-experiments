Capítulo 2

Uma abordagem pragmática
Existem certas dicas e truques que se aplicam em todos os níveis de desenvolvimento de software, processos praticamente universais e idéias quase axiomáticas. No entanto, essas abordagens raramente são documentadas como tal; Você os encontrará principalmente escritos como frases estranhas em discussões sobre design, gerenciamento de projetos ou codificação. Mas, para sua conveniência, reuniremos essas idéias e processos aqui.

O primeiro e talvez o tópico mais importante chega ao coração do desenvolvimento de software: Tópico 8, a essência do bom design. Tudo se segue disso.

As próximas duas seções, o tópico 9, seco - os males de duplicação e tópico 10, ortogonalidade, estão intimamente relacionados. Os primeiros avisam que você não duplica o conhecimento em seus sistemas, o segundo a não dividir nenhum conhecimento em vários componentes do sistema.

À medida que o ritmo da mudança aumenta, torna -se cada vez mais difícil manter nossos aplicativos relevantes. No tópico 11, reversibilidade, examinaremos algumas técnicas que ajudam a isolar seus projetos a partir do ambiente em mudança.

As próximas duas seções também estão relacionadas. No tópico 12, Bullets Tracer, falamos sobre um estilo de desenvolvimento que permite reunir requisitos, testar projetos e implementar código ao mesmo tempo. É a única maneira de acompanhar o ritmo da vida moderna.

Tópico 13, protótipos e notas post-it mostra como usar prototipagem para testar arquiteturas, algoritmos, interfaces e idéias. No mundo moderno, é fundamental testar idéias e obter feedback antes de se comprometer com elas de todo o coração.

À medida que a ciência da computação amadurece lentamente, os designers estão produzindo idiomas cada vez mais de nível superior. Embora o compilador que aceite "faça assim" ainda não tenha sido inventado, no tópico 14, idiomas de domínio, apresentamos sugestões mais modestas que você pode implementar para si mesmo.

Finalmente, todos trabalhamos em um mundo de tempo e recursos limitados. Você pode sobreviver melhor a essas escassezes (e manter seus chefes ou clientes mais felizes) se você for bom em descobrir quanto tempo as coisas levarão, que cobrimos no tópico 15, estimando.

Lembre -se desses princípios fundamentais durante o desenvolvimento e você escreverá o código melhor, mais rápido e mais forte. Você pode até fazer com que pareça fácil.





Tópico 8
A essência do bom design
O mundo está cheio de gurus e especialistas, todos ansiosos para transmitir sua sabedoria suada quando se trata de como projetar software. Existem acrônimos, listas (que parecem favorecer cinco entradas), padrões, diagramas, vídeos, palestras e (a Internet sendo a Internet) provavelmente uma série legal sobre a lei de Demeter explicada usando dança interpretativa.

E nós, seus autores gentis, também somos culpados disso. Mas gostaríamos de fazer as pazes explicando algo que só se tornou aparente para nós bastante recentemente. Primeiro, a declaração geral:

Dica 14 O bom design é mais fácil de mudar do que o design ruim
Uma coisa é bem projetada se se adaptar às pessoas que a usam. Para o código, isso significa que ele deve se adaptar mudando. Portanto, acreditamos no princípio do ETC: mais fácil de mudar. Etc. É isso.

Até onde sabemos, todo princípio de design é um caso especial de etc.

Por que a dissociação está bem? Porque, isolando as preocupações, facilitamos cada uma delas. Etc.

Por que o princípio de responsabilidade única é útil? Porque uma mudança nos requisitos é refletida por uma alteração em apenas um módulo. Etc.

Por que nomear é importante? Porque os bons nomes facilitam a leitura do código e você precisa lê -lo para alterá -lo. Etc!

Etc é um valor, não uma regra
Os valores são coisas que ajudam você a tomar decisões: devo fazer isso ou aquilo? Quando se trata de pensar em software, etc, é um guia, ajudando você a escolher entre os caminhos. Assim como todos os seus outros valores, ele deve estar flutuando logo atrás do seu pensamento consciente, cutucando -o sutilmente na direção certa.

Mas como você faz isso acontecer? Nossa experiência é que requer algum reforço consciente inicial. Você pode precisar passar uma semana ou mais deliberadamente se perguntando: "A coisa que eu acabei de tornar o sistema geral mais fácil ou mais difícil de mudar?" Faça isso quando salvar um arquivo. Faça isso quando escrever um teste. Faça isso quando corrigir um bug.

Há uma premissa implícita em etc. Ele pressupõe que uma pessoa possa dizer qual de muitos caminhos será mais fácil de mudar no futuro. Na maioria das vezes, o bom senso estará correto e você poderá adivinhar.

Às vezes, porém, você não terá idéia. Isso está ok. Nesses casos, pensamos que você pode fazer duas coisas.

Primeiro, dado isso
Você não tem certeza de que alteração de formulário levará, sempre poderá recorrer ao caminho definitivo "fácil de alterar": tente fazer o que você escreve substituível. Dessa forma, o que quer que aconteça no futuro, esse pedaço de código não será um obstáculo. Parece extremo, mas na verdade é o que você deveria fazer o tempo todo. É realmente só de pensar em manter o código dissociado e coeso.

Segundo, trate isso como uma maneira de desenvolver instintos. Observe a situação em seu livro do Dia da Engenharia: as opções que você tem e algumas suposições sobre mudanças. Deixe uma tag na fonte. Então, mais tarde, quando esse código tiver que mudar, você poderá olhar para trás e dar um feedback. Pode ajudar na próxima vez que você chegar a um garfo semelhante na estrada.

O restante das seções deste capítulo tem idéias específicas sobre design, mas todas são motivadas por esse princípio.

Seções relacionadas incluem
Tópico 9, seco - os males de duplicação
Tópico 10, Ortogonalidade
Tópico 11, reversibilidade
Tópico 14, idiomas de domínio
Tópico 28, dissociação
Tópico 30, transformando a programação
Tópico 31, Imposto sobre Herança
Desafios
Pense em um princípio de design que você usa regularmente. Pretende-se facilitar a mudança das coisas?

Pense também em idiomas e paradigmas de programação (OO, FP, Reativo e assim por diante). Algum tem grandes positivos ou grandes negativos quando se trata de ajudá -lo a escrever código etc? Algum tem os dois?

Ao codificar, o que você pode fazer para eliminar os negativos e acentuar os positivos? [13]

Muitos editores têm suporte (interno ou através de extensões) para executar comandos ao salvar um arquivo. Faça com que seu editor apareça um etc? Mensagem toda vez que você salva [14] e usa -a como uma sugestão para pensar no código que você acabou de escrever. É fácil mudar?





Tópico 9
Seco - os males de duplicação
Dando a um computador duas peças contraditórias de conhecimento, o capitão James T. Kirk é a maneira preferida de desativar uma inteligência artificial saqueadora. Infelizmente, o mesmo princípio pode ser eficaz para reduzir seu código.

Como programadores, coletamos, organizamos, mantemos e aproveitamos o conhecimento. Documentamos conhecimento sobre especificações, fazemos com que ele ganhe vida no código de execução e o usamos para fornecer as verificações necessárias durante o teste.

Infelizmente, o conhecimento não é estável. Muda - geralmente rapidamente. Sua compreensão de um requisito pode mudar após uma reunião com o cliente. O governo muda um regulamento e alguma lógica de negócios fica desatualizada. Os testes podem mostrar que o algoritmo escolhido não funcionará. Toda essa instabilidade significa que gastamos grande parte do nosso tempo no modo de manutenção, reorganizando e reexpressando o conhecimento em nossos sistemas.

A maioria das pessoas assume que a manutenção começa quando um aplicativo é liberado, essa manutenção significa consertar bugs e aprimorar os recursos. Achamos que essas pessoas estão erradas. Os programadores estão constantemente no modo de manutenção. Nossa compreensão muda dia a dia. Novos requisitos chegam e os requisitos existentes evoluem à medida que somos cabeças para baixo no projeto. Talvez o ambiente mude. Seja qual for o motivo, a manutenção não é uma atividade discreta, mas uma parte rotineira de todo o processo de desenvolvimento.

Quando realizamos manutenção, precisamos encontrar e alterar as representações das coisas - aquelas cápsulas de conhecimento incorporadas no aplicativo. O problema é que é fácil duplicar o conhecimento nas especificações, processos e programas que desenvolvemos e, quando o fazemos, convidamos um pesadelo de manutenção - um que começa bem antes do envio do aplicativo.

Achamos que a única maneira de desenvolver software de maneira confiável e facilitar nossos desenvolvimentos é entender e manter, é seguir o que chamamos de princípio seco:

Todo conhecimento deve ter uma representação única, inequívoca e autorizada dentro de um sistema.

Por que chamamos de seco?

DICA 15 seca - não se repita
A alternativa é ter a mesma coisa expressa em dois ou mais lugares. Se você mudar um, deve se lembrar de mudar os outros ou, como os computadores alienígenas, seu programa será trazido de joelhos por uma contradição. Não é uma questão de saber se você se lembra: é uma questão de quando você esquecerá.

Você encontrará o princípio seco aparecendo várias vezes ao longo deste livro, geralmente em contextos que não têm nada a ver com a codificação. Achamos que é uma das ferramentas mais importantes na caixa de ferramentas do programador pragmático.

Nesta seção, delinearemos os problemas de duplicação e sugeriremos estratégias gerais para lidar com ela.

Seco é mais do que
Código
Vamos tirar algo do caminho antecipadamente. Na primeira edição deste livro, fizemos um péssimo trabalho ao explicar exatamente o que queremos dizer por não se repetir. Muitas pessoas o levaram para se referir apenas ao código: eles pensaram que seco significa "não copie e coloque linhas de fonte".

Isso faz parte do seco, mas é uma parte minúscula e bastante trivial.

Dry é sobre a duplicação do conhecimento, de intenção. Trata -se de expressar a mesma coisa em dois lugares diferentes, possivelmente de duas maneiras totalmente diferentes.

Aqui está o teste de ácido: quando uma única faceta do código precisa mudar, você se vê fazendo essa alteração em vários lugares e em vários formatos diferentes? Você precisa alterar o código e a documentação, ou um esquema de banco de dados e uma estrutura que o segura, ou…? Nesse caso, seu código não está seco.

Então, vejamos alguns exemplos típicos de duplicação.

Este exemplo também ilustra uma questão importante: sempre que um módulo expõe uma estrutura de dados, você está acoplando todo o código que usa essa estrutura à implementação desse módulo. Sempre que possível, sempre use funções de acessador para ler e escrever os atributos dos objetos. Isso facilitará a adição de funcionalidade no futuro.

Esse uso de funções de acessador se vincula ao princípio de acesso uniforme de Meyer, descrito na construção de software orientada a objetos [Mey97], que afirma que afirma que

Todos os serviços oferecidos por um módulo devem estar disponíveis através de uma notação uniforme, que não traia se eles são implementados por meio de armazenamento ou por computação.

Duplicação representacional
Seu código interfina o mundo exterior: outras bibliotecas via APIs, outros serviços por meio de chamadas remotas, dados em fontes externas e assim por diante. E praticamente cada vez que você faz, você apresenta algum tipo de violação seca: seu código precisa ter conhecimento que também esteja presente na coisa externa. Ele precisa conhecer a API, ou o esquema, ou o significado dos códigos de erro, ou o que seja. A duplicação aqui é que duas coisas (seu código e a entidade externa) precisam ter conhecimento da representação de sua interface. Mude em uma extremidade e a outra extremidade quebra.

Essa duplicação é inevitável, mas pode ser atenuada. Aqui estão algumas estratégias.

Duplicação em APIs internas
Para APIs internas, procure ferramentas que permitam especificar a API em algum tipo de formato neutro. Essas ferramentas normalmente geram documentação, Mock APIs, testes funcionais e clientes da API, este último em vários idiomas diferentes. Idealmente, a ferramenta armazenará todas as suas APIs em um repositório central, permitindo que elas sejam compartilhadas entre as equipes.

Duplicação em APIs externas
Cada vez mais, você descobrirá que as APIs públicas estão documentadas formalmente usando algo como o OpenAPI. [15] Isso permite importar a especificação da API para suas ferramentas locais de API e integrar -se de maneira mais confiável ao serviço.

Se você não conseguir encontrar essa especificação, considere criar um e publicá -lo. Outros não apenas acharão útil; Você pode até obter ajuda para mantê -lo.

Duplicação com fontes de dados
Muitas fontes de dados permitem que você introspecione seu esquema de dados. Isso pode ser usado para remover grande parte da duplicação entre eles e seu código. Em vez de criar manualmente o código para conter esses dados armazenados, você pode gerar os contêineres diretamente a partir do esquema. Muitas estruturas de persistência farão esse levantamento pesado para você.

Há outra opção, e uma que frequentemente preferimos. Em vez de escrever um código que represente dados externos em uma estrutura fixa (uma instância de uma estrutura ou classe, por exemplo), basta enfiar em uma estrutura de dados de chave/valor (seu idioma pode chamá -lo de mapa, hash, dicionário ou mesmo objeto).

Por si só, isso é arriscado: você perde muita segurança de saber exatamente quais dados está trabalhando. Por isso, recomendamos adicionar uma segunda camada a esta solução: um simples conjunto de validação orientado por mesa que verifica se o mapa que você criou contém pelo menos os dados necessários, no formato que você precisa. Sua ferramenta de documentação da API pode ser capaz de gerar isso.

Duplicação interdeveloper
Talvez o tipo mais difícil de duplicação para detectar e manipular ocorra entre diferentes desenvolvedores em um projeto. Conjuntos inteiros de funcionalidade podem ser inadvertidamente duplicados, e essa duplicação pode não ser detectada por anos, levando a problemas de manutenção. Ouvimos em primeira mão um estado dos EUA cujos sistemas governamentais de computadores foram pesquisados para a conformidade com Y2K. A auditoria apareceu mais de 10.000 programas que cada um continha uma versão diferente do número de previdência social
Código de validação.

Em um nível alto, lide com o problema construindo uma equipe forte e unida com boas comunicações.

No entanto, no nível do módulo, o problema é mais insidioso. A funcionalidade ou dados geralmente necessários que não se enquadram em uma área de responsabilidade óbvia pode ser implementada várias vezes.

Sentimos que a melhor maneira de lidar com isso é incentivar uma comunicação ativa e frequente entre os desenvolvedores.

Talvez faça uma reunião diária de stand -up. Configure os fóruns (como canais Slack) para discutir problemas comuns. Isso fornece uma maneira não invasiva de se comunicar - mesmo em vários sites - enquanto reteve um histórico permanente de tudo o que dizia.

Nomeie um membro da equipe como bibliotecário do projeto, cujo trabalho é facilitar a troca de conhecimento. Tenha um local central na árvore de origem, onde as rotinas e scripts utilizados podem ser depositados. E faça questão de ler o código e a documentação de outras pessoas, informalmente ou durante as revisões de código. Você não está bisbilhotando - você está aprendendo com eles. E lembre -se, o acesso é recíproco - também não se tornará distorcido sobre outras pessoas que se destacam (pata?) Através do seu código.

Dica 16 facilite a reutilização
O que você está tentando fazer é promover um ambiente em que é mais fácil encontrar e reutilizar coisas existentes do que escrever você mesmo. Se não for fácil, as pessoas não farão isso. E se você não conseguir reutilizar, corre o risco de duplicar o conhecimento.

Seções relacionadas incluem
Tópico 8, a essência do bom design
Tópico 28, dissociação
Tópico 32, configuração
Tópico 38, Programação por coincidência
Tópico 40, refatoração






Tópico 10
Ortogonalidade
A ortogonalidade é um conceito crítico se você deseja produzir sistemas fáceis de projetar, construir, testar e estender. No entanto, o conceito de ortogonalidade raramente é ensinado diretamente. Muitas vezes, é uma característica implícita de vários outros métodos e técnicas que você aprende. Isso é um erro. Depois de aprender a aplicar diretamente o princípio da ortogonalidade, você notará uma melhoria imediata na qualidade dos sistemas que você produz.

O que é ortogonalidade?
Um gráfico é mostrado em um ponto de vista diferente. O eixo horizontal representa o leste e o eixo vertical representa o norte. A linha 1 é desenhada paralela ao eixo vertical e a linha 2 é desenhada paralela ao eixo horizontal.
“Ortogonalidade '' é um termo emprestado da geometria. Duas linhas são ortogonais se elas se encontrarem em ângulos retos, como os eixos em um gráfico. Em termos vetoriais, as duas linhas são independentes. Como o número 1 no diagrama se move ao norte, não muda até o extremo leste ou oeste. O número 2 se move leste, mas não ao norte ou ao sul.

Na computação, o termo passou a significar um tipo de independência ou dissociação. Duas ou mais coisas são ortogonais se as alterações em um não afetam nenhum dos outros. Em um sistema bem projetado, o código do banco de dados será ortogonal para a interface do usuário: você pode alterar a interface sem afetar o banco de dados e trocar bancos de dados sem alterar a interface.

Antes de examinarmos os benefícios dos sistemas ortogonais, vamos primeiro olhar para um sistema que não é ortogonal.

Um sistema não ortogonal
Você está em um tour de helicóptero pelo Grand Canyon quando o piloto, que cometeu o erro óbvio de comer peixe para almoçar, de repente geme e desmaia. Felizmente, ele deixou você pairando 100 pés acima do solo.

Por sorte, você leu uma página da Wikipedia sobre helicópteros na noite anterior. Você sabe que os helicópteros têm quatro controles básicos. O cíclico é o bastão que você segura na mão direita. Mova -o e o helicóptero se move na direção correspondente. Sua mão esquerda segura a alavanca de afinação coletiva. Puxe isso e aumenta o tom em todas as lâminas, gerando elevação. No final da alavanca de arremesso está o acelerador. Finalmente, você tem pedais de dois pés, que variam a quantidade de impulso do rotor de cauda e, portanto, ajudam a virar o helicóptero.

"Fácil!", Você pensa. "Abaixe suavemente a alavanca de arremesso coletivo e você descerá graciosamente ao chão, um herói." No entanto, quando você tenta, descobre que a vida não é tão simples. O nariz do helicóptero cai e você começa a ficar em espiral para a esquerda. De repente, você descobre que está pilotando um sistema em que toda entrada de controle tem efeitos secundários. Abaixe a alavanca à esquerda e você precisa adicionar um movimento para trás compensar ao bastão direito e empurre o pedal direito. Mas então cada uma dessas mudanças afeta todos os outros controles novamente. De repente você está fazendo malabarismos com um sistema inacreditavelmente complexo, onde toda mudança afeta todo o
Outras entradas. Sua carga de trabalho é fenomenal: suas mãos e pés estão se movendo constantemente, tentando equilibrar todas as forças em interação.

Os controles de helicóptero não são decididamente ortogonais.

Benefícios da ortogonalidade
Como o exemplo de helicóptero ilustra, os sistemas não ortogonais são inerentemente mais complexos para mudar e controlar. Quando os componentes de qualquer sistema são altamente interdependentes, não existe uma correção local.

Dica 17 elimina os efeitos entre coisas não relacionadas
Queremos projetar componentes independentes: independentes e com um único objetivo bem definido (o que o YourDon e o Constantine chamam coesão no design estruturado: fundamentos de uma disciplina de programa de computador e design de sistemas [YC79]). Quando os componentes são isolados um do outro, você sabe que pode mudar um sem ter que se preocupar com o resto. Desde que você não altere as interfaces externas desse componente, poderá ter certeza de que não causará problemas que ondulam por todo o sistema.

Você obtém dois grandes benefícios se escrever sistemas ortogonais: aumento da produtividade e risco reduzido.

Ganhe produtividade
As mudanças estão localizadas, portanto, o tempo de desenvolvimento e o tempo de teste são reduzidos. É mais fácil escrever componentes relativamente pequenos e independentes do que um único bloco grande de código. Componentes simples podem ser projetados, codificados, testados e esquecidos - não há necessidade de continuar alterando o código existente à medida que você adiciona novo código.

Uma abordagem ortogonal também promove a reutilização. Se os componentes tiverem responsabilidades específicas e bem definidas, eles podem ser combinados com novos componentes de maneiras que não foram previstas por seus implementadores originais. Quanto mais pouco acoplavam seus sistemas, mais fáceis eles são reconfigurar e reengenheiros.

Há um ganho bastante sutil em produtividade quando você combina componentes ortogonais. Suponha que um componente faça coisas distintas superiores e outra faz as coisas superiores. Se eles são ortogonais e você os combina, o resultado é o Mirping M cruzar as coisas superiores. No entanto, se os dois componentes não forem ortogonais, haverá sobreposição e o resultado fará menos. Você obtém mais funcionalidade por unidade de esforço, combinando componentes ortogonais.

Reduzir o risco
Uma abordagem ortogonal reduz os riscos inerentes a qualquer desenvolvimento.

Seções doentes do código estão isoladas. Se um módulo estiver doente, é menos provável que espalhe os sintomas pelo restante do sistema. Também é mais fácil cortá -lo e transplantar em algo novo e saudável.

O sistema resultante é menos frágil. Faça pequenas alterações e correções em uma área específica, e quaisquer problemas que você gerar serão restritos a essa área.

Um sistema ortogonal provavelmente será melhor testado, porque será mais fácil projetar e executar testes em seus componentes.

Você não estará tão bem ligado a um fornecedor, produto ou plataforma específico, porque as interfaces desses componentes de terceiros serão isoladas em partes menores do desenvolvimento geral.

Vejamos algumas das maneiras pelas quais você pode aplicar o princípio da ortogonalidade ao seu trabalho.

Projeto
A maioria dos desenvolvedores está familiarizada com a necessidade de projetar sistemas ortogonais, embora possam usar palavras como modular, baseado em componentes e em camadas para descrever o processo. Os sistemas devem ser compostos por um conjunto de módulos de cooperação, cada um dos quais implementa a funcionalidade independente dos outros. Às vezes, esses componentes são organizados em camadas, cada um fornecendo um nível de abstração. Essa abordagem em camadas é uma maneira poderosa de projetar sistemas ortogonais. Como cada camada usa apenas as abstrações fornecidas pelas camadas abaixo dela, você tem grande flexibilidade na alteração de implementações subjacentes sem afetar o código. As camadas também reduzem o risco de dependências descontroladas entre os módulos. Você costuma ver as camadas expressas em diagramas:

A representação do endereço é mostrada.

Existe um teste fácil para o design ortogonal. Depois de mapear seus componentes, pergunte -se: se eu alterar drasticamente os requisitos por trás de uma função específica, quantos módulos são afetados? Em um sistema ortogonal, a resposta deve ser "uma".

Vamos considerar um sistema complexo para monitorar e controlar uma planta de aquecimento. O requisito original pedia uma interface gráfica do usuário, mas os requisitos foram alterados para adicionar uma interface móvel que permite que os engenheiros monitorem os valores das chaves. Em um
Sistema de design ortogonalmente, você precisaria alterar apenas os módulos associados à interface do usuário para lidar com isso: a lógica subjacente do controle da planta permaneceria inalterada. De fato, se você estruturar seu sistema com cuidado, poderá suportar ambas as interfaces com a mesma base de código subjacente.

Pergunte também a si mesmo como seu design é dissociado por mudanças no mundo real. Você está usando um número de telefone como identificador de cliente? O que acontece quando a companhia telefônica reatribui os códigos de área? Códigos postais, números de previdência social ou IDs do governo, endereços de email e domínios são todos identificadores externos sobre os quais você não tem controle e pode mudar a qualquer momento por qualquer motivo. Não confie nas propriedades das coisas que você não pode controlar.

Kits de ferramentas e bibliotecas
Cuidado em preservar a ortogonalidade do seu sistema ao introduzir kits de ferramentas e bibliotecas de terceiros. Escolha suas tecnologias com sabedoria.

Quando você traz um kit de ferramentas (ou mesmo uma biblioteca de outros membros da sua equipe), pergunte -se se ele impõe alterações no seu código que não deve estar lá. Se um esquema de persistência de objeto for transparente, é ortogonal. Se exigir que você crie ou acesse objetos de uma maneira especial, não é. Manter esses detalhes isolados do seu código tem o benefício adicional de facilitar a alteração de fornecedores no futuro.

O sistema Enterprise Java Beans (EJB) é um exemplo interessante de ortogonalidade. Na maioria dos sistemas orientados a transações, o código do aplicativo deve delinear o início e o final de cada transação. Com o EJB, essas informações são expressas declarativamente como anotações, fora dos métodos que fazem o trabalho. O mesmo código de aplicativo pode ser executado em diferentes ambientes de transação EJB, sem alteração.

De certa forma, o EJB é um exemplo do padrão do decorador: adicionando funcionalidade às coisas sem alterá -las. Esse estilo de programação pode ser usado em quase todas as linguagens de programação e não exige necessariamente uma estrutura ou biblioteca. É preciso apenas um pouco de disciplina ao programar.

Codificação
Toda vez que você escreve o código, você corre o risco de reduzir a ortogonalidade do seu aplicativo. A menos que você monitore constantemente não apenas o que está fazendo, mas também o contexto maior do aplicativo, você pode duplicar sem querer a funcionalidade em algum outro módulo ou expressar o conhecimento existente duas vezes.

Existem várias técnicas que você pode usar para manter a ortogonalidade:

Mantenha seu código dissociado
Escreva código tímido - módulos que não revelam nada desnecessário a outros módulos e que não dependem das implementações de outros módulos. Experimente a lei do Demeter, que discutimos no tópico 28, desacoplando. Se você precisar alterar o estado de um objeto, faça com que o objeto faça isso por você. Dessa forma, seu código permanece isolado da implementação do outro código e aumenta as chances de você permanecer ortogonal.

Evite dados globais
Toda vez que seu código faz referência a dados globais, ele se vincula aos outros componentes que compartilham esses dados. Mesmo os globais que você pretende ler apenas pode levar a problemas (por exemplo, se você precisar de repente alterar seu código para ser multithread). Em geral, seu código é mais fácil de entender e manter se você passar explicitamente qualquer contexto necessário em seus módulos. Em aplicações orientadas a objetos, o contexto é frequentemente passado como parâmetros para os construtores dos objetos. Em outro código, você pode criar estruturas que contêm o contexto e transmitir referências a elas.

O padrão de singleton nos padrões de design: elementos do software reutilizável orientado a objetos [ghjv95] é uma maneira de garantir que exista apenas uma instância de um objeto de uma classe específica. Muitas pessoas usam esses objetos de singleton como uma espécie de variável global (particularmente em idiomas, como Java, que de outra forma não suportam o conceito de globais). Cuidado com singletons - eles também podem levar a uma ligação desnecessária.

Evite funções semelhantes
Muitas vezes, você encontra um conjunto de funções que parecem semelhantes - talvez elas compartilhem código comum no início e no fim, mas cada uma tem um algoritmo central diferente. O código duplicado é um sintoma de problemas estruturais. Dê uma olhada no padrão de estratégia nos padrões de design para uma melhor implementação.

Entre no hábito de ser constantemente crítico do seu código. Procure qualquer oportunidade de reorganizá -lo para melhorar sua estrutura e ortogonalidade. Esse processo é chamado de refatoração, e é tão importante que dedicamos uma seção a ele (ver tópico 40,
Refatoramento).

Teste
Um sistema ortogonalmente projetado e implementado é mais fácil de testar. Como as interações entre os componentes do sistema são formalizadas e limitadas, mais testes do sistema podem ser realizados no nível individual do módulo. Esta é uma boa notícia, porque o teste de nível (ou unidade) do módulo é consideravelmente mais fácil de especificar e executar do que o teste de integração. De fato, sugerimos que esses testes sejam realizados automaticamente como parte do processo de construção regular (consulte o tópico 41, teste para código).

Escrever testes de unidade é um teste interessante de ortogonalidade. O que é preciso para obter um teste de unidade para construir e executar? Você precisa importar uma grande porcentagem do restante do código do sistema? Nesse caso, você encontrou um módulo que não está bem dissociado do restante do sistema.

A correção de bugs também é um bom momento para avaliar a ortogonalidade do sistema como um todo. Quando você se deparar com um problema, avalie como a correção está localizada. Você altera apenas um módulo ou as alterações estão espalhadas por todo o sistema? Quando você faz uma mudança, isso conserta tudo ou faz outros problemas misteriosamente? Esta é uma boa oportunidade para trazer automação para suportar. Se você usar um sistema de controle de versão (e depois de ler o tópico 19, controle de versão), tag Bugs Correções quando você verificar o código de volta após o teste. Você pode executar relatórios mensais analisando tendências no número de arquivos de origem afetados por cada correção de bug.

Documentação
Talvez surpreendentemente, a ortogonalidade também se aplica à documentação. Os eixos são conteúdo e apresentação. Com documentação verdadeiramente ortogonal, você poderá alterar dramaticamente a aparência sem alterar o conteúdo. Os processadores de texto fornecem folhas de estilo e macros que ajudam. Pessoalmente, preferimos usar um sistema de marcação como Markdown: ao escrever, focamos apenas no conteúdo e deixamos a apresentação para qualquer ferramenta que usarmos para renderizá -la. [17]

Vivendo com ortogonalidade
A ortogonalidade está intimamente relacionada ao princípio seco. Com seco, você deseja minimizar a duplicação dentro de um sistema, enquanto que com a ortogonalidade você reduz a interdependência entre os componentes do sistema. Pode ser uma palavra desajeitada, mas se você usar o princípio da ortogonalidade, combinado de perto com o princípio seco, descobrirá que os sistemas que desenvolve são mais flexíveis, mais compreensíveis e mais fáceis de depurar, testar e manter.

Se você é trazido para um projeto em que as pessoas estão desesperadamente lutando para fazer mudanças e onde todas as mudanças parecem causar quatro outras coisas, lembre -se do pesadelo com o helicóptero. O projeto provavelmente não é ortogonalmente projetado e codificado. É hora de refatorar.

E, se você é um piloto de helicóptero, não coma o peixe….

Seções relacionadas incluem
Tópico 3, entropia de software
Tópico 8, a essência do bom design
Tópico 11, reversibilidade
Tópico 28, dissociação
Tópico 31, Imposto sobre Herança
Tópico 33, quebrando o acoplamento temporal
Tópico 34, Estado compartilhado é um estado incorreto
Tópico 36, Blackboards
Desafios
Considere a diferença entre as ferramentas que possuem uma interface gráfica do usuário e utilitários de linha de comando pequenos, mas combináveis, usados nos avisos do shell. Qual conjunto é mais ortogonal e por quê? O que é mais fácil de usar exatamente para o fim para o qual se destinava? Qual conjunto é mais fácil de combinar com outras ferramentas para enfrentar novos desafios? Qual conjunto é mais fácil de aprender?

O C ++ suporta herança múltipla, e o Java permite que uma classe implemente várias interfaces. Ruby tem mixins. Que impacto o uso dessas instalações tem na ortogonalidade? Existe uma diferença de impacto entre o uso de herança múltipla e várias interfaces? Existe uma diferença entre usar a delegação e a herança?








Tópico 11
Reversibilidade
Nada é mais perigoso do que uma ideia se for a única que você tem.

Emil-August Chartier (Alain), Propos Sur la Religion, 1938
Os engenheiros preferem soluções simples e singulares a problemas. Os testes de matemática que permitem proclamar com grande confiança que X é igual a 2 são muito mais confortáveis do que ensaios difusos e calorosos sobre as inúmeras causas da revolução francesa. A gerência tende a concordar com os engenheiros: respostas singulares e fáceis se encaixam bem nas planilhas e nos planos do projeto.

Se ao menos o mundo real cooperaria! Infelizmente, enquanto X é 2 hoje, pode precisar ser 5 amanhã e 3 na próxima semana. Nada é para sempre - e se você confiar fortemente em algum fato, poderá quase garantir que isso mudará.

Sempre há mais de uma maneira de
Implementar algo, e geralmente há mais de um fornecedor disponível para fornecer um produto de terceiros. Se você entrar em um projeto prejudicado pela noção míope de que existe apenas uma maneira de fazê -lo, você pode ter uma surpresa desagradável. Muitas equipes de projeto abriram seus olhos à força à medida que o futuro se desenrola:

"Mas você disse que usaríamos o banco de dados XYZ! Estamos 85% com codificação do projeto, não podemos mudar agora!" O programador protestou. "Desculpe, mas nossa empresa decidiu padronizar o PDQ do banco de dados - para todos os projetos. Está fora de minhas mãos. Vamos ter que recodificar. Todos vocês estarão trabalhando nos fins de semana até mais avisado."

As mudanças não precisam ser tão draconianas ou mesmo imediatas. Mas com o passar do tempo, e seu projeto avança, você pode ficar preso em uma posição insustentável. A cada decisão crítica, a equipe do projeto se compromete a um alvo menor - uma versão mais estreita da realidade que tem menos opções.

Quando muitas decisões críticas foram tomadas, o alvo se torna tão pequeno que, se ele se mover, ou o vento mudar de direção, ou uma borboleta em Tóquio retira suas asas, você sente falta. [18] E você pode perder por uma quantidade enorme.

O problema é que as decisões críticas não são facilmente reversíveis.

Depois de decidir usar o banco de dados deste fornecedor, ou esse padrão arquitetônico, ou um determinado modelo de implantação, você está comprometido com um curso de ação que não pode ser desfeito, exceto com ótimas custas.

Reversibilidade
Muitos dos tópicos deste livro são voltados para produzir software flexível e adaptável. Ao manter suas recomendações - especialmente o princípio seco, a desacoplamento e o uso da configuração externa - não precisamos tomar tantas decisões críticas e irreversíveis. Isso é uma coisa boa, porque nem sempre tomamos as melhores decisões na primeira vez. Nós nos comprometemos com uma certa tecnologia apenas para descobrir que não podemos contratar pessoas suficientes com as habilidades necessárias. Nós travamos um determinado fornecedor de terceiros pouco antes de serem comprados pelo concorrente. Requisitos, usuários e hardware mudam mais rápido do que podemos desenvolver o software.

Suponha que você decida, no início do projeto, usar um banco de dados relacional do fornecedor A. muito mais tarde, durante o teste de desempenho, você descobre que o banco de dados é simplesmente muito lento, mas que o banco de dados do Document do fornecedor B seja mais rápido. Com a maioria dos projetos convencionais, você ficaria sem sorte. Na maioria das vezes, as chamadas para produtos de terceiros estão enredadas ao longo do código. Mas se você realmente abstraiu a idéia de um banco de dados - até o ponto em que ele simplesmente fornece persistência como serviço - então você tem a flexibilidade de trocar de cavalos no meio da corrente.

Da mesma forma, suponha que o projeto comece como um aplicativo baseado em navegador, mas, no final do jogo, o marketing decide que o que eles realmente querem é um aplicativo móvel. Quão difícil seria isso para você? Em um mundo ideal, não deve afetar muito você, pelo menos no lado do servidor. Você estaria retirando alguma renderização em HTML e substituindo -a por uma API.

O erro está em assumir que qualquer decisão é lançada em pedra - e não se preparar para as contingências que possam surgir. Em vez de esculpir decisões em pedra, pense nelas mais como escritas na areia na praia. Uma grande onda pode aparecer e acabar com eles a qualquer momento.

Dica 18 Não há decisões finais
Arquitetura flexível
Enquanto muitas pessoas tentam manter seu código flexível, você também precisa pensar em manter a flexibilidade nas áreas de arquitetura, implantação e integração de fornecedores.

Estamos escrevendo isso em 2019. Desde a virada do século, vimos as seguintes arquiteturas do lado do servidor “Melhores Práticas”:

Grande pedaço de ferro
Federações de Big Iron
Clusters balanceados de carga de hardware de commodity
Máquinas virtuais baseadas em nuvem executando aplicativos
Máquinas virtuais baseadas em nuvem Serviços de execução
Versões de contêiner do acima
Aplicativos sem servidores suportados por nuvens
E, inevitavelmente, um aparente movimento de volta a grandes pedaços de ferro para algumas tarefas
Vá em frente e adicione os melhores e mais recentes modismos a esta lista e, em seguida, considere -a com admiração: é um milagre que qualquer coisa já tenha funcionado.

Como você pode planejar esse tipo de volatilidade arquitetônica? Você não pode.

O que você pode fazer é facilitar a mudança. Esconda as APIs de terceiros por trás de suas próprias camadas de abstração. Divida seu código em componentes: mesmo se você acabar implantando -os em um único servidor massivo, essa abordagem é muito mais fácil do que tomar um aplicativo monolítico e dividi -lo. (Temos as cicatrizes para provar isso.)

E, embora isso não seja
Particularmente uma questão de reversibilidade, um conselho final.

Dica 19 Opgo a seguir os modismos
Ninguém sabe o que o futuro pode conter, especialmente não nós! Portanto, ative seu código para o rock-n-roll: “Rock on '' quando puder, rolar com os socos quando for necessário.

Seções relacionadas incluem
Tópico 8, a essência do bom design
Tópico 10, Ortogonalidade
Tópico 19, controle de versão
Tópico 28, dissociação
Tópico 45, o poço de requisitos
Tópico 51, kit iniciante pragmático
Desafios
Hora de um pouco de mecânica quântica com o gato de Schrödinger.

Suponha que você tenha um gato em uma caixa fechada, junto com uma partícula radioativa. A partícula tem exatamente 50% de chance de fissurar em dois. Se isso acontecer, o gato será morto. Caso contrário, o gato ficará bem. Então, o gato está morto ou vivo? De acordo com Schrödinger, a resposta correta é ambos (pelo menos enquanto a caixa permanece fechada). Toda vez que ocorre uma reação subnuclear que tem dois resultados possíveis, o universo é clonado. Em um, o evento ocorreu, no outro não. O gato está vivo em um universo, morto em outro. Somente quando você abre a caixa, você sabe em qual universo você está.

Não é de admirar que codificar para o futuro seja difícil.

Mas pense na evolução do código na mesma linha que uma caixa cheia de gatos de Schrödinger: toda decisão resulta em uma versão diferente do futuro. Quantos futuros possíveis seu código pode suportar? Quais são mais prováveis? Quão difícil será apoiá -los quando chegar a hora?

Você se atreve a abrir a caixa?







Tópico 12
Balas traçer
Pronto, fogo, mira ...

Anon
Frequentemente falamos em atingir alvos quando desenvolvemos software. Na verdade, não estamos disparando nada no campo de tiro, mas ainda é uma metáfora útil e muito visual. Em particular, é interessante considerar como acertar um alvo em um mundo complexo e em mudança.

A resposta, é claro, depende da natureza do dispositivo com o qual você mira. Com muitos, você só tem uma chance de mirar e depois ver se você bate no Bullseye ou não. Mas há uma maneira melhor.

Você conhece todos esses filmes, programas de TV e videogames onde as pessoas estão filmando metralhadoras? Nessas cenas, você costuma ver o caminho das balas como estrias brilhantes no ar. Essas riscas vêm de balas de traçador.

As balas traçer são carregadas em intervalos ao lado da munição regular. Quando eles são demitidos, seu fósforo acende e deixa uma trilha pirotecnica da arma para o que quer que eles atinjam. Se os traçadores estão atingindo o alvo, também são as balas regulares. Os soldados usam essas rodadas de traçadores para refinar seu objetivo: é pragmático e em tempo real feedback sob condições reais.

Esse mesmo princípio se aplica a projetos, principalmente quando você está construindo algo que nunca foi construído antes. Utilizamos o termo desenvolvimento de balas de rastreamento para ilustrar visualmente a necessidade de feedback imediato em condições reais com uma meta móvel.

Como os Gunners, você está tentando atingir um alvo no escuro. Como seus usuários nunca viram um sistema como esse antes, seus requisitos podem ser vagos. Como você pode estar usando algoritmos, técnicas, idiomas ou bibliotecas com as quais não conhece, você enfrenta um grande número de incógnitas. E como os projetos levam tempo para serem concluídos, você pode garantir que o ambiente em que está trabalhando mude antes de terminar.

A resposta clássica é especificar o sistema até a morte. Produza resmas de papel especificando todos os requisitos, amarrando todos os desconhecidos e restringindo o ambiente. Disparar a arma usando o cálculo morto. Um grande cálculo na frente, depois atire e espere.

Programadores pragmáticos, no entanto, tendem a preferir usar o equivalente de software das balas do Tracer.

Código que brilha no escuro
As balas do Tracer funcionam porque operam no mesmo ambiente e sob as mesmas restrições que as balas reais. Eles chegam ao alvo rapidamente, então o artilheiro recebe feedback imediato. E do ponto de vista prático, eles são uma solução relativamente barata.

Para obter o mesmo efeito no código, procuramos algo que nos exija de um requisito a algum aspecto do sistema final de maneira rápida, visível e repetida.

Procure os requisitos importantes, aqueles que definem o sistema. Procure as áreas em que você tem dúvidas e onde vê os maiores riscos. Em seguida, priorize seu desenvolvimento para que essas sejam as primeiras áreas que você codifica.

Dica 20 Use balas traçer para encontrar o alvo
De fato, dada a complexidade da configuração do projeto de hoje, com enxames de dependências e ferramentas externas, as balas do Tracer se tornam ainda mais importantes.
Para nós, a primeira bala do Tracer é simplesmente criar o projeto, adicionar um "Hello World!" E verifique se ele compila e corre. Em seguida, procuramos áreas de incerteza na aplicação geral e adicionamos o esqueleto necessário para fazê -lo funcionar.

Dê uma olhada no seguinte diagrama. Este sistema possui cinco camadas arquitetônicas. Temos algumas preocupações sobre como eles se integrariam, por isso procuramos um recurso simples que nos permita exercê -los juntos. A linha diagonal mostra o caminho que o recurso segue através do código. Para fazê -lo funcionar, apenas precisamos implementar as áreas solidamente sombreadas em cada camada: as coisas com os rabiscos serão feitas mais tarde.

Uma figura mostra um conjunto de barras para representar entidades diferentes.

Certa vez, realizamos um projeto complexo de marketing de banco de dados cliente-servidor. Parte de seu requisito era a capacidade de especificar e executar consultas temporais. Os servidores eram uma variedade de bancos de dados relacionais e especializados. A interface do usuário do cliente, escrita na linguagem aleatória A, usou um conjunto de bibliotecas escritas em um idioma diferente para fornecer uma interface aos servidores. A consulta do usuário foi armazenada no servidor em uma notação do tipo LISP antes de ser convertida em SQL otimizado imediatamente antes da execução. Havia muitas incógnitas e muitos ambientes diferentes, e ninguém tinha certeza de como a interface do usuário deveria se comportar.

Esta foi uma ótima oportunidade para usar o código do rastreador. Desenvolvemos a estrutura para o front end, bibliotecas para representar as consultas e uma estrutura para converter uma consulta armazenada em uma consulta específica de banco de dados. Então juntamos tudo e verificamos que funcionou. Para essa compilação inicial, tudo o que podíamos fazer era enviar uma consulta que listou todas as linhas em uma tabela, mas provou que a interface do usuário poderia conversar com as bibliotecas, as bibliotecas poderiam serializar e não comunicar uma consulta, e o servidor poderia gerar SQL a partir do resultado. Nos meses seguintes, desenvolvemos gradualmente essa estrutura básica, adicionando uma nova funcionalidade aumentando cada componente do código do traçador em paralelo. Quando a interface do usuário adicionou um novo tipo de consulta, a biblioteca cresceu e a geração SQL foi tornada mais sofisticada.

O código do traçador não é descartável: você o escreve para manter. Ele contém toda a verificação, estruturação, documentação e auto-verificação de erros que qualquer código de produção possui. Simplesmente não é totalmente funcional. No entanto, depois de atingir uma conexão de ponta a ponta entre os componentes do seu sistema, você pode verificar o quão próximo o destino você está, ajustando, se necessário. Quando você estiver no alvo, adicionar funcionalidade é fácil.

O desenvolvimento do rastreador é consistente com a ideia de que um projeto nunca será concluído: sempre haverá alterações necessárias e funções para adicionar. É uma abordagem incremental.

A alternativa convencional é um tipo de abordagem de engenharia pesada: o código é dividido em módulos, que são codificados no vácuo. Os módulos são combinados em subconjuntos, que são então combinados, até que um dia você tenha um aplicativo completo. Somente então o aplicativo como um todo pode ser apresentado ao usuário e testado.

A abordagem do Código do Tracer tem muitas vantagens:

Os usuários podem ver algo funcionando cedo
Se você comunicou com sucesso o que está fazendo (consulte o tópico 52, encanta seus usuários), seus usuários saberão que estão vendo algo imaturo. Eles não ficarão desapontados com a falta de funcionalidade; Eles ficarão em êxtase ao ver algum progresso visível em direção ao seu sistema. Eles também contribuem à medida que o projeto avança, aumentando sua adesão. Esses mesmos usuários provavelmente serão as pessoas que lhe dirão o quão perto do alvo está cada iteração.

Desenvolvedores constroem uma estrutura para trabalhar em
O pedaço de papel mais assustador é aquele sem nada escrito. Se você elaborou todas as interações de ponta a ponta do seu aplicativo e as incorporou no código, sua equipe não precisará puxar tanto do nada. Isso torna todo mundo mais produtivo e incentiva a consistência.

Você tem uma plataforma de integração
Como o sistema está conectado de ponta a ponta, você tem um ambiente ao qual você pode adicionar novas peças de código depois que elas forem testadas na unidade. Em vez de tentar uma integração de grande porte, você estará se integrando todos os dias (geralmente muitas vezes por dia). O impacto de cada nova alteração é mais aparente e as interações são mais limitadas; portanto, a depuração e os testes são mais rápidos e precisos.

Você tem algo para demonstrar
Os patrocinadores do projeto e o topo de bronze tendem a querer ver demos nos momentos mais inconvenientes. Com o código do traçador, você sempre
tem algo para mostrar a eles.

Você tem uma sensação melhor para o progresso
Em um desenvolvimento de código do Tracer, os desenvolvedores abordam os casos de uso, um por um. Quando um terminar, eles se mudam para o próximo. É muito mais fácil medir o desempenho e demonstrar progresso para o seu usuário. Como cada desenvolvimento individual é menor, você evita criar esses blocos monolíticos de código que são relatados como 95% completos semana após semana.

Balas traçer nem sempre atingem seu alvo
Bullets Tracer mostram o que você está batendo. Isso nem sempre pode ser o alvo. Você então ajusta seu objetivo até que eles estejam no alvo. Esse é o ponto.

É o mesmo com o código do rastreamento. Você usa a técnica em situações em que não tem 100% de certeza de onde está indo. You shouldn't be surprised if your first couple of attempts miss: the user says “that's not what I meant,'' or data you need isn't available when you need it, or performance problems seem likely. So change what you've got to bring it nearer the target, and be thankful that you've used a lean development methodology; a small body of code has low inertia—it is easy and quick to change. You'll be able to gather feedback on your application and generate a new, more accurate version quickly and cheaply. And because every major O componente do aplicativo é representado no seu código do traçador, seus usuários podem ter certeza de que o que eles veem é baseado na realidade, não apenas em uma especificação de papel.

Código traçador versus prototipagem
Você pode pensar que esse conceito de código do rastreador nada mais é do que prototipagem sob um nome agressivo. Há uma diferença. Com um protótipo, você pretende explorar aspectos específicos do sistema final. Com um protótipo verdadeiro, você jogará fora o que quer que se acertará ao experimentar o conceito e o recuperará corretamente usando as lições que aprendeu.

Por exemplo, diga que você está produzindo um aplicativo que ajuda os remetentes a determinar como embalar caixas de tamanho ímpar em contêineres. Entre outros problemas, a interface do usuário precisa ser intuitiva e os algoritmos que você usa para determinar a embalagem ideal são muito complexos.

Você pode prototipar uma interface do usuário para seus usuários finais em uma ferramenta de interface do usuário. Você codifica apenas o suficiente para tornar a interface responsiva às ações do usuário. Depois de concordarem com o layout, você pode jogá -lo fora e recuperá -lo, desta vez com a lógica de negócios por trás dele, usando o idioma de destino. Da mesma forma, você pode querer prototipar vários algoritmos que executam a embalagem real. Você pode codificar testes funcionais em um idioma de alto nível, como Python, e codificar testes de desempenho de baixo nível em algo mais próximo da máquina. De qualquer forma, depois de tomar sua decisão, começaria de novo e codificaria os algoritmos em seu ambiente final, interface -se no mundo real. Isso é prototipagem e é muito útil.

A abordagem do código do traçador aborda um problema diferente. Você precisa saber como o aplicativo como um todo fica juntos. Você deseja mostrar aos usuários como as interações funcionarão na prática e deseja dar aos seus desenvolvedores um esqueleto arquitetônico para pendurar o código. Nesse caso, você pode construir um traçador que consiste em uma implementação trivial do algoritmo de embalagem de contêineres (talvez algo como o primeiro a chegar, primeiro servido) e uma interface de usuário simples, mas funcional. Depois de ter todos os componentes do aplicativo, você terá uma estrutura para mostrar seus usuários e seus desenvolvedores. Com o tempo, você adiciona a essa estrutura com nova funcionalidade, concluindo rotinas manchadas. Mas a estrutura permanece intacta, e você sabe que o sistema continuará se comportando da maneira que se saiu quando o seu primeiro código do traçador foi concluído.

A distinção é importante o suficiente para justificar a repetição. A prototipagem gera código descartável. O código do traçador é enxuto, mas completo, e faz parte do esqueleto do sistema final. Pense na prototipagem como a reunião de reconhecimento e inteligência que ocorre antes que uma única bala de traçador seja demitida.

Seções relacionadas incluem
Tópico 13, protótipos e notas post-it
Tópico 27, não supere seus faróis
Tópico 40, refatoração
Tópico 49, equipes pragmáticas
Tópico 50, os cocos não o cortam
Tópico 51, kit iniciante pragmático
Tópico 52, encanta seus usuários





Tópico 13
Protótipos e notas post-it
Muitas indústrias usam protótipos para experimentar idéias específicas; A prototipagem é muito mais barata que a produção em larga escala. Os fabricantes de carros, por exemplo, podem construir muitos protótipos diferentes de um novo design de carro. Cada um foi projetado para testar um específico
aspecto do carro - a aerodinâmica, estilo, características estruturais e assim por diante. O pessoal da velha escola pode usar um modelo de argila para testes de túneis de vento, talvez um modelo de madeira balsa e fita adesiva serve para o departamento de arte e assim por diante. Os menos românticos farão sua modelagem na tela do computador ou na realidade virtual, reduzindo ainda mais os custos. Dessa forma, elementos arriscados ou incertos podem ser testados sem se comprometer a criar o item real.

Construímos protótipos de software da mesma maneira e, pelas mesmas razões - analisar e expor riscos e oferecer chances de correção a um custo bastante reduzido. Como os fabricantes de carros, podemos atingir um protótipo para testar um ou mais aspectos específicos de um projeto.

Tendemos a pensar nos protótipos como baseados em código, mas eles nem sempre precisam ser. Como os fabricantes de carros, podemos construir protótipos a partir de diferentes materiais. As notas post-it são ótimas para prototipagem de coisas dinâmicas, como fluxo de trabalho e lógica de aplicativo. Uma interface do usuário pode ser prototipada como um desenho em um quadro branco, como uma maquete não funcional desenhada com um programa de pintura ou com um construtor de interface.

Os protótipos são projetados para responder apenas algumas perguntas, por isso são muito mais baratas e mais rápidas para desenvolver do que os aplicativos que entram em produção. O código pode ignorar detalhes sem importância - sem importância para você no momento, mas provavelmente muito importante para o usuário posteriormente. Se você estiver prototipando uma interface do usuário, por exemplo, pode se safar de resultados ou dados incorretos. Por outro lado, se você está apenas investigando aspectos computacionais ou de desempenho, pode se safar de uma interface do usuário muito pobre, ou talvez até nenhuma interface do usuário.

Mas se você se encontrar em um ambiente em que não pode desistir dos detalhes, precisa se perguntar se está realmente construindo um protótipo. Talvez um estilo de desenvolvimento de marcadores traçadores seja mais apropriado neste caso (ver tópico 12, marcadores de rastreamento).

Coisas para o protótipo
Que tipo de coisa você pode escolher investigar com um protótipo? Qualquer coisa que carregue riscos. Qualquer coisa que não tenha sido tentada antes, ou isso é absolutamente crítico para o sistema final. Qualquer coisa não comprovada, experimental ou duvidosa. Qualquer coisa que você não esteja confortável. Você pode prototipo:

Arquitetura
Nova funcionalidade em um sistema existente
Estrutura ou conteúdo de dados externos
Ferramentas ou componentes de terceiros
Questões de desempenho
Design da interface do usuário
A prototipagem é uma experiência de aprendizado. Seu valor não está no código produzido, mas nas lições aprendidas. Esse é realmente o ponto de prototipagem.

Dica 21 Prototipo para aprender
Como usar protótipos
Ao criar um protótipo, que detalhes você pode ignorar?

Correção
Você pode usar dados fictícios, quando apropriado.

Integridade
O protótipo pode funcionar apenas em um sentido muito limitado, talvez com apenas uma peça pré -selecionada de dados de entrada e um item de menu.

Robustez
A verificação de erros provavelmente será incompleta ou ausente completamente. Se você se afastar do caminho predefinido, o protótipo poderá travar e queimar em uma exibição gloriosa de pirotecnia. Tudo bem.

Estilo
O código do protótipo não deve ter muito em termos de comentários ou documentação (embora você possa produzir resmas de documentação como resultado da sua experiência com o protótipo).

Os protótipos encobrem os detalhes e concentram-se em aspectos específicos do sistema que está sendo considerado; portanto, você pode implementá-los usando uma linguagem de script de alto nível-mais alta que o restante do projeto (talvez um idioma como Python ou Ruby), pois esses idiomas podem sair do seu caminho. Você pode optar por continuar se desenvolvendo no idioma usado para o protótipo ou pode alternar; Afinal, você vai jogar o protótipo de qualquer maneira.

Para protótipo de interfaces de usuário, use uma ferramenta que permita se concentrar na aparência e/ou interações sem se preocupar com código ou marcação.

As linguagens de script também funcionam bem como a “cola '' para combinar peças de baixo nível em novas combinações. Usando essa abordagem, você pode montar rapidamente componentes existentes em novas configurações para ver como as coisas funcionam.

Arquitetura de prototipagem
Muitos protótipos são construídos para modelar todo o sistema em consideração. Ao contrário das balas do Tracer, nenhum dos módulos individuais no sistema de protótipo precisa ser particularmente funcional. De fato, você pode nem precisar codificar para protótipo de arquitetura-você pode prototipar em um quadro branco, com notas post-it ou cartões de índice. O que você está procurando é como o sistema se une como um todo, novamente adiando
detalhes. Aqui estão algumas áreas específicas que você pode querer procurar no protótipo arquitetônico:

As responsabilidades das principais áreas são bem definidas e apropriadas?
As colaborações entre os principais componentes estão bem definidas?
O acoplamento é minimizado?
Você pode identificar possíveis fontes de duplicação?
As definições e restrições de interface são aceitáveis?
Todo módulo tem um caminho de acesso aos dados de que precisa durante a execução? Tem esse acesso quando precisa?
Este último item tende a gerar as mais surpresas e os resultados mais valiosos da experiência de prototipagem.

Como não usar protótipos
Antes de embarcar em qualquer prototipagem baseada em código, verifique se todos entendem que você está escrevendo código descartável. Os protótipos podem ser enganosamente atraentes para pessoas que não sabem que são apenas protótipos. Você deve deixar bem claro que esse código é descartável, incompleto e não pode ser concluído.

É fácil ficar enganado pela aparente integridade de um protótipo demonstrado, e os patrocinadores ou gerenciamento do projeto podem insistir em implantar o protótipo (ou sua progênie) se você não definir as expectativas certas. Lembre-os de que você pode construir um ótimo protótipo de um carro novo a partir de madeira de balsa e fita adesiva, mas não tentaria conduzi-lo no trânsito da hora do rush!

Se você acha que existe uma forte possibilidade em seu ambiente ou cultura de que o objetivo do código do protótipo possa ser mal interpretado, você pode estar melhor com a abordagem de bala do Tracer. Você acabará com uma estrutura sólida na qual basear o desenvolvimento futuro.

Os protótipos adequadamente usados podem economizar grandes quantidades de tempo, dinheiro e dor, identificando e corrigindo possíveis pontos problemáticos no início do ciclo de desenvolvimento - o tempo em que corrigir erros é barato e fácil.

Seções relacionadas incluem
Tópico 12, balas de traçador
Tópico 14, idiomas de domínio
Tópico 17, jogos de shell
Tópico 27, não supere seus faróis
Tópico 37, ouça seu cérebro de lagarto
Tópico 45, o poço de requisitos
Tópico 52, encanta seus usuários
Exercícios
Exercício 3 (resposta possível)

O marketing gostaria de se sentar e debater alguns designs de página da web com você. Eles estão pensando em mapas de imagem clicáveis para levá -lo a outras páginas e assim por diante. Mas eles não podem decidir sobre um modelo para a imagem - talvez seja um carro, um telefone ou uma casa. Você tem uma lista de páginas de destino e conteúdo; Eles gostariam de ver alguns protótipos. Ah, a propósito, você tem 15 minutos. Quais ferramentas você pode usar?







Tópico 14
Idiomas de domínio
Os limites da linguagem são os limites do mundo.

Ludwig Wittgenstein
As linguagens do computador influenciam como você pensa sobre um problema e como pensa em se comunicar. Cada idioma vem com uma lista de recursos: palavras -chave, como digitação estática versus dinâmica, ligação precoce versus tardio, funcional versus OO, modelos de herança, mixins, macros - todos os quais podem sugerir ou obscurecer certas soluções. Projetar uma solução com C ++ em mente produzirá resultados diferentes de uma solução baseada no pensamento no estilo Haskell e vice-versa. Por outro lado, e pensamos mais importante, o idioma do domínio do problema também pode sugerir uma solução de programação.

Sempre tentamos escrever código usando o vocabulário do domínio do aplicativo (consulte Manter um glossário). Em alguns casos, os programadores pragmáticos podem ir para o próximo nível e realmente programar usando o vocabulário, a sintaxe e a semântica - o idioma - do domínio.

Dica 22 Programa próximo ao domínio do problema
Algumas línguas de domínio do mundo real
Vejamos alguns exemplos em que as pessoas fizeram exatamente isso.

RSPEC
RSPEC [19] é uma biblioteca de testes para Ruby. Ele inspirou versões para a maioria dos outros idiomas modernos. Um teste no RSPEC visa refletir o comportamento que você espera do seu código.


Pepino
O pepino [20] é uma maneira neutra em linguagem de programação de especificar testes. Você executa os testes usando uma versão do pepino apropriada para o idioma que você está usando. Para suportar a sintaxe da linguagem natural, você também precisa escrever correspondências específicas que reconheçam frases e extraem parâmetros para os testes.


Os testes de pepino pretendiam ser lidos pelos clientes do software (embora isso aconteça bastante raramente na prática; o seguinte ao lado considera por que isso pode ser).

Por que muitos usuários de negócios não leem os recursos do CUCUMER?
Uma das razões pelas quais o clássico reunir requisitos, design, código, abordagem de navio não funciona é que ela está ancorada pelo conceito de que sabemos quais são os requisitos. Mas raramente fazemos. Seu
Os usuários de negócios terão uma vaga idéia do que querem alcançar, mas não sabem nem se importam com os detalhes. Isso faz parte do nosso valor: Intuit Intent e o convertemos em código.

Portanto, quando você forçar uma pessoa de negócios a assinar um documento de requisitos ou fazê -la concordar com um conjunto de recursos de pepino, você está fazendo o equivalente a fazê -los verificar a ortografia em um ensaio escrito em sumério. Eles farão algumas mudanças aleatórias para salvar o rosto e assiná -lo para tirá -lo do escritório deles.

Dê -lhes código que executa, no entanto, e eles podem brincar com ele. É aí que suas necessidades reais surgirão.

Rotas de Phoenix
Muitas estruturas da Web têm uma instalação de roteamento, mapeando solicitações HTTP recebidas para funções de manipulador no código. Aqui está um exemplo de Phoenix. [21]

Isso diz que solicitações iniciais “/” serão executadas através de uma série de filtros apropriados para os navegadores. Uma solicitação para "/" será tratada pela função de índice no módulo PageController. O UsuáriosController implementa as funções necessárias para gerenciar um recurso acessível através do URL /Usuários.

Ansible
Ansible [22] é uma ferramenta que configura o software, normalmente em um monte de servidores remotos. Faz isso lendo uma especificação que você fornece, fazendo o que for necessário nos servidores para fazê -los refletir essa especificação. A especificação pode ser escrita em YAML, [23] Um idioma que cria estruturas de dados a partir de descrições de texto:

Este exemplo garante que a versão mais recente do NGINX seja instalada nos meus servidores, que seja iniciada por padrão e que use um arquivo de configuração que você forneceu.

Características dos idiomas de domínio
Vejamos esses exemplos mais de perto.

O RSPEC e o roteador Phoenix estão escritos em seus idiomas hospedeiros (Ruby e Elixir). Eles empregam algum código bastante desonesto, incluindo metaprogramação e macros, mas, finalmente, são compilados e executados como código regular.

Os testes de pepino e as configurações Ansible são escritas em seus próprios idiomas. Um teste de pepino é convertido em código para ser executado ou em umaestrutura de dados, enquanto as especificações do Ansible são sempre convertidas em uma estrutura de dados executada pela própria Ansible.

Como resultado, o RSPEC e o código do roteador são incorporados ao código que você executa: são extensões verdadeiras ao vocabulário do seu código. O pepino e o Ansible são lidos por código e convertidos em algum formulário que o código pode usar.

Chamamos o RSPEC e os exemplos do roteador de linguagens de domínio interno, enquanto o pepino e o Ansible usam idiomas externos.

Trade-offs entre idiomas internos e externos
Em geral, uma linguagem de domínio interno pode aproveitar os recursos de sua linguagem host: o idioma do domínio que você cria é mais poderoso e esse poder vem gratuitamente. Por exemplo, você pode usar algum código Ruby para criar vários testes RSPEC automaticamente. Nesse caso, podemos testar as pontuações onde não há peças de reposição ou greves:

São 100 testes que você acabou de escrever. Tire o resto do dia de folga.

A desvantagem dos idiomas de domínio interno é que você está vinculado pela sintaxe e semântica desse idioma. Embora alguns idiomas sejam notavelmente flexíveis nesse sentido, você ainda é forçado a comprometer entre o idioma que deseja e o idioma que pode implementar.

Por fim, tudo o que você criar ainda deve ser uma sintaxe válida em seu idioma de destino. Idiomas com macros (como elixir, clojure e cristal) oferecem um pouco mais de flexibilidade, mas, em última análise, a sintaxe é a sintaxe.

Idiomas externos não têm essas restrições. Contanto que você possa escrever um analisador para o idioma, estará pronto. Às vezes, você pode usar o analisador de outra pessoa (como Ansible fez usando o YAML), mas depois voltará a fazer um compromisso.

Escrever um analisador provavelmente significa adicionar novas bibliotecas e possivelmente ferramentas ao seu aplicativo. E escrever um bom analisador não é um trabalho trivial. Mas, se você estiver se sentindo forte de coração, poderá olhar para geradores de analisador como Bison ou Antlr, e a análise de estruturas como os muitos analisadores de cantos por aí.

Nossa sugestão é bastante simples: não gaste mais esforço do que você economiza. Escrever um idioma de domínio adiciona algum custo ao seu projeto e você precisará estar convencido de que há economias compensadas (potencialmente a longo prazo).

Em geral, use idiomas externos prontos para uso (como YAML, JSON ou CSV), se puder. Caso contrário, observe os idiomas internos. Recomendamos o uso de idiomas externos apenas nos casos em que seu idioma será gravado pelos usuários do seu aplicativo.

Uma linguagem de domínio interno em barato
Finalmente,
Há um trapaceiro para criar idiomas de domínio interno se você não se importar com a sintaxe da linguagem do host. Não faça um monte de metaprogramação. Em vez disso, apenas escreva funções para fazer o trabalho. De fato, é isso que o RSPEC faz:

Neste código, descreva, espera, e o EQ são apenas métodos de rubi. Há um pouco de encanamento nos bastidores em termos de como os objetos são transmitidos, mas tudo é apenas código. Vamos explorar isso um pouco nos exercícios.

Seções relacionadas incluem
Tópico 8, a essência do bom design
Tópico 13, protótipos e notas post-it
Tópico 32, configuração
Desafios
Alguns dos requisitos do seu projeto atual poderiam ser expressos em um idioma específico do domínio? Seria possível escrever um compilador ou tradutor que pudesse gerar a maior parte do código necessário?

Se você decidir adotar mini-idiomas como uma maneira de programar mais perto do domínio do problema, estará aceitando que algum esforço será necessário para implementá-los. Você pode ver maneiras pelas quais a estrutura que você desenvolve para um projeto pode ser reutilizada em outras pessoas?



Tópico 15
Estimativa
A Biblioteca do Congresso em Washington, DC, atualmente possui cerca de 75 terabytes de informações digitais on -line. Rápido! Quanto tempo levará para enviar todas essas informações em uma rede de 1 Gbps? Quanta armazenamento você precisará para um milhão de nomes e endereços? Quanto tempo leva para comprimir 100 MB de texto? Quantos meses levará para entregar seu projeto?

Em um nível, todas essas são perguntas sem sentido - todas estão ausentes de informações. E, no entanto, todos eles podem ser respondidos, desde que você esteja confortável em estimar. E, no processo de produção de uma estimativa, você entenderá mais sobre o mundo que seus programas habitam.

Ao aprender a estimar e desenvolvendo essa habilidade a ponto de ter uma sensação intuitiva pelas magnitudes das coisas, você poderá mostrar uma aparente capacidade mágica de determinar sua viabilidade. Quando alguém disser "enviaremos o backup sobre uma conexão de rede com o S3", você poderá saber intuitivamente se isso é prático. Ao codificar, você poderá saber quais subsistemas precisam otimizar e quais podem ser deixados em paz.

Dica 23 Estimativa para evitar surpresas
Como bônus, no final desta seção, revelaremos a resposta correta para dar sempre que alguém pedir uma estimativa.

Quão preciso é preciso o suficiente?
Até certo ponto, todas as respostas são estimativas. É que alguns são mais precisos que outros. Portanto, a primeira pergunta que você deve fazer a si mesmo quando alguém lhe pedir uma estimativa é o contexto em que sua resposta será levada. Eles precisam de alta precisão ou estão procurando uma figura de estádio?

Uma das coisas interessantes sobre estimar é que as unidades que você usa fazem a diferença na interpretação do resultado. Se você disser que algo levará cerca de 130 dias úteis, as pessoas esperam que ele chegue bem perto. No entanto, se você disser "Oh, cerca de seis meses", eles sabem procurá -lo a qualquer momento entre cinco e sete meses daqui. Ambos os números representam a mesma duração, mas "130 dias" provavelmente implica um maior grau de precisão do que você. Recomendamos que você escala estimativas de tempo da seguinte forma:

Duração

Estimativa de citação em

1–15 dias

Dias

3-6 semanas

Semanas

8 a 20 semanas

Meses

Mais de 20 semanas

Pense muito antes de dar uma estimativa

Portanto, se, depois de fazer todo o trabalho necessário, você decidir que um projeto levará 125 dias úteis (25 semanas), convém entregar uma estimativa de "cerca de seis meses".

Os mesmos conceitos se aplicam a estimativas de qualquer quantidade: escolha as unidades de sua resposta para refletir a precisão que você pretende transmitir.

De onde vêm as estimativas?
Todas as estimativas são baseadas nos modelos do problema. Mas antes de nos aprofundarmos muito nas técnicas de construção de modelos, precisamos mencionar um truque de estimativa básica que sempre dá boas respostas: pergunte a alguém que já o fez. Antes de se comprometer demais com a construção de modelos, lançado para alguém que esteve em uma situação semelhante no passado. Veja como o problema deles foi resolvido. É improvável que você encontre uma combinação exata, mas ficaria surpreso com quantas vezes você pode atrair com sucesso as experiências de outras pessoas.

Entenda o que está sendo perguntado
A primeira parte de qualquer exercício de estimativa é construir uma compreensão do que está sendo solicitado. Além dos problemas de precisão discutidos acima, você precisa ter uma compreensão do escopo do domínio. Muitas vezes isso está implícito na questão, mas você precisa
Torne o hábito de pensar no escopo antes de começar a adivinhar. Freqüentemente, o escopo que você escolhe faz parte da resposta que você dá: "Supondo que não haja acidentes de trânsito e que haja gás no carro, eu deveria estar lá em 20 minutos".

Construir um modelo do sistema
Esta é a parte divertida da estimativa. A partir da sua compreensão da pergunta, construa um modelo mental de ossos nus e prontos. Se você estiver estimando os tempos de resposta, seu modelo poderá envolver um servidor e algum tipo de tráfego que chega. Para um projeto, o modelo pode ser as etapas que sua organização usa durante o desenvolvimento, juntamente com uma imagem muito difícil de como o sistema pode ser implementado.

A construção de modelos pode ser criativa e útil a longo prazo. Freqüentemente, o processo de construção do modelo leva a descobertas de padrões e processos subjacentes que não eram aparentes na superfície. Você pode até querer reexaminar a pergunta original: “Você pediu uma estimativa para fazer X. No entanto, parece que Y, uma variante de X, pode ser feita em cerca de metade do tempo e você perde apenas um recurso.”

A construção do modelo introduz imprecisões no processo de estimativa. Isso é inevitável e também benéfico. Você está trocando a simplicidade do modelo por precisão. Dobrar o esforço do modelo pode dar apenas um ligeiro aumento de precisão. Sua experiência lhe dirá quando parar de refinar.

Quebre o modelo em componentes
Depois de ter um modelo, você pode decompô -lo em componentes. Você precisará descobrir as regras matemáticas que descrevem como esses componentes interagem. Às vezes, um componente contribui com um único valor adicionado ao resultado. Alguns componentes podem fornecer fatores de multiplicação, enquanto outros podem ser mais complicados (como aqueles que simulam a chegada do tráfego em um nó).

Você descobrirá que cada componente normalmente terá parâmetros que afetam como isso contribui para o modelo geral. Nesta fase, basta identificar cada parâmetro.

Dê um valor a cada parâmetro
Depois de quebrar os parâmetros, você pode passar e atribuir um valor a cada um. Você espera apresentar alguns erros nesta etapa. O truque é descobrir quais parâmetros têm o maior impacto no resultado e se concentrar em acertá -los. Normalmente, os parâmetros cujos valores são adicionados em resultado são menos significativos do que os multiplicados ou divididos. Dobrar uma velocidade de linha pode dobrar a quantidade de dados recebidos em uma hora, enquanto a adição de um atraso no trânsito de 5ms não terá efeito perceptível.

Você deve ter uma maneira justificável de calcular esses parâmetros críticos. Para o exemplo de fila, você pode medir a taxa de chegada da transação real do sistema existente ou encontrar um sistema semelhante para medir. Da mesma forma, você pode medir o tempo atual para atender a uma solicitação ou obter uma estimativa usando as técnicas descritas nesta seção. Na verdade, você geralmente se baseia baseando uma estimativa em outros subestimados. É aqui que seus maiores erros entrarão.

Calcule as respostas
Somente nos casos mais simples, uma estimativa terá uma única resposta. Você pode ficar feliz em dizer: "Eu posso andar cinco blocos entre cidades em 15 minutos". No entanto, à medida que os sistemas ficam mais complexos, você deseja proteger suas respostas. Execute vários cálculos, variando os valores dos parâmetros críticos, até descobrir quais realmente dirigem o modelo. Uma planilha pode ser uma grande ajuda. Em seguida, forneça sua resposta em termos desses parâmetros. "O tempo de resposta é de aproximadamente três quartos de segundo se o sistema tiver SSDs e 32 GB de memória e um segundo com memória de 16 GB". (Observe como "três quartos de um segundo" transmite um sentimento diferente de precisão de 750ms.)

Durante a fase de cálculo, você obtém respostas que parecem estranhas. Não seja muito rápido para descartá -los. Se sua aritmética estiver correta, sua compreensão do problema ou do seu modelo provavelmente está errada. Esta é uma informação valiosa.

Acompanhe suas proezas de estimativa
Achamos que é uma ótima idéia gravar suas estimativas para que você possa ver o quão perto você estava. Se uma estimativa geral envolveu o cálculo dos subestimados, também acompanhe isso. Muitas vezes, você descobrirá que suas estimativas são muito boas - na verdade, depois de um tempo, você espera isso.

Quando uma estimativa acaba errada, não apenas deça de ombros e vá embora - descubra o porquê. Talvez você tenha escolhido alguns parâmetros que não correspondem à realidade do problema. Talvez seu modelo estivesse errado. Seja qual for o motivo, reserve algum tempo para descobrir o que aconteceu. Se você fizer,
Sua próxima estimativa será melhor.

Estimativa de cronogramas do projeto
Normalmente, você será solicitado a estimar quanto tempo algo levará. Se esse "algo" for complexo, a estimativa pode ser muito difícil de produzir. Nesta seção, veremos duas técnicas para reduzir essa incerteza.

Pintando o míssil

"Quanto tempo levará para pintar a casa?"

"Bem, se tudo correr, e essa tinta tem a cobertura que afirmam, pode demorar apenas 10 horas. Mas isso é improvável: eu acho que uma figura mais realista está mais próxima de 18 horas. E, é claro, se o tempo ficar ruim, isso pode empurrá -lo para 30 ou mais."

É assim que as pessoas estimam no mundo real. Não com um único número (a menos que você os force a dar um), mas com uma variedade de cenários.

Quando a Marinha dos EUA precisava planejar o projeto submarino Polaris, eles adotaram esse estilo de estimativa com uma metodologia que chamavam de técnica de revisão de avaliação do programa, ou PERT.

Toda tarefa PERT tem uma estimativa otimista, mais provável e pessimista. As tarefas são organizadas em uma rede de dependência e você usa algumas estatísticas simples para identificar os melhores e os piores momentos prováveis para o projeto geral.

Usar uma variedade de valores como essa é uma ótima maneira de evitar uma das causas mais comuns de erro de estimativa: preencher um número porque você não tem certeza. Em vez disso, as estatísticas por trás da PERT divulgam a incerteza para você, oferecendo melhores estimativas de todo o projeto.

No entanto, não somos grandes fãs disso. As pessoas tendem a produzir gráficos do tamanho de uma parede de todas as tarefas em um projeto e acreditam implicitamente que, apenas porque usaram uma fórmula, elas têm uma estimativa precisa. As chances são de que não, porque nunca fizeram isso antes.

Comer o elefante
Descobrimos que muitas vezes a única maneira de determinar o cronograma para um projeto é obter experiência no mesmo projeto. Isso não precisa ser um paradoxo se você praticar o desenvolvimento incremental, repetindo as etapas a seguir com fatias muito finas de funcionalidade:

Verifique os requisitos
Analisar o risco (e priorizar itens mais arriscados mais cedo)
Projetar, implementar, integrar
Validar com os usuários
Inicialmente, você pode ter apenas uma vaga idéia de quantas iterações serão necessárias ou quanto tempo elas podem levar. Alguns métodos exigem que você acerte isso como parte do plano inicial; No entanto, para todos, exceto o mais trivial dos projetos, isso é um erro. A menos que você esteja fazendo um aplicativo semelhante ao anterior, com a mesma equipe e a mesma tecnologia, você estaria apenas adivinhando.

Assim, você conclui a codificação e teste da funcionalidade inicial e marque isso como o final da primeira iteração. Com base nessa experiência, você pode refinar seu palpite inicial sobre o número de iterações e o que pode ser incluído em cada um. O refinamento fica cada vez melhor a cada vez, e a confiança no cronograma cresce junto com ele. Esse tipo de estimativa geralmente é feito durante a revisão da equipe no final de cada ciclo iterativo.

É também assim que a velha piada diz para comer um elefante: uma mordida de cada vez.

Dica 24 itera o cronograma com o código
Isso pode não ser popular entre a gerência, que normalmente deseja um único número e rápido antes mesmo do projeto começar. Você terá que ajudá -los a entender que a equipe, sua produtividade e o ambiente determinarão o cronograma. Ao formalizar isso e refinar o cronograma como parte de cada iteração, você estará dando a eles as estimativas de agendamento mais precisas possível.

O que dizer quando solicitado uma estimativa
Você diz: "Eu vou voltar para você."

Você quase sempre obtém melhores resultados se desacelerar o processo e passar algum tempo passando pelas etapas que descrevemos nesta seção. As estimativas fornecidas na máquina de café (como o café) voltarão para assombrá -lo.

Seções relacionadas incluem
Tópico 7, comunique!
Tópico 39, velocidade do algoritmo
Desafios
Comece a manter um registro de suas estimativas. Para cada um, rastreie o quão preciso você se mostrou. Se seu erro foi superior a 50%, tente descobrir onde sua estimativa deu errado.