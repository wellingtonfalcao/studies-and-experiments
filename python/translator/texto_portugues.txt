O programador pragmático


Sua jornada para o domínio



Por Dave Thomas, Andy Hunt


Versão: P1.0 (13 de setembro de 2019)





Muitas das designações usadas pelos fabricantes e vendedores para distinguir seus produtos são reivindicados como marcas comerciais. Onde essas designações aparecem neste livro e o editor estava ciente de uma reivindicação de marca registrada, as designações foram impressas com letras maiúsculas iniciais ou em todas as capitais. "O programador pragmático" e o dispositivo G de vinculação são marcas comerciais do Pragmatic Programmers, LLC.

Os autores e editores cuidaram da preparação deste livro, mas não fazem garantia expressa ou implícita de qualquer tipo e não assumem nenhuma responsabilidade por erros ou omissões. Nenhuma responsabilidade é assumida por danos incidentais ou conseqüentes relacionados ou decorrentes do uso das informações ou programas aqui contidos.

Para obter informações sobre a compra deste título em quantidades em massa ou para oportunidades especiais de vendas (que podem incluir versões eletrônicas; designs de cobertura personalizada; e conteúdo particular dos seus negócios, metas de treinamento, foco de marketing ou interesses de marca), entre em contato com nosso departamento de vendas corporativas em Corpsales@pearsoned.com ou (800) 382-3419.

Para consultas de vendas do governo, entre em contato com governossales@pearsoned.com. Para perguntas sobre vendas fora dos EUA, entre em contato com intlcs@pearson.com. Visite -nos na web: informit.com/aw

Número de controle da Biblioteca do Congresso: 2019944178

Copyright © 2020 Pearson Education, Inc.

Imagens de capa: Mihalec/Shutterstock, Stockish/Shutterstock

Todos os direitos reservados. Esta publicação é protegida por direitos autorais e a permissão deve ser obtida do editor antes de qualquer reprodução proibida, armazenamento em um sistema de recuperação ou transmissão de qualquer forma ou por qualquer meio, eletrônico, mecânico, fotocópia, gravação ou da mesma forma. Para obter informações sobre permissões, formulários de solicitação e contatos apropriados no Departamento de Direitos Globais e Direitos Globais da Pearson Education, visite www.pearsoned.com/permissions.

ISBN-13: 978-0-13-595705-9

ISBN-10: 0-13-595705-2





Para Juliet e Ellie,

Zachary e Elizabeth,

Henry e Stuart





Índice


Prefácio

Prefácio da segunda edição como o livro está organizado

O que há em um nome?

Código -fonte e outros recursos

Envie -nos feedback

Agradecimentos da segunda edição





Do prefácio à primeira edição que deve ler este livro?

O que faz um programador pragmático?

Pragmatistas individuais, grandes equipes

É um processo contínuo





1. Um tópico de filosofia pragmática 1. É a sua vida

Tópico 2. O gato comeu meu código -fonte

Tópico 3. Entropia de software

Tópico 4. Sopa de pedra e sapos cozidos

Tópico 5. Software bom o suficiente

Tópico 6. Seu portfólio de conhecimento

Tópico 7. Comunique -se!





2. Uma abordagem pragmática tópico 8. A essência do bom design

Tópico 9. Seco - os males de duplicação

Tópico 10. Ortogonalidade

Tópico 11. Reversibilidade

Tópico 12. Bullets Tracer

Tópico 13. Protótipos e Notas Post-It

Tópico 14. Línguas de domínio

Tópico 15. Estimativa





3. O tópico das ferramentas básicas 16. O poder do texto simples

Tópico 17. Jogos de concha

Tópico 18. Edição de energia

Tópico 19. Controle de versão

Tópico 20. Depuração

Tópico 21. Manipulação de texto

Tópico 22. Daybooks de engenharia





4. Paranóia pragmática Tópico 23. Projeto por contrato

Tópico 24. Programas mortos não contam mentiras

Tópico 25. Programação Assertiva

Tópico 26. Como equilibrar recursos

Tópico 27. Não supere seus faróis





5. Bend, ou Break Topic 28. Desaparelamento

Tópico 29. Malabarismo no mundo real

Tópico 30. Transformando a programação

Tópico 31. Imposto sobre herança

Tópico 32. Configuração





6. Tópico de concorrência 33. Quebrando o acoplamento temporal

Tópico 34. Estado compartilhado é um estado incorreto

Tópico 35. atores e processos

Tópico 36. Blackboards





7. Enquanto você está codificando o tópico 37. Ouça seu cérebro de lagarto

Tópico 38. Programação por coincidência

Tópico 39. Velocidade do algoritmo

Tópico 40. Refatoração

Tópico 41. Teste para código

Tópico 42. Teste baseado em propriedades

Tópico 43. Fique seguro lá fora

Tópico 44. Nomear coisas





8. Antes do tópico do projeto 45. O poço de requisitos

Tópico 46. Resolvendo quebra -cabeças impossíveis

Tópico 47. Trabalhando juntos

Tópico 48. A essência da agilidade





9. Projetos pragmáticos Tópico 49. equipes pragmáticas

Tópico 50. Os cocos não o cortam

Tópico 51. Kit iniciante pragmático

Tópico 52. Alegue seus usuários

Tópico 53. Pride e preconceito





10. PostFace

A1. Bibliografia

A2. Respostas possíveis para os exercícios





Copyright © 2020 Pearson
Educação, Inc.





Louvor à segunda edição do programador pragmático


Alguns dizem que com o programador pragmático, Andy e Dave capturaram raios em uma garrafa; É improvável que alguém em breve escreva um livro que possa mover uma indústria inteira como fez. Às vezes, porém, o raio atinge duas vezes, e este livro é prova. O conteúdo atualizado garante que ele permaneça no topo das listas de "Melhores Livros em Desenvolvimento de Software" por mais 20 anos, exatamente onde pertence.



- VM (Vicky) Brasseur

Diretor de estratégia de código aberto, Juniper Networks





Se você deseja que seu software seja fácil de modernizar e manter, mantenha uma cópia do programador pragmático próximo. Está cheio de conselhos práticos, técnicos e profissionais, que servirão bem a você e a seus projetos nos próximos anos.



- Andrea Goulet

CEO, Corgibytes; Fundador, LegacyCode.rocks





O programador pragmático é o único livro que posso apontar que desalojou completamente a trajetória existente da minha carreira em software e me apontou na direção do sucesso. Ler isso abriu minha mente para as possibilidades de ser um artesão, não apenas uma engrenagem em uma grande máquina. Um dos livros mais significativos da minha vida.



- Obie Fernandez

Autor, o caminho do Rails





Os leitores iniciantes podem esperar uma indução fascinante no mundo moderno da prática de software, um mundo que a primeira edição desempenhou um papel importante na formação. Os leitores da primeira edição serão redescobertos aqui os insights e a sabedoria prática que tornaram o livro tão significativo em primeiro lugar, com curadoria e atualização, além de muito novo.



- David A. Black

Autor, o rubiista bem fundamentado





Eu tenho uma cópia antiga em papel do programador pragmático original na minha estante de livros. Ele foi lido e releituro e há muito tempo ele mudou tudo sobre como eu abordei meu trabalho como programador. Na nova edição, tudo e nada mudou: agora eu a li no meu iPad e os exemplos de código usam linguagens de programação modernas - mas os conceitos, idéias e atitudes subjacentes são atemporais e universalmente aplicáveis. Vinte anos depois, o livro é mais relevante do que nunca. Fico feliz em saber que os desenvolvedores atuais e futuros terão a mesma oportunidade de aprender com as profundas idéias de Andy e Dave que eu fiz na época.



- Sandy Mamoli

Treinador ágil, autor de como a auto-seleção permite que as pessoas se destaquem





Vinte anos atrás, a primeira edição do programador pragmático mudou completamente a trajetória da minha carreira. Esta nova edição pode fazer o mesmo para o seu.



- Mike Cohn

Autor de ter sucesso com estimativa e planejamento ágil e ágil e histórias de usuários aplicadas





Prefácio




Lembro -me de quando Dave e Andy twittaram pela primeira vez sobre a nova edição deste livro. Foi uma grande notícia. Eu assisti como a comunidade de codificação respondeu com emoção. Meu feed zumbiu com antecipação. Após vinte anos, o programador pragmático é tão relevante hoje quanto naquela época.

Diz muito que um livro com essa história teve essa reação. Tive o privilégio de ler uma cópia inédita para escrever esse prefácio, e entendi por que isso criou tanta agitação. Embora seja um livro técnico, chamando -o de um desserviço. Livros técnicos geralmente intimidam. Eles estão cheios de palavras grandes, termos obscuros, exemplos complicados que, sem querer, fazer você se sentir estúpido. Quanto mais experiente o autor, mais fácil é esquecer como é aprender novos conceitos, para ser iniciante.

Apesar de suas décadas de experiência em programação, Dave e Andy conquistaram o difícil desafio de escrever com a mesma emoção de pessoas que acabaram de aprender essas lições. Eles não falam com você. Eles não assumem que você é um especialista. Eles nem assumem que você leu a primeira edição. Eles levam você como você é - programadores que só querem ser melhores. Eles passam as páginas deste livro ajudando você a chegar lá, um passo acionável de cada vez.

Para ser justo, eles já haviam feito isso antes. O lançamento original estava cheio de exemplos tangíveis, novas idéias e dicas práticas para construir seus músculos de codificação e desenvolver seu cérebro de codificação que ainda se aplicam hoje. Mas esta edição atualizada faz duas melhorias no livro.

O primeiro é o óbvio: remove algumas das referências mais antigas, os exemplos desatualizados e os substitui por conteúdo moderno e fresco. Você não encontrará exemplos de invariantes de loop ou construir máquinas. Dave e Andy pegaram seu conteúdo poderoso e garantiram que as lições ainda vinham
Através, livre das distrações de exemplos antigos. Ele tira as idéias antigas como seco (não se repita) e lhes dá uma nova camada de tinta, fazendo -as brilhar.

Mas o segundo é o que torna esse lançamento realmente emocionante. Depois de escrever a primeira edição, eles tiveram a chance de refletir sobre o que estavam tentando dizer, o que queriam que seus leitores levassem e como isso estava sendo recebido. Eles receberam feedback sobre essas lições. Eles viram o que ficou preso, o que precisava refinar, o que foi incompreendido. Nos vinte anos em que este livro passou pelas mãos e corações dos programadores em todo o mundo, Dave e Andy estudaram essa resposta e formularam novas idéias, novos conceitos.

Eles aprenderam a importância da agência e reconheceram que os desenvolvedores têm indiscutivelmente mais agência do que a maioria dos outros profissionais. Eles começam este livro com a mensagem simples, mas profunda: "É a sua vida". Isso nos lembra nosso próprio poder em nossa base de código, em nossos empregos, em nossas carreiras. Ele define o tom para todo o resto do livro - que é mais do que apenas mais um livro técnico repleto de exemplos de código.

O que realmente se destaca entre as prateleiras dos livros técnicos é que ele entende o que significa ser um programador. A programação é tentar tornar o futuro menos doloroso. Trata -se de facilitar as coisas para nossos colegas de equipe. Trata -se de errar e ser capaz de se recuperar. Trata -se de formar bons hábitos. Trata -se de entender seu conjunto de ferramentas. A codificação é apenas parte do mundo de ser um programador, e este livro explora esse mundo.

Passo muito tempo pensando na jornada de codificação. Eu não cresci codificando; Eu não estudei na faculdade. Não passei minha adolescência mexendo com tecnologia. Entrei no mundo da codificação em meus vinte e poucos anos e tive que aprender o que significava ser um programador. Esta comunidade é muito diferente de outras pessoas das quais fiz parte. Há uma dedicação única à aprendizagem e praticidade que é refrescante e intimidador.

Para mim, realmente parece entrar em um novo mundo. Uma nova cidade, pelo menos. Eu tive que conhecer os vizinhos, escolher minha mercearia, encontrar os melhores cafeterias. Demorou um pouco para obter o Lay of the Land, para encontrar as rotas mais eficientes, para evitar as ruas com o tráfego mais pesado, para saber quando é provável que o tráfego atinasse. O tempo está diferente, eu precisava de um novo guarda -roupa.

As primeiras semanas, até meses, em uma nova cidade podem ser assustadoras. Não seria maravilhoso ter um vizinho amigável e experiente que morava lá há um tempo? Quem pode fazer uma turnê, mostrar esses cafeterias? Alguém que estava lá há tempo suficiente para conhecer a cultura, entender o pulso da cidade, então você não apenas se sente em casa, mas também se torna um membro contribuinte? Dave e Andy são aqueles vizinhos.

Como um recém -chegado relativo, é fácil ficar sobrecarregado não pelo ato de programação, mas pelo processo de se tornar um programador. Há uma mudança de mentalidade inteira que precisa acontecer - uma mudança de hábitos, comportamentos e expectativas. O processo de se tornar um programador melhor não acontece apenas porque você sabe como codificar; Deve ser recebido com intenção e prática deliberada. Este livro é um guia para se tornar um melhor programador com eficiência.

Mas não se engane - isso não diz como a programação deve ser. Não é filosófico ou julgador dessa maneira. Ele diz, puro e simples, o que é um programador pragmático - como eles operam e como eles abordam o código. Eles deixam para você decidir se você quer ser um. Se você acha que não é para você, eles não o manterão contra você. Mas se você decidir que é, eles são seus vizinhos amigáveis, para mostrar o caminho.



▶

Saron Yitbarek



Fundador e CEO da Codenewbie

Anfitrião de Heróis de Linha de Comando





Copyright © 2020 Pearson Education, Inc.





Prefácio da segunda edição




Nos anos 90, trabalhamos com empresas cujos projetos estavam tendo problemas. Nós nos encontramos dizendo as mesmas coisas para cada uma: talvez você deva testá -lo antes de enviá -lo; Por que o código só constrói na máquina de Mary? Por que ninguém perguntou aos usuários?

Para economizar tempo com novos clientes, começamos a anotar notas. E essas notas se tornaram o programador pragmático. Para nossa surpresa, o livro parecia ter um acorde, e continuou sendo popular nos últimos 20 anos.

Mas 20 anos são muitas vidas em termos de software. Pegue um desenvolvedor de 1999 e coloque -os em uma equipe hoje, e eles lutariam neste estranho mundo novo. Mas o mundo de
Os anos 90 são igualmente estranhos ao desenvolvedor de hoje. As referências do livro a coisas como corba, ferramentas de casos e loops indexados eram, na melhor das hipóteses, e mais provavelmente confusos.

Ao mesmo tempo, 20 anos não tiveram impacto no senso comum. A tecnologia pode ter mudado, mas as pessoas não o mudaram. Práticas e abordagens que eram uma boa idéia, então continuam sendo uma boa ideia agora. Esses aspectos do livro envelheceram bem.

Então, quando chegou a hora de criar esta edição do 20º aniversário, tivemos que tomar uma decisão. Poderíamos passar e atualizar as tecnologias que referenciamos e chamamos de dia. Ou poderíamos reexaminar as suposições por trás das práticas que recomendamos à luz de mais duas décadas de experiência.

No final, fizemos os dois.

Como resultado, este livro é um navio de Teseu. [1] Aproximadamente um terço dos tópicos do livro são novos. Do resto, a maioria foi reescrita, parcial ou totalmente. Nossa intenção era tornar as coisas mais claras, mais relevantes e esperamos um tanto atemporais.

Tomamos algumas decisões difíceis. Abaixamos o apêndice dos recursos, tanto porque seria impossível manter-se atualizado e porque é mais fácil procurar o que você deseja. Reorganizamos e reescrevemos tópicos a ver com a simultaneidade, dada a abundância atual de hardware paralelo e a escassez de boas maneiras de lidar com isso. Adicionamos conteúdo para refletir atitudes e ambientes em mudança, desde o movimento ágil que ajudamos a lançar, até a crescente aceitação de expressões de programação funcional e a crescente necessidade de considerar a privacidade e a segurança.

Curiosamente, porém, houve consideravelmente menos debate entre nós sobre o conteúdo desta edição do que quando escrevemos o primeiro. Nós dois sentimos que as coisas importantes eram mais fáceis de identificar.

De qualquer forma, este livro é o resultado. Por favor, aproveite. Talvez adote algumas novas práticas. Talvez decida que algumas das coisas que sugerimos estão erradas. Envolver -se em seu ofício. Dê -nos feedback.

Mas, mais importante, lembre -se de torná -lo divertido.





Como o livro é organizado


Este livro é escrito como uma coleção de tópicos curtos. Cada tópico é independente e aborda um tema específico. Você encontrará inúmeras referências cruzadas, que ajudam a colocar cada tópico em contexto. Sinta-se à vontade para ler os tópicos em qualquer ordem-este não é um livro que você precisa para ler a frente para trás.

Ocasionalmente, você se depara com uma caixa marcada com a ponta NN (como a dica 1, se preocupa com o seu ofício). Além de enfatizar os pontos no texto, sentimos que as dicas têm a vida própria - vivemos por eles diariamente. Você encontrará um resumo de todas as dicas em um cartão de tração dentro da tampa traseira.

Incluímos exercícios e desafios, quando apropriado. Os exercícios normalmente têm respostas relativamente simples, enquanto os desafios são mais abertos. Para dar uma idéia do nosso pensamento, incluímos nossas respostas aos exercícios em um apêndice, mas muito poucos têm uma única solução correta. Os desafios podem formar a base de discussões em grupo ou trabalho de ensaio em cursos de programação avançada.

Há também uma curta bibliografia listando os livros e artigos que referenciamos explicitamente.





O que há em um nome?


Espalhados ao longo do livro, você encontrará vários pedaços de jargão-perfeitamente boas palavras em inglês que foram corrompidas para significar algo técnico, ou horrendo palavras inventadas que foram atribuídas significados de cientistas da computação com um ressentimento contra o idioma. A primeira vez que usamos cada uma dessas palavras do jargão, tentamos defini -lo ou pelo menos dar uma dica ao seu significado. No entanto, temos certeza de que alguns caíram nas rachaduras, e outros, como objeto e banco de dados relacional, são em comum o uso suficiente para que a adição de uma definição seria chata. Se você se deparar com um termo que nunca viu antes, não pule sobre ele. Reserve um tempo para procurar, talvez na web, ou talvez em um livro de ciência da computação. E, se você tiver uma chance, envie -nos um e -mail e reclame, para que possamos adicionar uma definição à próxima edição.

Dito tudo isso, decidimos se vingar dos cientistas da computação. Às vezes, existem palavras perfeitamente boas para conceitos, palavras que decidimos ignorar. Por que? Porque o jargão existente é normalmente restrito a um domínio de problema específico ou a uma fase específica de desenvolvimento. No entanto, uma das filosofias básicas deste livro é que a maioria das técnicas que recomendamos é universal: a modularidade se aplica a código, designs, documentação e equipe
organização, por exemplo. Quando queríamos usar a palavra convencional do jargão em um contexto mais amplo, ela ficou confusa - não conseguimos superar a bagagem que o termo original trouxe com ela. Quando isso aconteceu, contribuímos para o declínio do idioma inventando nossos próprios termos.





Código -fonte e outros recursos


A maior parte do código mostrada neste livro é extraída de arquivos de origem compiláveis, disponíveis para download do nosso site. [2]

Lá você também encontrará links para os recursos que consideramos úteis, além de atualizações do livro e notícias de outros desenvolvimentos pragmáticos do programador.





Envie -nos feedback


Agradecemos ouvir de você. Envie um email para ppbook@pragprog.com.





Agradecimentos da segunda edição


Nós desfrutamos literalmente milhares de conversas interessantes sobre a programação nos últimos 20 anos, conhecendo pessoas em conferências, em cursos e às vezes até no avião. Cada um deles aumentou nossa compreensão do processo de desenvolvimento e contribuiu para as atualizações nesta edição. Obrigado a todos (e continuem nos dizendo quando estamos errados).

Graças aos participantes do processo beta do livro. Suas perguntas e comentários nos ajudaram a explicar as coisas melhor.

Antes de irmos beta, compartilhamos o livro com algumas pessoas para comentários. Graças a VM (Vicky) Brasseur, Jeff Langr e Kim Shrier por seus comentários detalhados e a José Valim e Nick Cuthbert por suas críticas técnicas.

Agradecemos a Ron Jeffries por nos deixar usar o exemplo sudoku.

Muita gratidão ao pessoal de Pearson que concordou em nos deixar criar este livro do nosso jeito.

Um agradecimento especial à indispensável Janet Furlow, que domina o que ela assume e nos mantém na fila.

E, finalmente, um grito para todos os programadores pragmáticos por aí que estão melhorando a programação para todos nos últimos vinte anos. Aqui estão mais vinte.





Notas de rodapé


[1]

Se, ao longo dos anos, todos os componentes de um navio são substituídos à medida que falharem, o navio resultante é o mesmo navio?



[2]

https://pragprog.com/titles/tpp20





Copyright © 2020 Pearson Education, Inc.





Do prefácio à primeira edição




Este livro ajudará você a se tornar um programador melhor.

Você pode ser um desenvolvedor solitário, um membro de uma grande equipe de projeto ou um consultor que trabalha com muitos clientes de uma só vez. Não importa; Este livro o ajudará, como indivíduo, a fazer melhor trabalho. Este livro não é teórico - nos concentramos em tópicos práticos, usando sua experiência para tomar decisões mais informadas. A palavra pragmática vem do latim Pragmaticus - "Skilled in Business" - que por sua vez é derivado do grego πραγματικός, o que significa "adequado para uso".

Este é um livro sobre fazer.

Programação é um ofício. No seu mais simples, tudo se resume a fazer um computador fazer o que você deseja (ou o que seu usuário deseja fazer). Como programador, você faz parte do ouvinte, parte do consultor, do intérprete de parte e do ditador de parte. Você tenta capturar requisitos indescritíveis e encontrar uma maneira de expressá -los para que uma mera máquina possa fazer justiça a eles. Você tenta documentar seu trabalho para que outras pessoas possam entendê -lo e tenta projetar seu trabalho para que outras pessoas possam desenvolvê -lo. Além disso, você tenta fazer tudo isso contra o ticking implacável do relógio do projeto. Você trabalha pequenos milagres todos os dias.

É um trabalho difícil.

Há muitas pessoas que oferecem ajudá -lo. Os fornecedores de ferramentas divulgam os milagres que seus produtos executam. Os gurus da metodologia prometem que suas técnicas garantem resultados. Todo mundo afirma que sua linguagem de programação é a melhor, e todo sistema operacional é a resposta para todos os males concebíveis.

Claro, nada disso é verdade. Não há respostas fáceis. Não existe a melhor solução, seja uma ferramenta, um idioma ou um sistema operacional. Só pode haver sistemas mais apropriados em um conjunto específico de circunstâncias.

É aqui que entra o pragmatismo. Você não deve se casar com nenhuma tecnologia específica, mas tem um fundo e uma base de experiência e experiência amplos para permitir que você escolha boas soluções em situações específicas. Sua formação decorre de uma compreensão dos princípios básicos da ciência da computação e sua experiência vem de uma ampla gama de projetos práticos. Teoria e prática combinam -se para fortalecer você.

Você ajusta sua abordagem para se adequar às circunstâncias e ambiente atuais. Você julga a importância relativa de todos os fatores que afetam um projeto e usa sua experiência para produzir soluções apropriadas. E você faz isso continuamente à medida que o trabalho avança.
Programadores pragmáticos fazem o trabalho e o fazem bem.





Quem deve ler este livro?


Este livro é destinado a pessoas que desejam se tornar programadores mais eficazes e mais produtivos. Talvez você se sinta frustrado por não estar alcançando seu potencial. Talvez você olhe para os colegas que parecem estar usando ferramentas para se tornarem mais produtivos do que você. Talvez seu trabalho atual use tecnologias mais antigas e você queira saber como as idéias mais recentes podem ser aplicadas ao que você faz.

Não fingimos ter todas (ou mesmo a maioria) das respostas, nem todas as nossas idéias são aplicáveis em todas as situações. Tudo o que podemos dizer é que, se você seguir nossa abordagem, obterá experiência rapidamente, sua produtividade aumentará e terá uma melhor compreensão de todo o processo de desenvolvimento. E você escreverá um software melhor.





O que faz um programador pragmático?


Cada desenvolvedor é único, com forças e fraquezas individuais, preferências e desgostos. Com o tempo, cada um criará seu próprio ambiente pessoal. Esse ambiente refletirá a individualidade do programador com a mesma força que seus hobbies, roupas ou corte de cabelo. No entanto, se você é um programador pragmático, compartilhará muitas das seguintes características:

ADOPTENTE/ADAPTADOR RÁPIDO

Você tem um instinto para tecnologias e técnicas, e adora experimentar as coisas. Quando recebeu algo novo, você pode entendê -lo rapidamente e integrá -lo ao resto do seu conhecimento. Sua confiança nasceu da experiência.



Inquisitivo

Você tende a fazer perguntas. Isso é legal - como você fez isso? Você teve problemas com essa biblioteca? O que é essa computação quântica que já ouvi sobre? Como os links simbólicos são implementados? Você é um rato de matilha para pequenos fatos, cada um dos quais pode afetar alguns anos de decisão daqui a.



Pensador crítico

Você raramente leva as coisas como dadas sem primeiro obter os fatos. Quando os colegas dizem "porque é assim que é feito" ou um fornecedor promete a solução para todos os seus problemas, você cheira um desafio.



Realista

Você tenta entender a natureza subjacente de cada problema que enfrenta. Esse realismo lhe dá uma boa sensação de como as coisas são difíceis e quanto tempo as coisas levarão. Entendendo profundamente que um processo deve ser difícil ou levará um tempo para concluir, dá a você a resistência para continuar.



Jack de todos os negócios

Você se esforça para se familiarizar com uma ampla gama de tecnologias e ambientes e trabalha para acompanhar os novos desenvolvimentos. Embora seu trabalho atual possa exigir que você seja especialista, você sempre poderá passar para novas áreas e novos desafios.





Deixamos as características mais básicas até o fim. Todos os programadores pragmáticos os compartilham. Eles são básicos o suficiente para declarar como dicas:

Dica 1 Cuide -se com o seu ofício



Achamos que não há sentido no desenvolvimento de software, a menos que você se preocupe em fazê -lo bem.

Dica 2 Pense! Sobre o seu trabalho



Para ser um programador pragmático, estamos desafiando você a pensar no que está fazendo enquanto faz isso. Esta não é uma auditoria única das práticas atuais-é uma avaliação crítica em andamento de todas as decisões que você toma, todos os dias e em todos os projetos. Nunca funcione no piloto automático. Estar constantemente pensando, criticando seu trabalho em tempo real. O velho lema corporativo da IBM, Think!, É o mantra do programador pragmático.

Se isso parece muito trabalho para você, você está exibindo a característica realista. Isso levará um pouco do seu tempo valioso - o tempo que provavelmente já está sob tremenda pressão. A recompensa é um envolvimento mais ativo com um trabalho que você ama, um sentimento de domínio sobre uma gama crescente de assuntos e prazer com um sentimento de melhoria contínua. A longo prazo, seu investimento em tempo será reembolsado à medida que você e sua equipe se tornarem mais eficientes, escreva código mais fácil de manter e gastar menos tempo nas reuniões.





Pragmatistas individuais, grandes equipes


Algumas pessoas sentem que não há espaço para individualidade em grandes equipes ou projetos complexos. "O software é uma disciplina de engenharia", dizem eles, "isso se decompõe se os membros individuais da equipe tomam decisões por si mesmos".

Nós discordamos fortemente.

Deve haver engenharia na construção de software. No entanto, isso não impede o artesanato individual. Pense nas grandes catedrais construídas na Europa durante a Idade Média. Cada um levou milhares de anos-ano de esforço, espalhado por muitas décadas. As lições aprendidas foram passadas para o próximo conjunto de construtores, que avançaram o estado de
Engenharia estrutural com suas realizações. Mas os carpinteiros, pedreiros, entalhadores e trabalhadores de vidro eram todos artesãos, interpretando os requisitos de engenharia para produzir um todo que transcendeu o lado puramente mecânico da construção. Era a sua crença em suas contribuições individuais que sustentou os projetos: nós, que cortamos meras pedras, devemos sempre estar imaginando as catedrais.

Dentro da estrutura geral de um projeto, sempre há espaço para individualidade e habilidade. Isso é particularmente verdadeiro, dado o estado atual da engenharia de software. Daqui a cem anos, nossa engenharia pode parecer tão arcaica quanto as técnicas usadas pelos construtores de catedrais medievais parecem aos engenheiros civis de hoje, enquanto nosso artesanato ainda será homenageado.





É um processo contínuo


Um turista que visita o Eton College da Inglaterra perguntou ao jardineiro como ele conseguiu os gramados tão perfeitos. "Isso é fácil", ele respondeu, "você apenas afasta o orvalho todas as manhãs, corta -os todos os dias e os rola uma vez por semana".

"Isso é tudo?" perguntou o turista. "Absolutamente", respondeu o jardineiro. "Faça isso por 500 anos e você também terá um bom gramado."

Grandes gramados precisam de pequenas quantidades de cuidados diários, assim como ótimos programadores. Os consultores de gerenciamento gostam de abandonar a palavra kaizen em conversas. "Kaizen" é um termo japonês que captura o conceito de fazer continuamente muitas pequenas melhorias. Foi considerado uma das principais razões para os ganhos dramáticos em produtividade e qualidade na fabricação japonesa e foi amplamente copiada em todo o mundo. Kaizen também se aplica aos indivíduos. Todos os dias, trabalhe para refinar as habilidades que você possui e adicionar novas ferramentas ao seu repertório. Ao contrário dos gramados de Eton, você começará a ver resultados em questão de dias. Ao longo dos anos, você ficará surpreso com a forma como sua experiência floresceu e como suas habilidades cresceram.



Copyright © 2020 Pearson Education, Inc.





Capítulo 1



Uma filosofia pragmática




Este livro é sobre você.

Não se engane, é sua carreira e, mais importante, o Tópico 1, é a sua vida. Você possui isso. Você está aqui porque sabe que pode se tornar um desenvolvedor melhor e ajudar os outros a se tornarem melhores também. Você pode se tornar um programador pragmático.

O que distingue programadores pragmáticos? Achamos que é uma atitude, um estilo, uma filosofia de abordar problemas e suas soluções. Eles pensam além do problema imediato, colocando -o em seu contexto maior e buscando o quadro geral. Afinal, sem esse contexto maior, como você pode ser pragmático? Como você pode tomar compromissos inteligentes e decisões informadas?

Outra chave para o sucesso deles é que os programadores pragmáticos assumem a responsabilidade por tudo o que fazem, que discutimos no tópico 2, o gato comeu meu código -fonte. Sendo responsáveis, os programadores pragmáticos não se sentam à toa e assistirão seus projetos desmoronarem por negligência. No tópico 3, entropia de software, dizemos como manter seus projetos intocados.

A maioria das pessoas acha as mudanças difíceis, às vezes por boas razões, às vezes por causa da antiga inércia. No tópico 4, sopa de pedra e sapos cozidos, analisamos uma estratégia para instigar mudanças e (no interesse do equilíbrio) apresentamos a história de advertência de um anfíbio que ignorou os perigos da mudança gradual.

Um dos benefícios de entender o contexto em que você trabalha é que fica mais fácil saber o quão bom seu software deve ser. Às vezes, a quase perfeição é a única opção, mas muitas vezes há compensações envolvidas. Exploramos isso no tópico 5, o software bom o suficiente.

Obviamente, você precisa ter uma ampla base de conhecimento e experiência para fazer tudo isso. O aprendizado é um processo contínuo e contínuo. No tópico 6, seu portfólio de conhecimento, discutimos algumas estratégias para manter o momento.

Finalmente, nenhum de nós trabalha no vácuo. Todos passamos uma grande quantidade de tempo interagindo com os outros. Tópico 7, Comunique! Lista maneiras de fazer isso melhor.

A programação pragmática deriva de uma filosofia do pensamento pragmático. Este capítulo define a base para essa filosofia.





Tópico 1

É a sua vida




Não estou neste mundo para cumprir suas expectativas e você não está neste mundo para cumprir o meu.



Bruce Lee



É a sua vida. Você possui isso. Você opera. Você cria.

Muitos desenvolvedores com quem conversamos estão frustrados. Suas preocupações são variadas. Alguns sentem que estão estagnando em seu trabalho, outros pela qual a tecnologia passou por eles. As pessoas sentem que estão sendo apreciadas ou mal pagas, ou que seus
As equipes são tóxicas. Talvez eles queiram se mudar para a Ásia, ou Europa, ou trabalhar em casa.

E a resposta que damos é sempre a mesma.

"Por que você não pode mudar isso?"

O desenvolvimento de software deve aparecer próximo ao topo de qualquer lista de carreiras onde você tenha controle. Nossas habilidades são procuradas, nosso conhecimento cruza os limites geográficos, podemos trabalhar remotamente. Nós somos bem pagos. Nós realmente podemos fazer praticamente tudo o que queremos.

Mas, por algum motivo, os desenvolvedores parecem resistir à mudança. Eles se abalam e esperam que as coisas melhorem. Eles olham, passivamente, à medida que suas habilidades se datam e reclamam que suas empresas não as treinam. Eles olham para os anúncios para locais exóticos no ônibus e depois entram na chuva arrepiante e entram no trabalho.

Então, aqui está a dica mais importante do livro.

Dica 3 você tem agência



Seu ambiente de trabalho é péssimo? O seu trabalho é chato? Tente consertar. Mas não tente para sempre. Como Martin Fowler diz: “Você pode mudar sua organização ou mudar sua organização.” [3]

Se a tecnologia parece estar passando por você, reserve um tempo (no seu próprio tempo) para estudar coisas novas que parecem interessantes. Você está investindo em si mesmo, então fazê-lo enquanto estiver próprio é razoável.

Quer trabalhar remotamente? Você perguntou? Se eles disserem não, encontre alguém que diga que sim.

Esta indústria oferece um conjunto notável de oportunidades. Seja proativo e leve -os.





Seções relacionadas incluem


Tópico 4, sopa de pedra e sapos cozidos

Tópico 6, seu portfólio de conhecimento





Tópico 2

O gato comeu meu código -fonte




	O maior de todas as fraquezas é o medo de parecer fraco.



J.B. Bossuet, Política de Holy Writ, 1709



Uma das pedras angulares da filosofia pragmática é a idéia de assumir a responsabilidade por você e suas ações em termos de avanço na carreira, seu aprendizado e educação, seu projeto e seu trabalho diário. Os programadores pragmáticos se encarregam de sua própria carreira e não têm medo de admitir ignorância ou erro. Não é o aspecto mais agradável da programação, com certeza, mas acontecerá - mesmo sobre os melhores projetos. Apesar dos testes completos, boa documentação e automação sólida, as coisas dão errado. As entregas estão atrasadas. Problemas técnicos imprevistos surgem.

Essas coisas acontecem, e tentamos lidar com elas o mais profissionalmente possível. Isso significa ser honesto e direto. Podemos nos orgulhar de nossas habilidades, mas devemos adquirir nossas deficiências - nossa ignorância e nossos erros.





Team confiança


Acima de tudo, sua equipe precisa confiar e confiar em você - e você precisa se sentir confortável confiando em cada um deles também. A confiança em uma equipe é absolutamente essencial para a criatividade e colaboração de acordo com a literatura de pesquisa. [4] Em um ambiente saudável baseado em confiança, você pode dizer com segurança, apresentar suas idéias e confiar nos membros da sua equipe que podem, por sua vez, confiar em você. Sem confiança, bem ...

Imagine uma equipe de alta tecnologia e Stealth Ninja se infiltrando no covil do vilão. Após meses de planejamento e execução delicada, você o fez no local. Agora é sua vez de montar a grade de orientação a laser: "Desculpe, pessoal, eu não tenho o laser. O gato estava brincando com o ponto vermelho e eu o deixei em casa".

Esse tipo de quebra de confiança pode ser difícil de reparar.





Assumir a responsabilidade


Responsabilidade é algo com o qual você concorda ativamente. Você se compromete a garantir que algo seja feito corretamente, mas não tem necessariamente controle direto sobre todos os aspectos. Além de fazer o seu melhor pessoal, você deve analisar a situação quanto aos riscos que estão além do seu controle. Você tem o direito de não assumir a responsabilidade por uma situação impossível, ou uma na qual os riscos são muito grandes, ou as implicações éticas muito esboçadas. Você precisará fazer a chamada com base em seus próprios valores e julgamento.

Quando você aceita a responsabilidade por um resultado, deve ser responsabilizado por isso. Quando você cometer um erro (como todos nós) ou um erro de julgamento, admiti -lo honestamente e tente oferecer opções.

Não culpe alguém ou outra coisa ou faça uma desculpa. Não culpe todos os problemas a um fornecedor, uma linguagem de programação, gerenciamento ou seus colegas de trabalho. Todo e tudo isso pode desempenhar um papel, mas cabe a você fornecer soluções, não desculpas.

Se houvesse o risco de que o fornecedor não aparecesse para você, você deveria ter um plano de contingência. Se o seu armazenamento em massa derreter - fazendo todo o seu código -fonte com ele - e você não tem um backup, é sua culpa. Dizendo ao seu chefe "o gato
Comeu meu código -fonte '' simplesmente não o cortará.

Dica 4 Ofereça opções, não faça desculpas esfarrapadas



Antes de você se aproximar de alguém para dizer a eles por que algo não pode ser feito, está atrasado ou está quebrado, pare e ouça a si mesmo. Fale com o pato de borracha no seu monitor ou no gato. Sua desculpa soa razoável ou estúpida? Como vai parecer seu chefe?

Corra pela conversa em sua mente. O que a outra pessoa provavelmente diz? Eles vão perguntar: "Você já tentou isso ..." ou "Você não considerou isso?" Como você vai responder? Antes de ir e contar as más notícias, há mais alguma coisa que você possa tentar? Às vezes, você sabe o que eles vão dizer, então salve o problema.

Em vez de desculpas, forneça opções. Não diga que não pode ser feito; Explique o que pode ser feito para salvar a situação. O código precisa ser excluído? Diga a eles e explique o valor da refatoração (consulte o tópico 40, refatoração).

Você precisa gastar prototipagem de tempo para determinar a melhor maneira de prosseguir (consulte o tópico 13, protótipos e notas post-it)? Você precisa introduzir melhores testes (consulte o tópico 41, teste para codificar e testes cruéis e contínuos) ou automação para impedir que isso aconteça novamente?

Talvez você precise de recursos adicionais para concluir esta tarefa. Ou talvez você precise passar mais tempo com os usuários? Ou talvez seja apenas você: você precisa aprender alguma técnica ou tecnologia com maior profundidade? Um livro ou um curso ajudaria? Não tenha medo de perguntar ou admitir que você precisa de ajuda.

Tente eliminar as desculpas esfarrapadas antes de expressá -las em voz alta. Se precisar, diga ao seu gato primeiro. Afinal, se pequenos telhas vão assumir a culpa….





Seções relacionadas incluem


Tópico 49, equipes pragmáticas





Desafios


Como você reage quando alguém - como um caixa, um mecânico de automóveis ou um funcionário - compara a você com uma desculpa manca? O que você acha deles e sua empresa como resultado?



Quando você se vê dizendo: "Eu não sei", siga -o com " - mas eu descobrirei". É uma ótima maneira de admitir o que você não sabe, mas assume a responsabilidade como um profissional.





Tópico 3

Entropia de software




Embora o desenvolvimento de software esteja imune a quase todas as leis físicas, o aumento inexorável da entropia nos atinge com força. A entropia é um termo da física que se refere à quantidade de "desordem" em um sistema. Infelizmente, as leis da termodinâmica garantem que a entropia no universo tende ao máximo. Quando o distúrbio aumenta no software, chamamos de "podridão do software". Algumas pessoas podem chamá -lo pelo termo mais otimista de "dívida técnica", com a noção implícita de que pagará de volta algum dia. Eles provavelmente não.

Seja qual for o nome, porém, a dívida e a podridão podem se espalhar incontrolavelmente.

Existem muitos fatores que podem contribuir para a podridão do software. O mais importante parece ser a psicologia ou cultura, trabalhando em um projeto. Mesmo se você é uma equipe de uma, a psicologia do seu projeto pode ser uma coisa muito delicada. Apesar dos melhores planos e das melhores pessoas, um projeto ainda pode experimentar ruína e deterioração durante sua vida. No entanto, existem outros projetos que, apesar das enormes dificuldades e contratempos constantes, combatem com sucesso a tendência da natureza em relação à desordem e conseguem sair muito bem.

O que faz a diferença?

Nas cidades internas, alguns edifícios são lindos e limpos, enquanto outros estão apodrecendo. Por que? Pesquisadores do campo do crime e decaimento urbano descobriram um mecanismo fascinante de gatilho, que rapidamente transforma um edifício limpo, intacto e habitado em um abandono e abandonado. [5]

Uma janela quebrada.

Uma janela quebrada, deixada não reparada por qualquer período substancial, instila nos habitantes do edifício uma sensação de abandono - um sentido de que os poderes que não se importam com o prédio. Então outra janela é quebrada. As pessoas começam a lixo. Graffiti aparece. Danos estruturais graves começam. Em um período relativamente curto, o edifício fica danificado além do desejo do proprietário de consertá -lo, e o sentimento de abandono se torna realidade.

Por que isso faria a diferença? Os psicólogos fizeram estudos [6] que mostram que a desesperança pode ser contagiosa. Pense no vírus da gripe de perto. Ignorar uma situação claramente quebrada reforça as idéias que talvez nada possa ser consertado, que ninguém se importa, tudo está condenado; Todos os pensamentos negativos que podem se espalhar entre os membros da equipe, criando uma espiral cruel.

Dica 5 Não mora com janelas quebradas



Não deixe "janelas quebradas" (designs ruins, errado
decisões, ou código ruim) não confirmado. Corrija cada um assim que for descoberto. Se não houver tempo suficiente para corrigi -lo corretamente, embarque -o. Talvez você possa comentar o código ofensivo ou exibir uma mensagem "não implementada" ou substituir dados fictícios. Tome algumas medidas para evitar mais danos e mostrar que você está no topo da situação.

Vimos sistemas limpos e funcionais se deteriorarem rapidamente quando o Windows começar a quebrar. Existem outros fatores que podem contribuir para a podridão do software, e abordaremos alguns deles em outros lugares, mas negligenciaremos acelerar a podridão mais rapidamente do que qualquer outro fator.

Você pode estar pensando que ninguém tem tempo para limpar todo o vidro quebrado de um projeto. Nesse caso, é melhor você planejar uma lixeira ou se mudar para outro bairro. Não deixe a entropia vencer.





Primeiro, não faça mal


Andy já tinha um conhecido que era obscenamente rico. Sua casa era imaculada, carregada de antiguidades inestimáveis, objetes d'Art e assim por diante. Um dia, uma tapeçaria que estava pendurada um pouco perto de uma lareira pega fogo. O corpo de bombeiros correu para salvar o dia - e sua casa. Mas antes de arrastarem suas grandes mangueiras sujas para a casa, eles pararam - com o fogo furioso - para rolar um tapete entre a porta da frente e a fonte do fogo.

Eles não queriam bagunçar o tapete.

Agora isso parece muito extremo. Certamente a primeira prioridade do corpo de bombeiros é apagar o incêndio, os danos colaterais são condenados. Mas eles claramente avaliaram a situação, estavam confiantes em sua capacidade de gerenciar o incêndio e tomaram cuidado para não causar danos desnecessários à propriedade. É assim que deve ser com o software: não cause danos colaterais apenas porque há algum tipo de crise. Uma janela quebrada é uma demais.

Uma janela quebrada - uma peça de código mal projetada, uma má decisão de gerenciamento com a qual a equipe deve viver durante a duração do projeto - é tudo o que é necessário para iniciar o declínio. Se você estiver trabalhando em um projeto com algumas janelas quebradas, é muito fácil entrar na mentalidade de "todo o restante deste código é uma porcaria, vou seguir o exemplo". Não importa se o projeto foi bom até este ponto. No experimento original, levando à "teoria da janela quebrada", um carro abandonado ficou por uma semana intocada. Mas uma vez que uma única janela foi quebrada, o carro foi despojado e virado de cabeça para baixo em poucas horas.

Da mesma forma, se você se encontrar em um projeto em que o código é intistinamente bonito - escrito, bem projetado e elegante - você provavelmente tomará um cuidado especial para não bagunçar, assim como os bombeiros. Mesmo se houver um incêndio (prazo, data de lançamento, demonstração da feira, etc.), você não quer ser o primeiro a fazer uma bagunça e causar danos adicionais.

Apenas diga a si mesmo: "Sem janelas quebradas".





Seções relacionadas incluem


Tópico 10, Ortogonalidade

Tópico 40, refatoração

Tópico 44, nomeando coisas





Desafios


Ajude a fortalecer sua equipe pesquisando o bairro do seu projeto. Escolha duas ou três janelas quebradas e discuta com seus colegas quais são os problemas e o que poderia ser feito para corrigi -los.



Você pode dizer quando uma janela é quebrada? Qual é a sua reação? Se foi o resultado da decisão de outra pessoa ou de um decreto da gerência, o que você pode fazer sobre isso?





Tópico 4

Sopa de pedra e sapos cozidos




Os três soldados que voltam para casa da guerra estavam com fome. Quando viram a vila à frente, seus espíritos se levantaram - eles tinham certeza de que os moradores lhes dariam uma refeição. Mas quando chegaram lá, encontraram as portas trancadas e as janelas fechadas. Depois de muitos anos de guerra, os moradores estavam com falta de comida e acumulavam o que tinham.

Sem se deixar abater, os soldados ferveram um pote de água e cuidadosamente colocaram três pedras nela. Os aldeões impressionados saíram para assistir.

"Esta é a sopa de pedra", explicou os soldados. "Isso é tudo que você coloca nele?" perguntou aos moradores. "Absolutamente - embora alguns digam que tem um gosto ainda melhor com algumas cenouras ..." Um aldeão fugiu, retornando em pouco tempo com uma cesta de cenouras de seu tesouro.

Alguns minutos depois, os moradores perguntaram novamente: "É isso?"

"Bem", disse os soldados, "duas batatas dão corpo". Off correu outro aldeão.

Durante a hora seguinte, os soldados listaram mais ingredientes que melhorariam a sopa: carne, alho -poró, sal e ervas. Cada vez que um aldeão diferente corria para invadir suas lojas pessoais.

Eventualmente eles produziram um pote grande de
sopa fumegante. Os soldados removeram as pedras e se sentaram com toda a vila para aproveitar a primeira refeição quadrada que qualquer um deles havia comido em meses.

Há alguns moral na história da sopa de pedra. Os moradores são enganados pelos soldados, que usam a curiosidade dos moradores para obter comida deles. Mais importante, porém, os soldados atuam como um catalisador, reunindo a vila para que possam produzir em conjunto algo que não poderiam ter feito por si mesmos - um resultado sinérgico. Eventualmente, todos vencem.

De vez em quando, você pode querer imitar os soldados.

Você pode estar em uma situação em que sabe exatamente o que precisa fazer e como fazê -lo. Todo o sistema aparece diante de seus olhos - você sabe que está certo. Mas peça permissão para enfrentar a coisa toda e você será recebido com atrasos e olhares em branco. As pessoas formarão comitês, os orçamentos precisarão de aprovação e as coisas ficarão complicadas. Todos vão guardar seus próprios recursos. Às vezes, isso é chamado de "fadiga inicial".

É hora de tirar as pedras. Descubra o que você pode pedir razoavelmente. Desenvolva bem. Depois de conseguir, mostre às pessoas e deixe -as se maravilhar. Então diga "É claro que seria melhor se acrescentarmos ..." Finja que não é importante. Sente -se e espere que eles comecem a pedir que você adicione a funcionalidade que você queria originalmente. As pessoas acham mais fácil participar de um sucesso contínuo. Mostre a eles um vislumbre do futuro e você o levará a se unir. [7]

Dica 6 seja um catalisador para a mudança





O lado dos moradores


Por outro lado, a história da sopa de pedra também é sobre engano gentil e gradual. Trata -se de focar com muita força. Os moradores pensam nas pedras e esquecem o resto do mundo. Todos nós caímos nisso, todos os dias. As coisas simplesmente se arrastam para nós.

Todos nós vimos os sintomas. Projetos lenta e inexoravelmente ficam totalmente fora de controle. A maioria dos desastres de software começa muito pequena para observar, e a maioria dos excedentes de projetos acontece um dia por vez. Os sistemas flutuam de seus recursos de especificações por recurso, enquanto o patch após o patch é adicionado a um pedaço de código até que não haja nada da esquerda original. Muitas vezes, é o acúmulo de pequenas coisas que quebram o moral e as equipes.

Dica 7 Lembre -se do quadro geral



Nós nunca tentamos isso - o melhor. Mas "eles" dizem que, se você pegar um sapo e soltá -lo em água fervente, ele voltará diretamente. No entanto, se você colocar o sapo em uma panela de água fria, aqueça gradualmente, o sapo não notará o lento aumento de temperatura e permanecerá parado até cozinhar.

Observe que o problema do sapo é diferente do problema do Windows quebrado discutido no tópico 3, entropia de software. Na teoria da janela quebrada, as pessoas perdem a vontade de combater a entropia porque percebem que ninguém mais se importa. O sapo simplesmente não percebe a mudança.

Não seja como o lendário sapo. Fique de olho no quadro geral. Revise constantemente o que está acontecendo ao seu redor, não apenas o que você está fazendo pessoalmente.





Seções relacionadas incluem


Tópico 1, é a sua vida

Tópico 38, Programação por coincidência





Desafios


Ao revisar um rascunho da primeira edição, John Lakos levantou a seguinte edição: Os soldados enganam progressivamente os moradores, mas a mudança que catalisam faz com que todos eles sejam bem. No entanto, ao enganar progressivamente o sapo, você está causando danos. Você pode determinar se está fazendo sopa de pedra ou sopa de sapo quando tenta catalisar a mudança? A decisão é subjetiva ou objetiva?



Rápido, sem olhar, quantas luzes estão no teto acima de você? Quantas saídas na sala? Quantas pessoas? Existe algo fora de contexto, algo que parece que não pertence? Este é um exercício de consciência situacional, uma técnica praticada por pessoas que variam de escoteiras de meninos e garotas a focas da Marinha. Entre no hábito de realmente olhar e perceber o ambiente. Então faça o mesmo com o seu projeto.





Tópico 5

Software bom o suficiente




	Esforçando -se para melhor, muitas vezes marcarmos o que está bem.



Shakespeare, rei Lear 1.4



Há uma piada antiga (ish) sobre uma empresa que faz um pedido para 100.000 ICs com um fabricante japonês. Parte da especificação foi a taxa de defeito: um chip em 10.000. Algumas semanas depois, chegou o pedido: uma caixa grande contendo milhares de ICs e uma pequena contendo apenas dez. Anexado à caixa pequena, havia um rótulo que dizia: "Estes são os defeituosos".

Se ao menos tivéssemos realmente esse tipo de controle sobre a qualidade. Mas o mundo real simplesmente não nos deixa produzir muito que é realmente perfeito,
particularmente não software sem insetos. Tempo, tecnologia e temperamento conspiram contra nós.

No entanto, isso não precisa ser frustrante. Como ED Yourdon descreveu em um artigo do IEEE Software, quando o software o suficiente é o melhor [você95], você pode se disciplinar para escrever software que seja bom o suficiente-bom o suficiente para seus usuários, para futuros mantenedores, para sua própria paz de espírito. Você descobrirá que é mais produtivo e seus usuários estão mais felizes. E você pode achar que seus programas são realmente melhores para a incubação mais curta.

Antes de prosseguirmos, precisamos qualificar o que estamos prestes a dizer. A frase "boa o suficiente" não implica um código desleixado ou mal produzido. Todos os sistemas devem atender aos requisitos de seus usuários para ter sucesso e atender aos padrões básicos de desempenho, privacidade e segurança. Estamos simplesmente defendendo que os usuários tenham a oportunidade de participar do processo de decisão quando o que você produziu é bom o suficiente para suas necessidades.





Envolva seus usuários no trade-off


Normalmente, você está escrevendo software para outras pessoas. Muitas vezes você se lembra de descobrir o que eles querem. [8] Mas você já pergunta o quão bom eles querem que seu software seja? Às vezes, não haverá escolha. Se você estiver trabalhando em marcapassos, um piloto automático ou uma biblioteca de baixo nível que será amplamente disseminada, os requisitos serão mais rigorosos e suas opções mais limitadas.

No entanto, se você estiver trabalhando em um produto novinho em folha, terá restrições diferentes. O pessoal de marketing terá promessa de cumprir, os eventuais usuários finais podem ter feito planos com base em um cronograma de entrega, e sua empresa certamente terá restrições de fluxo de caixa. Seria não profissional ignorar os requisitos desses usuários simplesmente adicionar novos recursos ao programa ou aprimorar o código apenas mais uma vez. Não estamos defendendo o pânico: é igualmente pouco profissional prometer escalas de tempo impossíveis e cortar cantos básicos de engenharia para cumprir um prazo.

O escopo e a qualidade do sistema que você produz devem ser discutidos como parte dos requisitos desse sistema.

Dica 8 Faça de qualidade um problema de requisitos



Muitas vezes, você estará em situações em que as compensações estão envolvidas. Surpreendentemente, muitos usuários preferem usar o software com algumas arestas hoje do que esperar um ano pela versão brilhante e de sino e branquear (e na verdade eles precisarão de um ano daqui a ser completamente diferente). Muitos departamentos de TI com orçamentos apertados concordariam. O ótimo software hoje costuma ser preferível à fantasia do software perfeito amanhã. Se você der aos usuários algo para brincar cedo, o feedback deles geralmente o levará a uma solução final melhor (consulte o tópico 12, marcadores de rastreamento).





Saiba quando parar


De certa forma, a programação é como pintura. Você começa com uma tela em branco e certas matérias -primas básicas. Você usa uma combinação de ciência, arte e artesanato para determinar o que fazer com eles. Você esboça uma forma geral, pinta o ambiente subjacente e depois preenche os detalhes. Você constantemente recupera com um olhar crítico para ver o que fez. De vez em quando você joga uma tela fora e começa novamente.

Mas os artistas lhe dirão que todo o trabalho duro é arruinado se você não souber quando parar. Se você adicionar camada após a camada, detalhes sobre detalhes, a pintura se perderá na tinta.

Não estrague um programa perfeitamente bom por excesso de descrição e excesso de refinamento. Avance em frente e deixe seu código ficar por si só por um tempo. Pode não ser perfeito. Não se preocupe: nunca poderia ser perfeito. (No capítulo 7, enquanto você estiver codificando, discutiremos filosofias para o desenvolvimento de código em um mundo imperfeito.)





Seções relacionadas incluem


Tópico 45, o poço de requisitos

Tópico 46, resolvendo quebra -cabeças impossíveis





Desafios


Veja as ferramentas de software e os sistemas operacionais que você usa regularmente. Você consegue encontrar alguma evidência de que essas organizações e/ou desenvolvedores sejam software de remessa confortável que eles sabem que não são perfeitos? Como usuário, você prefere (1) esperar que eles divulgem todos os bugs, (2) tenham software complexo e aceitam alguns bugs ou (3) opte por software mais simples com menos defeitos?



Considere o efeito da modularização na entrega de software. Levará mais ou menos tempo para obter um bloco monolítico de software firmemente acoplado à qualidade necessária em comparação com um sistema projetado como módulos ou microsserviços muito pouco acoplados? Quais são as vantagens ou desvantagens de cada abordagem?



Você pode pensar em software popular que sofre
De Bloat? Ou seja, software contendo muito mais recursos do que você jamais usaria, cada recurso introduzindo mais oportunidades para bugs e vulnerabilidades de segurança e tornando os recursos que você usa mais para encontrar e gerenciar. Você corre o risco de cair nessa armadilha?





Tópico 6

Seu portfólio de conhecimento




Um investimento em conhecimento sempre paga o melhor interesse.



Benjamin Franklin



Ah, o bom e velho Ben Franklin - nunca perdido para uma homilia expressa. Por que, se poderíamos chegar cedo para a cama e cedo para subir, seríamos ótimos programadores - bem? O madrugador pode conseguir o verme, mas o que acontece com o verme inicial?

Nesse caso, porém, Ben realmente bateu na unha na cabeça. Seu conhecimento e experiência são seus ativos profissionais diários mais importantes.

Infelizmente, eles estão expirando ativos. [9] Seu conhecimento fica desatualizado à medida que novas técnicas, idiomas e ambientes são desenvolvidos. A mudança das forças do mercado pode tornar sua experiência obsoleta ou irrelevante. Dado o ritmo cada vez maior de mudança em nossa sociedade tecnológica, isso pode acontecer rapidamente.

À medida que o valor do seu conhecimento diminui, o seu valor também para sua empresa ou cliente. Queremos impedir que isso aconteça.

Sua capacidade de aprender coisas novas é o seu ativo estratégico mais importante. Mas como você aprende a aprender e como sabe o que aprender?





Seu portfólio de conhecimento


Gostamos de pensar em todos os programadores de fatos sobre a computação, os domínios de aplicativos em que trabalham e toda a sua experiência como portfólios de conhecimento. Gerenciar um portfólio de conhecimento é muito semelhante ao gerenciamento de um portfólio financeiro:

Investidores sérios investem regularmente - como um hábito.

A diversificação é a chave para o sucesso a longo prazo.

Os investidores inteligentes equilibram seus portfólios entre investimentos conservadores e de alto risco e de alta recompensa.

Os investidores tentam comprar baixo e vender alto para retorno máximo.

Os portfólios devem ser revisados e reequilibrados periodicamente.



Para ter sucesso em sua carreira, você deve investir em seu portfólio de conhecimento usando essas mesmas diretrizes.

A boa notícia é que gerenciar esse tipo de investimento é uma habilidade como qualquer outra - pode ser aprendido. O truque é fazer isso de forma inicial e formar um hábito. Desenvolva uma rotina que você segue até que seu cérebro a internalize. Nesse ponto, você se encontrará sugando novos conhecimentos automaticamente.





Construindo seu portfólio


Invista regularmente

Assim como no investimento financeiro, você deve investir em seu portfólio de conhecimento regularmente, mesmo que seja apenas uma pequena quantia. O hábito é tão importante quanto as somas; portanto, planeje usar um tempo e local consistentes, longe das interrupções. Alguns objetivos de amostra estão listados na próxima seção.



Diversificar

Quanto mais coisas diferentes você souber, mais valioso é. Como linha de base, você precisa conhecer os meandros da tecnologia específica com a qual está trabalhando atualmente. Mas não pare por aí. A face da computação muda rapidamente - a tecnologia hoje pode estar perto de inútil (ou pelo menos não em demanda) amanhã. Quanto mais tecnologias você estiver confortável, melhor você poderá se ajustar a mudar. E não se esqueça de todas as outras habilidades que você precisa, incluindo as de áreas não técnicas.



Gerenciar riscos

A tecnologia existe ao longo de um espectro de padrões arriscados, potencialmente de alta recompensa a baixo risco e baixa recompensa. Não é uma boa ideia investir todo o seu dinheiro em ações de alto risco que podem entrar em colapso de repente, nem você deve investir tudo de forma conservadora e perder possíveis oportunidades. Não coloque todos os seus ovos técnicos em uma cesta.



Compre baixo, venda alto

Aprender uma tecnologia emergente antes de se tornar popular pode ser tão difícil quanto encontrar um estoque subvalorizado, mas o retorno pode ser igualmente gratificante. Aprender a Java quando foi introduzido e desconhecido pode ter sido arriscado na época, mas valeu a pena pelos primeiros adotantes quando se tornou um dos pilares da indústria mais tarde.



Revisão e reequilíbrio

Esta é uma indústria muito dinâmica. Essa tecnologia quente que você começou a investigar no mês passado pode estar frio agora. Talvez você precise aprimorar essa tecnologia de banco de dados que você não usa há algum tempo. Ou talvez você possa estar melhor posicionado para essa nova abertura de emprego se você experimentasse esse outro idioma….





De todas essas diretrizes, a mais importante é a mais simples de fazer:

Dica 9 Invista regularmente em seu portfólio de conhecimento





Metas


Agora que você tem algumas diretrizes sobre o que e quando
Adicione ao seu portfólio de conhecimento, qual é a melhor maneira de adquirir capital intelectual para financiar seu portfólio? Aqui estão algumas sugestões:

Aprenda pelo menos um novo idioma todos os anos

Diferentes idiomas resolvem os mesmos problemas de maneiras diferentes. Ao aprender várias abordagens diferentes, você pode ajudar a ampliar seu pensamento e evitar ficar preso em uma rotina. Além disso, aprender muitos idiomas é fácil graças à riqueza de software disponível gratuitamente.



Leia um livro técnico todos os meses

Embora exista um excesso de ensaios de formato curto e respostas ocasionalmente confiáveis na web, para um entendimento profundo, você precisa de livros de forma longa. Navegue pelos livreiros para livros técnicos sobre tópicos interessantes relacionados ao seu projeto atual. [10] Quando estiver no hábito, leia um livro por mês. Depois de dominar as tecnologias que está usando, ramifique e estuda alguns que não se relacionam com o seu projeto.



Leia livros não técnicos também

É importante lembrar que os computadores são usados por pessoas - pessoas cujas necessidades você está tentando satisfazer. Você trabalha com pessoas, é empregado por pessoas e é invadido pelas pessoas. Não se esqueça do lado humano da equação, pois isso requer um conjunto de habilidades totalmente diferente (chamamos ironicamente essas habilidades sociais, mas elas são realmente muito difíceis de dominar).



Tire aulas

Procure cursos interessantes em uma faculdade ou universidade local ou on -line, ou talvez na próxima feira ou conferência próxima.



Participar de grupos de usuários locais e encontros

O isolamento pode ser mortal para sua carreira; Descubra o que as pessoas estão trabalhando fora da sua empresa. Não vá e ouça: participe ativamente.



Experimente ambientes diferentes

Se você trabalhou apenas no Windows, passe algum tempo com o Linux. Se você usou apenas makefiles e um editor, tente um IDE sofisticado com recursos de ponta e vice-versa.



Fique atual

Leia notícias e postagens on -line em tecnologia diferente da do seu projeto atual. É uma ótima maneira de descobrir quais experiências outras pessoas estão tendo com isso, o jargão em particular que eles usam e assim por diante.





É importante continuar investindo. Depois de se sentir confortável com um novo idioma ou um pouco de tecnologia, siga em frente. Aprenda outro.

Não importa se você usa alguma dessas tecnologias em um projeto, ou mesmo se você as coloca em seu currículo. O processo de aprendizado expandirá seu pensamento, abrindo -o para novas possibilidades e novas maneiras de fazer as coisas. A polinização cruzada de idéias é importante; Tente aplicar as lições que você aprendeu ao seu projeto atual. Mesmo que o seu projeto não use essa tecnologia, talvez você possa emprestar algumas idéias. Familiarize -se com a orientação do objeto, por exemplo, e você escreverá programas processuais de maneira diferente. Entenda o paradigma de programação funcional e você escreverá o código orientado a objetos de maneira diferente e assim por diante.





Oportunidades de aprendizado


Então, você está lendo vorazmente, está no topo dos últimos desenvolvimentos de quebra em seu campo (não é uma coisa fácil de fazer) e alguém faz uma pergunta. Você não tem a idéia mais fraca qual é a resposta e admite livremente.

Não deixe isso parar por aí. Tome como um desafio pessoal encontrar a resposta. Pergunte ao redor. Pesquise na Web - as partes acadêmicas também, não apenas as peças do consumidor.

Se você não conseguir encontrar a resposta, descubra quem pode. Não deixe descansar. Conversar com outras pessoas ajudará a construir sua rede pessoal e você poderá se surpreender encontrando soluções para outros problemas não relacionados ao longo do caminho. E esse antigo portfólio continua ficando maior….

Toda essa leitura e pesquisa leva tempo e o tempo já está em falta. Então você precisa planejar com antecedência. Sempre tenha algo para ler em um momento morto. O tempo gasto esperando por médicos e dentistas pode ser uma grande oportunidade de acompanhar sua leitura-mas não deixe de trazer seu próprio e-reader com você, ou você pode se encontrar com um artigo de 1973 com orelhas de cachorro sobre a Papua Nova Guiné.





Pensamento crítico


O último ponto importante é pensar criticamente sobre o que você lê e ouve. Você precisa garantir que o conhecimento em seu portfólio seja preciso e sem subsídio pelo hype do fornecedor ou da mídia. Cuidado com os fanáticos que insistem que seu dogma fornece a única resposta - pode ou não ser aplicável a você e ao seu projeto.

Nunca subestime o poder do comercialismo. Só porque um mecanismo de pesquisa na web lista um acerto primeiro não significa que é o melhor
corresponder; O provedor de conteúdo pode pagar para obter o faturamento superior. Só porque uma livraria apresenta um livro com destaque não significa que é um bom livro ou até popular; Eles podem ter sido pagos para colocá -lo lá.

Dica 10 Analise criticamente o que você lê e ouve



O pensamento crítico é uma disciplina inteira para si mesma, e incentivamos você a ler e estudar tudo o que puder sobre isso. Enquanto isso, aqui está uma vantagem com algumas perguntas para fazer e pensar.

Pergunte aos "cinco porquês"

Um truque de consultoria favorito: pergunte "Por quê?" pelo menos cinco vezes. Faça uma pergunta e obtenha uma resposta. Cavar mais fundo perguntando "Por quê?" Repita como se você tivesse uma petulante de quatro anos (mas educado). Você pode se aproximar de uma causa raiz dessa maneira.



Quem isso se beneficia?

Pode parecer cínico, mas siga o dinheiro pode ser um caminho muito útil para analisar. Os benefícios para outra pessoa ou outra organização podem estar alinhados com os seus ou não.



Qual é o contexto?

Tudo ocorre em seu próprio contexto, e é por isso que as soluções de "tamanho único" geralmente não. Considere um artigo ou livro divulgando uma "prática recomendada". Boas perguntas a serem consideradas são "melhores para quem?" Quais são os pré -requisitos, quais são as consequências, a curto e a longo prazo?



Quando ou onde isso funcionaria?

Em que circunstâncias? É tarde demais? Muito cedo? Não pare com o pensamento de primeira ordem (o que acontecerá a seguir), mas use o pensamento de segunda ordem: o que acontecerá depois disso?



Por que isso é um problema?

Existe um modelo subjacente? Como funciona o modelo subjacente?





Infelizmente, existem muito poucas respostas simples. Mas com seu extenso portfólio e, ao aplicar alguma análise crítica à torrente de artigos técnicos que você lerá, você pode entender as respostas complexas.





Seções relacionadas incluem


Tópico 1, é a sua vida

Tópico 22, Daybooks de engenharia





Desafios


Comece a aprender um novo idioma nesta semana. Sempre programado na mesma língua antiga? Experimente Clojure, Elixir, Elm, F#, Go, Haskell, Python, R, RachoinML, Ruby, Rust, Scala, Swift, Typescript ou qualquer outra coisa que apela e/ou parece que você gosta. [11]



Comece a ler um novo livro (mas termine este primeiro!). Se você estiver fazendo implementação e codificação muito detalhadas, leia um livro sobre design e arquitetura. Se você estiver fazendo design de alto nível, leia um livro sobre técnicas de codificação.



Saia e converse tecnologia com pessoas que não estão envolvidas em seu projeto atual ou que não trabalham para a mesma empresa. Rede na cafeteria da sua empresa, ou talvez procure colegas entusiastas em um encontro local.





Tópico 7

Comunicar!




Eu acredito que é melhor ser visto do que para ser esquecido.



Mae West, Belle dos anos 90, 1934



Talvez possamos aprender uma lição da Sra. West. Não é apenas o que você tem, mas também como o empacote. Ter as melhores idéias, o melhor código ou o pensamento mais pragmático é, em última análise, estéril, a menos que você possa se comunicar com outras pessoas. Uma boa ideia é um órfão sem comunicação eficaz.

Como desenvolvedores, temos que nos comunicar em muitos níveis. Passamos horas em reuniões, ouvindo e conversando. Trabalhamos com usuários finais, tentando entender suas necessidades. Escrevemos o código, que comunica nossas intenções a uma máquina e documenta nosso pensamento para as gerações futuras de desenvolvedores. Escrevemos propostas e memorandos solicitando e justificando recursos, relatando nosso status e sugerindo novas abordagens. E trabalhamos diariamente em nossas equipes para defender nossas idéias, modificar as práticas existentes e sugerir novas. Grande parte do dia é gasta se comunicando, então precisamos fazê -lo bem.

Trate o inglês (ou qualquer que seja sua língua nativa) como apenas mais uma linguagem de programação. Escreva a linguagem natural como você escreveria código: honre o princípio seco, etc, automação e assim por diante. (Discutimos os princípios de design seco e etc no próximo capítulo.)

Dica 11 O inglês é apenas mais uma linguagem de programação



Reunimos uma lista de idéias adicionais que achamos úteis.





Conheça seu público


Você está se comunicando apenas se estiver transmitindo o que pretende transmitir - apenas conversar não é suficiente. Para fazer isso, você precisa entender as necessidades, interesses e capacidades do seu público. Todos nós sentamos em reuniões em que um geek de desenvolvimento de esmaltes sobre os olhos do vice -presidente de marketing com um longo monólogo sobre os méritos de alguma tecnologia misteriosa. Isso não está se comunicando: está apenas falando e é irritante. [12]

Diga que você deseja alterar seu sistema de monitoramento remoto para
Use um corretor de mensagens de terceiros para disseminar notificações de status. Você pode apresentar esta atualização de muitas maneiras diferentes, dependendo do seu público. Os usuários finais apreciarão que seus sistemas agora possam interoperar com outros serviços que usam o corretor. Seu departamento de marketing poderá usar esse fato para aumentar as vendas. Os gerentes de desenvolvimento e operações ficarão felizes porque o cuidado e a manutenção dessa parte do sistema agora são o problema de outra pessoa. Por fim, os desenvolvedores podem gostar de ter experiência com novas APIs e podem até encontrar novos usos para o corretor de mensagens. Ao fazer o argumento apropriado para cada grupo, você os empolgará com o seu projeto.

Como em todas as formas de comunicação, o truque aqui é obter feedback. Não espere apenas perguntas: peça -as. Olhe para a linguagem corporal e expressões faciais. Um dos pressupostos neuro -linguísticos é "o significado da sua comunicação é a resposta que você recebe". Melhore continuamente seu conhecimento do seu público à medida que você se comunica.





Saiba o que você quer dizer


Provavelmente, a parte mais difícil dos estilos de comunicação mais formais usados nos negócios é descobrir exatamente o que você deseja dizer. Os escritores de ficção costumam traçar seus livros em detalhes antes de começarem, mas as pessoas que escrevem documentos técnicos geralmente ficam felizes em sentar em um teclado, digite:

Introdução





E comece a digitar o que quer que chegue em suas cabeças a seguir.

Planeje o que você quer dizer. Escreva um esboço. Então pergunte a si mesmo: "Isso comunica o que eu quero expressar ao meu público de uma maneira que funcione para eles?" Refine até que isso aconteça.

Essa abordagem funciona para mais do que apenas documentos. Quando você se depara com uma reunião importante ou um bate -papo com um grande cliente, anote as idéias que deseja se comunicar e planeje algumas estratégias para colocá -las.

Agora que você sabe o que seu público quer, vamos entregá -lo.





Escolha seu momento


São seis horas na tarde de sexta -feira, após uma semana em que os auditores chegaram. O mais novo do seu chefe está no hospital, está chovendo lá fora, e a casa é garantida como um pesadelo. Provavelmente não é um bom momento para pedir a ela uma atualização de memória para o seu laptop.

Como parte do entendimento do que seu público precisa ouvir, você precisa descobrir quais são suas prioridades. Assista a um gerente que acabou de ter dificuldade em seu chefe porque algum código -fonte se perdeu e você terá um ouvinte mais receptivo para suas idéias sobre os repositórios do código -fonte. Faça o que você está dizendo relevante no tempo, bem como no conteúdo. Às vezes, basta a pergunta simples: "Este é um bom momento para falar ...?" "





Escolha um estilo


Ajuste o estilo da sua entrega para se adequar ao seu público. Algumas pessoas querem um briefing formal de "apenas os fatos". Outros gostam de um bate-papo longo e abrangente antes de chegar aos negócios. Qual é o seu nível de habilidade e experiência nessa área? São especialistas? Os novatos? Eles precisam de manutenção à mão ou apenas um rápido tl; dr? Se em dúvida, pergunte.

Lembre -se, no entanto, de que você é metade da transação de comunicação. Se alguém disser que precisa de um parágrafo descrevendo algo e você não pode ver nenhuma maneira de fazê -lo em menos de várias páginas, diga isso. Lembre -se, esse tipo de feedback também é uma forma de comunicação.





Faça parecer bom


Suas idéias são importantes. Eles merecem um veículo bonito para transmiti-los ao seu público.

Muitos desenvolvedores (e seus gerentes) concentram -se apenas no conteúdo ao produzir documentos escritos. Achamos que isso é um erro. Qualquer chef (ou observador da rede de alimentos) dirá que você pode escravar na cozinha por horas apenas para arruinar seus esforços com uma apresentação ruim.

Hoje, não há desculpa para produzir documentos impressos de aparência ruim. O software moderno pode produzir uma saída impressionante, independentemente de você estar escrevendo usando o Markdown ou usando um processador de texto. Você precisa aprender apenas alguns comandos básicos. Se você estiver usando um processador de texto, use suas folhas de estilo para consistência. (Sua empresa já pode ter folhas de estilo definidas que você pode usar.) Aprenda a definir cabeçalhos e rodapés da página. Veja os documentos de amostra incluídos no seu pacote para obter idéias sobre estilo e layout. Verifique a ortografia, primeiro automaticamente e depois manualmente. Depois de AWL, estão soletrando miss bifes para que o verificador possa dar um nó.





Envolva seu público


Muitas vezes descobrimos que os documentos que produzimos acabam sendo menos importantes do que o processo que vamos
para produzi -los. Se possível, envolva seus leitores com rascunhos iniciais do seu documento. Obtenha o feedback deles e escolha o cérebro. Você criará um bom relacionamento de trabalho e provavelmente produzirá um documento melhor no processo.





Seja um ouvinte


Há uma técnica que você deve usar se quiser que as pessoas o ouçam: ouça -as. Mesmo que essa seja uma situação em que você tenha todas as informações, mesmo que seja uma reunião formal com você na frente de 20 ternos - se você não os ouve, eles não o ouvirão.

Incentive as pessoas a conversarem fazendo perguntas ou peça que reafirmem a discussão em suas próprias palavras. Transforme a reunião em uma caixa de diálogo e você fará seu ponto de maneira mais eficaz. Quem sabe, você pode até aprender algo.





Volte para as pessoas


Se você fizer uma pergunta a alguém, sente que eles são indelicados se eles não responderem. Mas com que frequência você deixa de voltar para as pessoas quando elas enviam um e -mail ou um memorando pedindo informações ou solicitando alguma ação? Na pressa da vida cotidiana, é fácil esquecer. Sempre responda a e -mails e correios de voz, mesmo que a resposta seja simplesmente "voltarei a você mais tarde".

Dica 12 É o que você diz e a maneira como você diz



A menos que você trabalhe no vácuo, você precisa se comunicar. Quanto mais eficaz essa comunicação, mais influente você se torna.





Documentação


Por fim, há a questão de se comunicar por meio de documentação. Normalmente, os desenvolvedores não pensam muito na documentação. Na melhor das hipóteses, é uma necessidade infeliz; Na pior das hipóteses, é tratado como uma tarefa de baixa prioridade, na esperança de que a administração o esqueça no final do projeto.

Os programadores pragmáticos adotam a documentação como parte integrante do processo geral de desenvolvimento. A documentação de escrever pode ser facilitada, sem duplicar o esforço ou perder tempo e manter a documentação em questão - no próprio código. De fato, queremos aplicar todos os nossos princípios pragmáticos à documentação e ao código.

Dica 13 Construa documentação, não o prenda



É fácil produzir documentação de boa aparência a partir dos comentários no código-fonte, e recomendamos adicionar comentários a módulos e funções exportadas para dar a outros desenvolvedores uma vantagem quando eles o usam.

No entanto, isso não significa que concordamos com as pessoas que dizem que todas as funções, estrutura de dados, declaração de tipo, etc., precisam de seu próprio comentário. Esse tipo de redação de comentários mecânicos realmente torna mais difícil manter o código: agora há duas coisas a serem atualizadas quando você faz uma alteração. Portanto, restrinja seu não-api comentando a discutir por que algo é feito, seu objetivo e seu objetivo. O código já mostra como é feito, então comentar sobre isso é redundante - e é uma violação do princípio seco.

Comentar o código-fonte oferece a oportunidade perfeita para documentar aqueles bits ilusórios de um projeto que não podem ser documentados em nenhum outro lugar: engenharia de compensações, por que as decisões foram tomadas, que outras alternativas foram descartadas e assim por diante.





Resumo


Saiba o que você quer dizer.

Conheça seu público.

Escolha seu momento.

Escolha um estilo.

Faça parecer bom.

Envolva seu público.

Seja um ouvinte.

Volte para as pessoas.

Mantenha o código e a documentação juntos.





Seções relacionadas incluem


Tópico 15, estimativa

Tópico 18, edição de energia

Tópico 45, o poço de requisitos

Tópico 49, equipes pragmáticas




Comunicação online

Tudo o que dissemos sobre a comunicação por escrito se aplica igualmente a email, postagens de mídia social, blogs e assim por diante. O email em particular evoluiu até o ponto em que é um dos pilares das comunicações corporativas; É usado para discutir contratos, liquidar disputas e como evidência no tribunal. Mas, por algum motivo, as pessoas que nunca enviariam um documento de papel surrado ficam felizes em arremessar e-mails incoerentes de aparência desagradável em todo o mundo.

Nossas dicas são simples:

Revise antes de acertar o envio.



Verifique sua ortografia e procure quaisquer contratempos acidentais de correção automática.



Mantenha o formato simples e claro.



Continue citando no mínimo. Ninguém gosta de receber de volta seu próprio e-mail de 100 linhas com "eu concordo".



Se você está citando o e -mail de outras pessoas, atribua -o e cite -o embutido (e não como um anexo). Mesmo ao citar em plataformas de mídia social.



Não chama ou age como um troll, a menos que você queira voltar e
assombrá -lo mais tarde. Se você não disser isso no rosto de alguém, não diga online.



Verifique sua lista de destinatários antes de enviar. Tornou -se um clichê criticar o chefe por causa do email departamental sem perceber que o chefe está na lista do CC. Melhor ainda, não critique o chefe por e -mail.





Como inúmeras grandes corporações e políticos descobriram, o email e as postagens de mídia social são para sempre. Tente dar a mesma atenção e cuidado ao e -mail que faria com qualquer memorando ou relatório por escrito.





Desafios


Existem vários bons livros que contêm seções sobre comunicações dentro de equipes, incluindo o mítico-mês: ensaios sobre engenharia de software [BRO96] e Peopleware: Projetos e equipes produtivas [DL13]. Faça questão de tentar ler isso nos próximos 18 meses. Além disso, os cérebros de dinossauros: lidando com todas as pessoas impossíveis do trabalho [BR89] discute a bagagem emocional que todos trazemos para o ambiente de trabalho.



Na próxima vez que você precisar fazer uma apresentação ou escrever um memorando defendendo alguma posição, tente trabalhar com os conselhos nesta seção antes de iniciar. Identifique explicitamente o público e o que você precisa se comunicar. Se apropriado, converse com seu público depois e veja a precisão da sua avaliação de suas necessidades.





Notas de rodapé


[3]

http://wiki.c2.com/?changeyourororganization



[4]

Veja, por exemplo, uma boa metanálise no desempenho da confiança e da equipe: uma meta-análise de efeitos principais, moderadores e covariáveis, http://dx.doi.org/10.1037/APL0000110



[5]

Veja a segurança da polícia e do bairro [WH82]



[6]

Veja depressão contagiosa: existência, especificidade aos sintomas deprimidos e o papel da busca por garantia [JOI94]



[7]

Enquanto faz isso, você pode ser consolado pela linha atribuída ao almirante retrovisor Dr. Grace Hopper: "É mais fácil perguntar perdão do que obter permissão".



[8]

Isso deveria ser uma piada!



[9]

Um ativo vencido é algo cujo valor diminui com o tempo. Os exemplos incluem um armazém cheio de bananas e um ingresso para um jogo de bola.



[10]

Podemos ser tendenciosos, mas há uma boa seleção disponível em https://pragprog.com.



[11]

Nunca ouviu falar de nenhum desses idiomas? Lembre -se de que o conhecimento é um ativo expirador, assim como a tecnologia popular. A lista de idiomas novos e experimentais quentes foi muito diferente para a primeira edição e provavelmente é diferente novamente quando você ler isso. Mais uma razão para continuar aprendendo.



[12]

A palavra irritação vem do antigo enui francês, que também significa "para aborrecer".





Copyright © 2020 Pearson Education, Inc.





Capítulo 2



Uma abordagem pragmática




Existem certas dicas e truques que se aplicam em todos os níveis de desenvolvimento de software, processos praticamente universais e idéias quase axiomáticas. No entanto, essas abordagens raramente são documentadas como tal; Você os encontrará principalmente escritos como frases estranhas em discussões sobre design, gerenciamento de projetos ou codificação. Mas, para sua conveniência, reuniremos essas idéias e processos aqui.

O primeiro e talvez o tópico mais importante chega ao coração do desenvolvimento de software: Tópico 8, a essência do bom design. Tudo se segue disso.

As próximas duas seções, o tópico 9, seco - os males de duplicação e tópico 10, ortogonalidade, estão intimamente relacionados. Os primeiros avisam que você não duplica o conhecimento em seus sistemas, o segundo a não dividir nenhum conhecimento em vários componentes do sistema.

À medida que o ritmo da mudança aumenta, torna -se cada vez mais difícil manter nossos aplicativos relevantes. No tópico 11, reversibilidade, examinaremos algumas técnicas que ajudam a isolar seus projetos do ambiente em mudança.

As próximas duas seções também estão relacionadas. No tópico 12, Bullets Tracer, falamos sobre um estilo de desenvolvimento que permite reunir requisitos, testar projetos e implementar código ao mesmo tempo. É a única maneira de acompanhar o ritmo da vida moderna.

Tópico 13, protótipos e notas post-it mostra como usar prototipagem para testar arquiteturas, algoritmos, interfaces e idéias. No mundo moderno, é fundamental testar idéias e obter feedback antes de se comprometer com elas de todo o coração.

À medida que a ciência da computação amadurece lentamente, os designers estão produzindo idiomas cada vez mais de nível superior. Embora o compilador que aceite "Make It So" ainda não tenha sido inventado, no tópico 14, idiomas de domínio, apresentamos sugestões mais modestas que você pode implementar para si mesmo.

Finalmente, todos trabalhamos em um mundo de
tempo e recursos limitados. Você pode sobreviver melhor a essas escassezes (e manter seus chefes ou clientes mais felizes) se você for bom em descobrir quanto tempo as coisas levarão, que cobrimos no tópico 15, estimando.

Lembre -se desses princípios fundamentais durante o desenvolvimento e você escreverá o código melhor, mais rápido e mais forte. Você pode até fazer com que pareça fácil.





Tópico 8

A essência do bom design




O mundo está cheio de gurus e especialistas, todos ansiosos para transmitir sua sabedoria suada quando se trata de como projetar software. Existem acrônimos, listas (que parecem favorecer cinco entradas), padrões, diagramas, vídeos, palestras e (a Internet sendo a Internet) provavelmente uma série legal sobre a lei de Demeter explicada usando dança interpretativa.

E nós, seus autores gentis, também somos culpados disso. Mas gostaríamos de fazer as pazes explicando algo que só se tornou aparente para nós bastante recentemente. Primeiro, a declaração geral:

Dica 14 O bom design é mais fácil de mudar do que o design ruim



Uma coisa é bem projetada se se adaptar às pessoas que a usam. Para o código, isso significa que ele deve se adaptar mudando. Portanto, acreditamos no princípio do ETC: mais fácil de mudar. Etc. É isso.

Até onde sabemos, todo princípio de design é um caso especial de etc.

Por que a dissociação está bem? Porque, isolando as preocupações, facilitamos cada uma delas. Etc.

Por que o princípio de responsabilidade única é útil? Porque uma mudança nos requisitos é refletida por uma alteração em apenas um módulo. Etc.

Por que nomear é importante? Porque os bons nomes facilitam a leitura do código e você precisa lê -lo para alterá -lo. Etc!





Etc é um valor, não uma regra


Os valores são coisas que ajudam você a tomar decisões: devo fazer isso ou aquilo? Quando se trata de pensar em software, etc, é um guia, ajudando você a escolher entre os caminhos. Assim como todos os seus outros valores, ele deve estar flutuando logo atrás do seu pensamento consciente, cutucando -o sutilmente na direção certa.

Mas como você faz isso acontecer? Nossa experiência é que requer algum reforço consciente inicial. Você pode precisar passar uma semana ou mais deliberadamente se perguntando: "A coisa que eu acabei de tornar o sistema geral mais fácil ou mais difícil de mudar?" Faça isso quando salvar um arquivo. Faça isso quando escrever um teste. Faça isso quando corrigir um bug.

Há uma premissa implícita em etc. Ele pressupõe que uma pessoa possa dizer qual de muitos caminhos será mais fácil de mudar no futuro. Na maioria das vezes, o bom senso estará correto e você poderá adivinhar.

Às vezes, porém, você não tem idéia. Isso está ok. Nesses casos, pensamos que você pode fazer duas coisas.

Primeiro, dado que você não tem certeza de que alteração de formulário levará, sempre poderá recorrer ao caminho final "fácil de alterar": tente fazer o que você escreve substituível. Dessa forma, o que quer que aconteça no futuro, esse pedaço de código não será um obstáculo. Parece extremo, mas na verdade é o que você deveria fazer o tempo todo. É realmente apenas pensar em manter o código dissociado e coeso.

Segundo, trate isso como uma maneira de desenvolver instintos. Observe a situação em seu livro do Dia da Engenharia: as opções que você tem e algumas suposições sobre mudanças. Deixe uma tag na fonte. Mais tarde, quando esse código tiver que mudar, você poderá olhar para trás e dar um feedback. Pode ajudar na próxima vez que você chegar a um garfo semelhante na estrada.

O restante das seções deste capítulo tem idéias específicas sobre design, mas todas são motivadas por esse princípio.





Seções relacionadas incluem


Tópico 9, seco - os males de duplicação

Tópico 10, Ortogonalidade

Tópico 11, reversibilidade

Tópico 14, idiomas de domínio

Tópico 28, dissociação

Tópico 30, transformando a programação

Tópico 31, Imposto sobre Herança





Desafios


Pense em um princípio de design que você usa regularmente. Pretende-se facilitar a mudança das coisas?



Pense também em idiomas e paradigmas de programação (OO, FP, Reativo e assim por diante). Algum tem grandes positivos ou grandes negativos quando se trata de ajudá -lo a escrever código etc? Algum tem os dois?

Ao codificar, o que você pode fazer para eliminar os negativos e acentuar os positivos? [13]





Muitos editores têm suporte (interno ou através de extensões) para executar comandos ao salvar um arquivo. Faça com que seu editor apareça um etc? Mensagem toda vez que você salva [14] e usa -a como uma sugestão para pensar no código que você acabou de escrever. É fácil mudar?





Tópico 9

Seco - os males de duplicação




Dando a um computador duas peças contraditórias de conhecimento foi o caminho preferido do capitão James T. Kirk
de desativar uma inteligência artificial saqueadora. Infelizmente, o mesmo princípio pode ser eficaz para reduzir seu código.

Como programadores, coletamos, organizamos, mantemos e aproveitamos o conhecimento. Documentamos conhecimento sobre especificações, fazemos com que ele ganhe vida no código de execução e o usamos para fornecer as verificações necessárias durante o teste.

Infelizmente, o conhecimento não é estável. Muda - geralmente rapidamente. Sua compreensão de um requisito pode mudar após uma reunião com o cliente. O governo muda um regulamento e alguma lógica de negócios fica desatualizada. Os testes podem mostrar que o algoritmo escolhido não funcionará. Toda essa instabilidade significa que gastamos grande parte do nosso tempo no modo de manutenção, reorganizando e reexpressando o conhecimento em nossos sistemas.

A maioria das pessoas assume que a manutenção começa quando um aplicativo é liberado, essa manutenção significa consertar bugs e aprimorar os recursos. Achamos que essas pessoas estão erradas. Os programadores estão constantemente no modo de manutenção. Nossa compreensão muda dia a dia. Novos requisitos chegam e os requisitos existentes evoluem à medida que estamos de cabeça para baixo no projeto. Talvez o ambiente mude. Seja qual for o motivo, a manutenção não é uma atividade discreta, mas uma parte rotineira de todo o processo de desenvolvimento.

Quando realizamos manutenção, precisamos encontrar e alterar as representações das coisas - aquelas cápsulas de conhecimento incorporadas no aplicativo. O problema é que é fácil duplicar o conhecimento nas especificações, processos e programas que desenvolvemos e, quando o fazemos, convidamos um pesadelo de manutenção - um que começa bem antes do envio do aplicativo.

Achamos que a única maneira de desenvolver software de maneira confiável e facilitar nossos desenvolvimentos é entender e manter, é seguir o que chamamos de princípio seco:

Todo conhecimento deve ter uma representação única, inequívoca e autorizada dentro de um sistema.

Por que chamamos de seco?

Dica 15 seca - não se repita



A alternativa é ter a mesma coisa expressa em dois ou mais lugares. Se você mudar um, deve se lembrar de mudar os outros ou, como os computadores alienígenas, seu programa será trazido de joelhos por uma contradição. Não se trata de se lembrar: é uma questão de quando você esquecerá.

Você encontrará o princípio seco aparecendo várias vezes ao longo deste livro, geralmente em contextos que não têm nada a ver com a codificação. Achamos que é uma das ferramentas mais importantes na caixa de ferramentas do programador pragmático.

Nesta seção, descreveremos os problemas de duplicação e sugerimos estratégias gerais para lidar com ela.





Seco é mais do que código


Vamos tirar algo do caminho antecipadamente. Na primeira edição deste livro, fizemos um péssimo trabalho ao explicar exatamente o que queremos dizer por não se repetir. Muitas pessoas o levaram para se referir apenas ao código: eles pensaram que seco significa "não copie e coloque linhas de fonte".

Isso faz parte do seco, mas é uma parte minúscula e bastante trivial.

Dry é sobre a duplicação do conhecimento, de intenção. Trata -se de expressar a mesma coisa em dois lugares diferentes, possivelmente de duas maneiras totalmente diferentes.

Aqui está o teste de ácido: quando uma única faceta do código precisa mudar, você se vê fazendo essa alteração em vários lugares e em vários formatos diferentes? Você precisa alterar o código e a documentação, ou um esquema de banco de dados e uma estrutura que o segura, ou…? Nesse caso, seu código não está seco.

Então, vejamos alguns exemplos típicos de duplicação.





Duplicação no código


Pode ser trivial, mas a duplicação de código é oh, tão comum. Aqui está um exemplo:

DEF Print_balance (conta)

Printf "Débitos: %10.2f \ n", conta.debits

Printf "Créditos: %10.2f \ n", conta.credits

Se conta.fees <0

Printf "Taxas: %10.2f- \ n", -Account.Fees

Outra pessoa

Printf "Taxas: %10.2f \ n", conta.fees

Fim

Printf "———- \ n"

Se conta.alance <0

Printf "Balance: %10.2f- \ n", -Account.Balance

Outra pessoa

Printf "Balance: %10.2f \ n", conta.alance

Fim

Fim



Por enquanto, ignore a implicação de que estamos cometendo o erro de novato de armazenar moedas em carros alegóricos. Em vez disso, veja se você pode identificar duplicações neste código. (Podemos ver pelo menos três coisas, mas você pode ver mais.)

O que você encontrou? Aqui está a nossa lista.

Primeiro, há claramente uma duplicação de cópia e pasta para lidar com os números negativos. Podemos consertar isso adicionando outra função:

Def format_amount (valor)

Resultado =
sprintf ("%10.2f", value.abs)

Se valor <0

Resultado + "-"

Outra pessoa

Resultado + ""

Fim

Fim

​

DEF Print_balance (conta)

Printf "Débitos: %10.2f \ n", conta.debits

Printf "Créditos: %10.2f \ n", conta.credits

Printf "Taxas: %s \ n", format_amount (account.fees)

Printf "———- \ n"

Printf "Balance: %s \ n", format_amount (conta.balance)

Fim



Outra duplicação é a repetição da largura do campo em todas as chamadas PrintF. Poderíamos consertar isso introduzindo uma constante e passando para cada chamada, mas por que não usar a função existente?

Def format_amount (valor)

Resultado = sprintf ("%10.2f", value.abs)

Se valor <0

Resultado + "-"

Outra pessoa

Resultado + ""

Fim

Fim

​

DEF Print_balance (conta)

Printf "Débitos: %s \ n", format_amount (conta.debits)

Printf "Credits: %s \ n", format_amount (account.credits)

Printf "Taxas: %s \ n", format_amount (account.fees)

Printf "———- \ n"

Printf "Balance: %s \ n", format_amount (conta.balance)

Fim



Mais alguma coisa? Bem, e se o cliente pedir um espaço extra entre os rótulos e os números? Teríamos que mudar cinco linhas. Vamos remover essa duplicação:

Def format_amount (valor)

Resultado = sprintf ("%10.2f", value.abs)

Se valor <0

Resultado + "-"

Outra pessoa

Resultado + ""

Fim

Fim

​

DEF Print_line (etiqueta, valor)

Printf "%-9s%s \ n", etiqueta, valor

Fim

​

DEF Report_line (etiqueta, quantidade)

Print_line (etiqueta + ":", format_amount (quantidade))

Fim

​

DEF Print_balance (conta)

Relatório_line ("Débitos", Account.debits)

Relatório_line ("Credits", Account.credits)

Relatório_line ("Taxas", Account.Fees)

Print_line ("", "———-")

Relatório_line ("Balance", Account.Balance)

Fim



Se precisarmos alterar a formatação de quantidades, alteramos o format_amount. Se queremos alterar o formato do rótulo, alteramos o relatório_line.

Ainda há uma violação seca implícita: o número de hífens na linha do separador está relacionado à largura do campo da quantidade. Mas não é uma correspondência exata: atualmente é um personagem mais curto; portanto, qualquer signo de menos que se estenda além da coluna. Essa é a intenção do cliente e é uma intenção diferente para a formatação real de quantidades.





Nem toda a duplicação de código é duplicação do conhecimento


Como parte do seu aplicativo de pedidos de vinho on -line, você está capturando e validando a idade do seu usuário, juntamente com a quantidade que eles estão pedindo. De acordo com o proprietário do site, eles devem ser números e maiores que zero. Então você codifica as validações:

Def validate_age (valor):

Validate_type (valor ,: número inteiro)

Validate_min_integer (valor, 0)

​

Def validate_quantity (valor):

Validate_type (valor ,: número inteiro)

Validate_min_integer (valor, 0)



Durante a revisão do código, o Know-It-All residente salta esse código, alegando que é uma violação seca: ambos os corpos da função são os mesmos.

Eles estão errados. O código é o mesmo, mas o conhecimento que eles representam é diferente. As duas funções validam duas coisas separadas que têm as mesmas regras. Isso é uma coincidência, não uma duplicação.





Duplicação em documentação


De alguma forma, nasceu o mito de que você deveria comentar todas as suas funções. Aqueles que acreditam nessa loucura produzem algo como este:

# Calcule as taxas para esta conta.

#

# * Cada cheque retornado custa $ 20

# * Se a conta estiver em cheque especial por mais de 3 dias,

# Cobrar US $ 10 por cada dia

# * Se o saldo médio da conta for maior que US $ 2.000

# Reduza as taxas em 50%

​

Def Taxas (A)

F = 0

Se a.returned_check_count> 0

F += 20 * A.Returb_Check_Count

Fim

Se a.overdraft_days> 3

F += 10*a.overdraft_days

Fim

Se A.average_balance> 2_000

F /= 2

Fim

F

Fim



A intenção desta função é dada duas vezes: uma vez no comentário e novamente no código. O cliente altera uma taxa e temos que atualizar os dois. Dado o tempo, podemos garantir o comentário e o código ficará fora de passo.

Pergunte a si mesmo o que o comentário adiciona ao código. Do nosso ponto de vista, ele simplesmente compensa alguns maus nomes e layout. Que tal isso apenas:

Def calcular_account_fees (conta)

Taxas = 20 * conta.Returned_Check_Count

Taxas += 10 * Account.Overdraft_Days If Account.Overdraft_Days> 3

Taxas /= 2 se conta.average_balance> 2_000

Taxas

Fim



O
O nome diz o que faz e, se alguém precisar de detalhes, será apresentado na fonte. Isso é seco!





Violações secas em dados


Nossas estruturas de dados representam conhecimento e podem entrar em conflito com o princípio seco. Vejamos uma aula representando uma linha:

Linha de classe {

Início de ponto;

Final de ponto;

Comprimento duplo;

};



À primeira vista, essa classe pode parecer razoável. Uma linha tem claramente um início e fim, e sempre terá um comprimento (mesmo que seja zero). Mas temos duplicação. O comprimento é definido pelos pontos de partida e final: altere um dos pontos e o comprimento muda. É melhor fazer do comprimento um campo calculado:

Linha de classe {

Início de ponto;

Final de ponto;

Comprimento duplo () {return start.distanceto (end); }

};



Posteriormente, no processo de desenvolvimento, você pode optar por violar o princípio seco por razões de desempenho. Freqüentemente, isso ocorre quando você precisa armazenar em cache dados para evitar repetir operações caras. O truque é localizar o impacto. A violação não está exposta ao mundo exterior: apenas os métodos da classe precisam se preocupar em manter as coisas retas:

Linha de classe {

Comprimento duplo privado;

Início de ponto privado;

Final de ponto privado;

​

Linha pública (início do ponto, final de ponto) {

Este .start = start;

Este .nd = end;

CalculatElngth ();

}

​

// público

Void setStart (ponto p) {this .start = p; calculatElngth (); }

Void setend (ponto p) {this .nd = p; calculatElngth (); }

​

Ponto getStart () {return start; }

Point getEnd () {return end; }

​

Duplo getLength () {retornar comprimento; }

​

Private vazio calculatElngth () {

Este .Length = start.distanceto (end);

}

};



Este exemplo também ilustra uma questão importante: sempre que um módulo expõe uma estrutura de dados, você está acoplando todo o código que usa essa estrutura à implementação desse módulo. Sempre que possível, sempre use funções de acessador para ler e escrever os atributos dos objetos. Isso facilitará a adição de funcionalidade no futuro.

Esse uso de funções de acessador se vincula ao princípio de acesso uniforme de Meyer, descrito na construção de software orientada a objetos [Mey97], que afirma que afirma que

Todos os serviços oferecidos por um módulo devem estar disponíveis através de uma notação uniforme, que não traia se eles são implementados por meio de armazenamento ou por computação.





Duplicação representacional


Seu código interfina o mundo exterior: outras bibliotecas via APIs, outros serviços por meio de chamadas remotas, dados em fontes externas e assim por diante. E praticamente cada vez que você faz, você apresenta algum tipo de violação seca: seu código precisa ter conhecimento que também esteja presente na coisa externa. Ele precisa conhecer a API, ou o esquema, ou o significado dos códigos de erro, ou o que seja. A duplicação aqui é que duas coisas (seu código e a entidade externa) precisam ter conhecimento da representação de sua interface. Mude em uma extremidade e a outra extremidade quebra.

Essa duplicação é inevitável, mas pode ser atenuada. Aqui estão algumas estratégias.





Duplicação em APIs internas


Para APIs internas, procure ferramentas que permitam especificar a API em algum tipo de formato neutro. Essas ferramentas normalmente geram documentação, Mock APIs, testes funcionais e clientes da API, este último em vários idiomas diferentes. Idealmente, a ferramenta armazenará todas as suas APIs em um repositório central, permitindo que elas sejam compartilhadas entre as equipes.





Duplicação em APIs externas


Cada vez mais, você descobrirá que as APIs públicas estão documentadas formalmente usando algo como o OpenAPI. [15] Isso permite importar a especificação da API para suas ferramentas locais de API e integrar -se de maneira mais confiável ao serviço.

Se você não encontrar essa especificação, considere criar um e publicá -lo. Outros não apenas acharão útil; Você pode até obter ajuda para mantê -lo.





Duplicação com fontes de dados


Muitas fontes de dados permitem que você introspecione seu esquema de dados. Isso pode ser usado para remover grande parte da duplicação entre eles e seu código. Em vez de criar manualmente o código para conter esses dados armazenados, você pode gerar os contêineres diretamente a partir do esquema. Muitas estruturas de persistência farão esse levantamento pesado para você.

Há outra opção, e uma que frequentemente preferimos. Em vez de escrever código que representa dados externos em uma estrutura fixa (uma instância de uma estrutura ou classe, por exemplo), basta prender em uma estrutura de dados de chave/valor (seu idioma pode chamá -lo de mapa,
hash, dicionário ou mesmo objeto).

Por si só, isso é arriscado: você perde muita segurança de saber exatamente quais dados está trabalhando. Por isso, recomendamos adicionar uma segunda camada a esta solução: um simples conjunto de validação orientado por mesa que verifica se o mapa que você criou contém pelo menos os dados necessários, no formato que você precisa. Sua ferramenta de documentação da API pode ser capaz de gerar isso.





Duplicação interdeveloper


Talvez o tipo mais difícil de duplicação para detectar e manipular ocorra entre diferentes desenvolvedores em um projeto. Conjuntos inteiros de funcionalidade podem ser inadvertidamente duplicados, e essa duplicação pode não ser detectada por anos, levando a problemas de manutenção. Ouvimos em primeira mão um estado dos EUA cujos sistemas governamentais de computadores foram pesquisados para a conformidade com Y2K. A auditoria apresentou mais de 10.000 programas que cada um continha uma versão diferente do código de validação do número de seguridade social.

Em um nível alto, lide com o problema construindo uma equipe forte e unida com boas comunicações.

No entanto, no nível do módulo, o problema é mais insidioso. A funcionalidade ou dados geralmente necessários que não se enquadram em uma área de responsabilidade óbvia pode ser implementada várias vezes.

Sentimos que a melhor maneira de lidar com isso é incentivar uma comunicação ativa e frequente entre os desenvolvedores.

Talvez faça uma reunião diária de stand -up. Configure os fóruns (como canais Slack) para discutir problemas comuns. Isso fornece uma maneira não invasiva de se comunicar - mesmo em vários sites - enquanto reteve um histórico permanente de tudo o que dizia.

Nomeie um membro da equipe como bibliotecário do projeto, cujo trabalho é facilitar a troca de conhecimento. Tenha um local central na árvore de origem, onde as rotinas e scripts utilizados podem ser depositados. E faça questão de ler o código e a documentação de outras pessoas, informalmente ou durante as revisões de código. Você não está bisbilhotando - você está aprendendo com eles. E lembre -se, o acesso é recíproco - também não se tornará torcido sobre outras pessoas que se destacam (pata?) Através do seu código.

Dica 16 facilite a reutilização



O que você está tentando fazer é promover um ambiente em que é mais fácil encontrar e reutilizar coisas existentes do que escrever você mesmo. Se não for fácil, as pessoas não farão isso. E se você não conseguir reutilizar, corre o risco de duplicar o conhecimento.





Seções relacionadas incluem


Tópico 8, a essência do bom design

Tópico 28, dissociação

Tópico 32, configuração

Tópico 38, Programação por coincidência

Tópico 40, refatoração





Tópico 10

Ortogonalidade




A ortogonalidade é um conceito crítico se você deseja produzir sistemas fáceis de projetar, construir, testar e estender. No entanto, o conceito de ortogonalidade raramente é ensinado diretamente. Muitas vezes, é uma característica implícita de vários outros métodos e técnicas que você aprende. Isso é um erro. Depois de aprender a aplicar diretamente o princípio da ortogonalidade, você notará uma melhoria imediata na qualidade dos sistemas que você produz.





O que é ortogonalidade?




"Ortogonalidade '' é um termo emprestado da geometria. Duas linhas são ortogonais se se encontrarem em ângulos retos, como os eixos em um gráfico. Em termos vetoriais, as duas linhas são independentes. Como o número 1 no diagrama se move ao norte, ele não muda o extremo leste ou oeste. O número 2 se move leste, mas não ao norte ou ao sul.

Na computação, o termo passou a significar um tipo de independência ou dissociação. Duas ou mais coisas são ortogonais se as alterações em um não afetam nenhum dos outros. Em um sistema bem projetado, o código do banco de dados será ortogonal para a interface do usuário: você pode alterar a interface sem afetar o banco de dados e trocar bancos de dados sem alterar a interface.

Antes de examinarmos os benefícios dos sistemas ortogonais, vamos primeiro olhar para um sistema que não é ortogonal.





Um sistema não ortogonal


Você está em um tour de helicóptero pelo Grand Canyon quando o piloto, que cometeu o erro óbvio de comer peixe para almoçar, de repente geme e desmaia. Felizmente, ele deixou você pairando 100 pés acima do solo.

Por sorte, você leu uma página da Wikipedia sobre helicópteros na noite anterior. Você sabe que os helicópteros têm quatro controles básicos. O cíclico é o bastão que você segura na mão direita. Mova -o e o helicóptero se move na direção correspondente. Sua mão esquerda segura a alavanca de afinação coletiva. Puxe isso e aumenta o tom em todas as lâminas, gerando elevação. No final da alavanca de arremesso está o acelerador. Finalmente você tem dois pés
Os pedais, que variam a quantidade de impulso do rotor de cauda e, portanto, ajudam a girar o helicóptero.

"Fácil!", Você pensa. "Abaixe suavemente a alavanca de arremesso coletiva e você descerá graciosamente ao chão, um herói". No entanto, quando você tenta, descobre que a vida não é tão simples. O nariz do helicóptero cai e você começa a ficar em espiral para a esquerda. De repente, você descobre que está pilotando um sistema em que toda entrada de controle tem efeitos secundários. Abaixe a alavanca à esquerda e você precisa adicionar um movimento para trás compensar ao bastão direito e empurre o pedal direito. Mas então cada uma dessas mudanças afeta todos os outros controles novamente. De repente, você está fazendo malabarismos com um sistema inacreditavelmente complexo, onde toda mudança afeta todas as outras entradas. Sua carga de trabalho é fenomenal: suas mãos e pés estão se movendo constantemente, tentando equilibrar todas as forças em interação.

Os controles de helicóptero não são decididamente ortogonais.





Benefícios da ortogonalidade


Como o exemplo de helicóptero ilustra, os sistemas não ortogonais são inerentemente mais complexos para mudar e controlar. Quando os componentes de qualquer sistema são altamente interdependentes, não existe uma correção local.

Dica 17 elimina os efeitos entre coisas não relacionadas



Queremos projetar componentes independentes: independentes e com um único objetivo bem definido (o que o YourDon e o Constantine chamam coesão no design estruturado: fundamentos de uma disciplina de programa de computador e design de sistemas [YC79]). Quando os componentes são isolados um do outro, você sabe que pode mudar um sem ter que se preocupar com o resto. Desde que você não altere as interfaces externas desse componente, poderá ter certeza de que não causará problemas que ondulam por todo o sistema.

Você obtém dois grandes benefícios se escrever sistemas ortogonais: aumento da produtividade e risco reduzido.





Ganhe produtividade


As mudanças estão localizadas, portanto, o tempo de desenvolvimento e o tempo de teste são reduzidos. É mais fácil escrever componentes relativamente pequenos e independentes do que um único bloco grande de código. Componentes simples podem ser projetados, codificados, testados e esquecidos - não há necessidade de continuar alterando o código existente à medida que você adiciona novo código.



Uma abordagem ortogonal também promove a reutilização. Se os componentes tiverem responsabilidades específicas e bem definidas, eles podem ser combinados com novos componentes de maneiras que não foram previstas por seus implementadores originais. Quanto mais pouco acoplavam seus sistemas, mais fáceis eles são reconfigurar e reengenheiros.



Há um ganho bastante sutil em produtividade quando você combina componentes ortogonais. Suponha que um componente faça coisas distintas e outro faça as coisas. Se eles são ortogonais e você os combina, o resultado faz as coisas. No entanto, se os dois componentes não forem ortogonais, haverá sobreposição e o resultado fará menos. Você obtém mais funcionalidade por unidade de esforço, combinando componentes ortogonais.





Reduzir o risco


Uma abordagem ortogonal reduz os riscos inerentes a qualquer desenvolvimento.

Seções doentes do código estão isoladas. Se um módulo estiver doente, é menos provável que espalhe os sintomas pelo restante do sistema. Também é mais fácil cortá -lo e transplantar em algo novo e saudável.



O sistema resultante é menos frágil. Faça pequenas alterações e correções em uma área específica, e quaisquer problemas que você gerar serão restritos a essa área.



Um sistema ortogonal provavelmente será melhor testado, porque será mais fácil projetar e executar testes em seus componentes.



Você não estará tão bem ligado a um fornecedor, produto ou plataforma específico, porque as interfaces desses componentes de terceiros serão isoladas em partes menores do desenvolvimento geral.





Vejamos algumas das maneiras pelas quais você pode aplicar o princípio da ortogonalidade ao seu trabalho.





Projeto


A maioria dos desenvolvedores está familiarizada com a necessidade de projetar sistemas ortogonais, embora possam usar palavras como modular, baseado em componentes e em camadas para descrever o processo. Os sistemas devem ser compostos por um conjunto de módulos de cooperação, cada um dos quais implementa a funcionalidade independente dos outros. Às vezes, esses componentes são organizados em camadas, cada um fornecendo um nível de abstração. Essa abordagem em camadas é uma maneira poderosa de projetar sistemas ortogonais. Como cada camada usa apenas as abstrações fornecidas pelas camadas abaixo dela, você tem grande flexibilidade na alteração de implementações subjacentes sem afetar o código. As camadas também reduzem o risco de dependências descontroladas entre os módulos. Você costuma ver
camadas expressas em diagramas:



Existe um teste fácil para o design ortogonal. Depois de mapear seus componentes, pergunte -se: se eu alterar drasticamente os requisitos por trás de uma função específica, quantos módulos são afetados? Em um sistema ortogonal, a resposta deve ser "uma".

Vamos considerar um sistema complexo para monitorar e controlar uma planta de aquecimento. O requisito original pedia uma interface gráfica do usuário, mas os requisitos foram alterados para adicionar uma interface móvel que permite que os engenheiros monitorem os valores das chaves. Em um sistema ortogonalmente projetado, você precisaria alterar apenas os módulos associados à interface do usuário para lidar com isso: a lógica subjacente de controlar a planta permaneceria inalterada. De fato, se você estruturar seu sistema com cuidado, poderá suportar ambas as interfaces com a mesma base de código subjacente.

Pergunte também a si mesmo como seu design é dissociado por mudanças no mundo real. Você está usando um número de telefone como identificador de cliente? O que acontece quando a companhia telefônica reatribui os códigos de área? Códigos postais, números de previdência social ou IDs do governo, endereços de email e domínios são todos identificadores externos sobre os quais você não tem controle e pode mudar a qualquer momento por qualquer motivo. Não confie nas propriedades das coisas que você não pode controlar.





Kits de ferramentas e bibliotecas


Cuidado em preservar a ortogonalidade do seu sistema ao introduzir kits de ferramentas e bibliotecas de terceiros. Escolha suas tecnologias com sabedoria.

Quando você traz um kit de ferramentas (ou mesmo uma biblioteca de outros membros da sua equipe), pergunte -se se ele impõe alterações ao seu código que não deve estar lá. Se um esquema de persistência de objeto for transparente, é ortogonal. Se exigir que você crie ou acesse objetos de uma maneira especial, não é. Manter esses detalhes isolados do seu código tem o benefício adicional de facilitar a alteração de fornecedores no futuro.

O sistema Enterprise Java Beans (EJB) é um exemplo interessante de ortogonalidade. Na maioria dos sistemas orientados a transações, o código do aplicativo deve delinear o início e o final de cada transação. Com o EJB, essas informações são expressas declarativamente como anotações, fora dos métodos que fazem o trabalho. O mesmo código de aplicativo pode ser executado em diferentes ambientes de transação EJB, sem alteração.

De certa forma, o EJB é um exemplo do padrão do decorador: adicionando funcionalidade às coisas sem alterá -las. Esse estilo de programação pode ser usado em quase todas as linguagens de programação e não exige necessariamente uma estrutura ou biblioteca. É preciso apenas um pouco de disciplina ao programar.





Codificação


Toda vez que você escreve o código, você corre o risco de reduzir a ortogonalidade do seu aplicativo. A menos que você monitore constantemente não apenas o que está fazendo, mas também o contexto maior do aplicativo, você pode duplicar sem querer a funcionalidade em algum outro módulo ou expressar o conhecimento existente duas vezes.

Existem várias técnicas que você pode usar para manter a ortogonalidade:

Mantenha seu código dissociado

Escreva código tímido - módulos que não revelam nada desnecessário a outros módulos e que não dependem das implementações de outros módulos. Experimente a lei do Demeter, que discutimos no tópico 28, desacoplando. Se você precisar alterar o estado de um objeto, faça com que o objeto faça isso por você. Dessa forma, seu código permanece isolado da implementação do outro código e aumenta as chances de você permanecer ortogonal.



Evite dados globais

Toda vez que seu código faz referência a dados globais, ele se vincula aos outros componentes que compartilham esses dados. Mesmo os globais que você pretende ler apenas pode levar a problemas (por exemplo, se você precisar de repente alterar seu código para ser multithread). Em geral, seu código é mais fácil de entender e manter se você passar explicitamente qualquer contexto necessário em seus módulos. Em aplicativos orientados a objetos, o contexto é frequentemente passado como parâmetros para os construtores dos objetos. Em outro código, você pode criar estruturas que contêm o contexto e transmitir referências a elas.



O padrão de singleton nos padrões de design: elementos do software reutilizável orientado a objetos [ghjv95] é uma maneira de garantir que exista apenas uma instância de um objeto de uma classe específica. Muitas pessoas usam esses objetos de singleton como uma espécie de variável global (particularmente em idiomas, como Java, que de outra forma
Não apoie o conceito de globais). Cuidado com singletons - eles também podem levar a uma ligação desnecessária.



Evite funções semelhantes

Muitas vezes, você encontra um conjunto de funções que parecem semelhantes - talvez elas compartilhem código comum no início e no fim, mas cada uma tem um algoritmo central diferente. O código duplicado é um sintoma de problemas estruturais. Dê uma olhada no padrão de estratégia nos padrões de design para uma melhor implementação.





Entre no hábito de ser constantemente crítico do seu código. Procure qualquer oportunidade de reorganizá -lo para melhorar sua estrutura e ortogonalidade. Esse processo é chamado de refatoração e é tão importante que dedicamos uma seção a ele (consulte o tópico 40, refatorando).





Teste


Um sistema ortogonalmente projetado e implementado é mais fácil de testar. Como as interações entre os componentes do sistema são formalizadas e limitadas, mais testes do sistema podem ser realizados no nível individual do módulo. Esta é uma boa notícia, porque o teste de nível (ou unidade) do módulo é consideravelmente mais fácil de especificar e executar do que o teste de integração. De fato, sugerimos que esses testes sejam realizados automaticamente como parte do processo de construção regular (consulte o tópico 41, teste para código).

Escrever testes de unidade é um teste interessante de ortogonalidade. O que é preciso para obter um teste de unidade para construir e executar? Você precisa importar uma grande porcentagem do restante do código do sistema? Nesse caso, você encontrou um módulo que não está bem dissociado do restante do sistema.

A correção de bugs também é um bom momento para avaliar a ortogonalidade do sistema como um todo. Quando você se deparar com um problema, avalie como a correção está localizada. Você altera apenas um módulo ou as alterações estão espalhadas por todo o sistema? Quando você faz uma mudança, isso conserta tudo ou faz outros problemas misteriosamente? Esta é uma boa oportunidade para trazer automação para suportar. Se você usar um sistema de controle de versão (e depois de ler o tópico 19, controle de versão), tag Bugs Correções quando você verificar o código de volta após o teste. Você pode executar relatórios mensais analisando tendências no número de arquivos de origem afetados por cada correção de bug.





Documentação


Talvez surpreendentemente, a ortogonalidade também se aplica à documentação. Os eixos são conteúdo e apresentação. Com documentação verdadeiramente ortogonal, você poderá alterar dramaticamente a aparência sem alterar o conteúdo. Os processadores de texto fornecem folhas de estilo e macros que ajudam. Pessoalmente, preferimos usar um sistema de marcação como Markdown: ao escrever, focamos apenas no conteúdo e deixamos a apresentação para qualquer ferramenta que usarmos para renderizá -la. [17]





Vivendo com ortogonalidade


A ortogonalidade está intimamente relacionada ao princípio seco. Com o seco, você deseja minimizar a duplicação dentro de um sistema, enquanto que com a ortogonalidade você reduz a interdependência entre os componentes do sistema. Pode ser uma palavra desajeitada, mas se você usar o princípio da ortogonalidade, combinado de perto com o princípio seco, descobrirá que os sistemas que você desenvolve são mais flexíveis, mais compreensíveis e mais fáceis de depurar, testar e manter.

Se você é levado a um projeto em que as pessoas estão desesperadamente lutando para fazer alterações e onde todas as mudanças parecem causar quatro outras coisas, lembre -se do pesadelo com o helicóptero. O projeto provavelmente não é ortogonalmente projetado e codificado. É hora de refatorar.

E, se você é um piloto de helicóptero, não coma o peixe ...





Seções relacionadas incluem


Tópico 3, entropia de software

Tópico 8, a essência do bom design

Tópico 11, reversibilidade

Tópico 28, dissociação

Tópico 31, Imposto sobre Herança

Tópico 33, quebrando o acoplamento temporal

Tópico 34, Estado compartilhado é um estado incorreto

Tópico 36, Blackboards





Desafios


Considere a diferença entre as ferramentas que possuem uma interface gráfica do usuário e utilitários de linha de comando pequenos, mas combináveis, usados nos avisos do shell. Qual conjunto é mais ortogonal e por quê? O que é mais fácil de usar exatamente para o fim para o qual se destinava? Qual conjunto é mais fácil de combinar com outras ferramentas para enfrentar novos desafios? Qual conjunto é mais fácil de aprender?



O C ++ suporta herança múltipla, e o Java permite que uma classe implemente várias interfaces. Ruby tem mixins. Que impacto o uso dessas instalações tem na ortogonalidade? Existe uma diferença de impacto entre o uso de herança múltipla e várias interfaces? Existe uma diferença entre usar a delegação e a herança?





Exercícios


Exercício 1
(Resposta possível)

Você é solicitado a ler um arquivo uma linha de cada vez. Para cada linha, você deve dividi -la em campos. Qual dos seguintes conjuntos de definições de pseudo -classe provavelmente será mais ortogonal?

Classe split1 {

Construtor (nome do arquivo) # abre o arquivo para leitura

Def readNextLine () # se move para a próxima linha

Def getfield (n) # retorna o enésimo campo na linha atual

}



ou

Classe split2 {

Construtor (linha) # divide uma linha

Def getfield (n) # retorna o enésimo campo na linha atual

}



Exercício 2 (possível resposta)

Quais são as diferenças de ortogonalidade entre idiomas orientados a objetos e funcionais? Essas diferenças são inerentes aos próprios idiomas, ou apenas da maneira como as pessoas as usam?





Tópico 11

Reversibilidade




Nada é mais perigoso do que uma ideia se for a única que você tem.



Emil-August Chartier (Alain), Propos Sur la Religion, 1938



Os engenheiros preferem soluções simples e singulares a problemas. Testes de matemática que permitem proclamar com grande confiança que são muito mais confortáveis do que ensaios calorosos e calorosos sobre as inúmeras causas da Revolução Francesa. A gerência tende a concordar com os engenheiros: respostas singulares e fáceis se encaixam bem nas planilhas e nos planos do projeto.

Se ao menos o mundo real cooperaria! Infelizmente, embora seja hoje, pode precisar ser amanhã e na próxima semana. Nada é para sempre - e se você confiar fortemente em algum fato, poderá quase garantir que isso mudará.

Sempre há mais de uma maneira de implementar algo, e geralmente há mais de um fornecedor disponível para fornecer um produto de terceiros. Se você entrar em um projeto prejudicado pela noção míope de que existe apenas uma maneira de fazê -lo, você pode ter uma surpresa desagradável. Muitas equipes de projeto abriram seus olhos à força à medida que o futuro se desenrola:

"Mas você disse que usaríamos o banco de dados XYZ! Estamos com 85% de codificação do projeto, não podemos mudar agora!" O programador protestou. "Desculpe, mas nossa empresa decidiu padronizar o PDQ do banco de dados - para todos os projetos. Está fora das minhas mãos. Teremos que recodificar. Todos vocês estarão trabalhando nos fins de semana até mais aviso".



As mudanças não precisam ser tão draconianas ou mesmo imediatas. Mas com o passar do tempo, e seu projeto avança, você pode ficar preso em uma posição insustentável. A cada decisão crítica, a equipe do projeto se compromete a um alvo menor - uma versão mais estreita da realidade que tem menos opções.

Quando muitas decisões críticas foram tomadas, o alvo se torna tão pequeno que, se ele se mover, ou o vento mudar de direção, ou uma borboleta em Tóquio retira suas asas, você sente falta. [18] E você pode perder por uma quantidade enorme.

O problema é que as decisões críticas não são facilmente reversíveis.

Depois de decidir usar o banco de dados deste fornecedor, ou esse padrão arquitetônico, ou um determinado modelo de implantação, você está comprometido com um curso de ação que não pode ser desfeito, exceto com ótimas custas.





Reversibilidade


Muitos dos tópicos deste livro são voltados para produzir software flexível e adaptável. Ao manter suas recomendações - especialmente o princípio seco, a desacoplamento e o uso da configuração externa - não precisamos tomar tantas decisões críticas e irreversíveis. Isso é uma coisa boa, porque nem sempre tomamos as melhores decisões na primeira vez. Nós nos comprometemos com uma certa tecnologia apenas para descobrir que não podemos contratar pessoas suficientes com as habilidades necessárias. Nós travamos um determinado fornecedor de terceiros pouco antes de serem comprados pelo concorrente. Requisitos, usuários e hardware mudam mais rápido do que podemos desenvolver o software.

Suponha que você decida, no início do projeto, usar um banco de dados relacional do fornecedor A. muito mais tarde, durante o teste de desempenho, você descobre que o banco de dados é simplesmente muito lento, mas que o banco de dados do Document do fornecedor B seja mais rápido. Com a maioria dos projetos convencionais, você ficaria sem sorte. Na maioria das vezes, as chamadas para produtos de terceiros estão enredadas ao longo do código. Mas se você realmente abstraiu a idéia de um banco de dados - até o ponto em que ele simplesmente fornece persistência como serviço - então você tem a flexibilidade de trocar de cavalos no meio da corrente.

Da mesma forma, suponha que o projeto comece como um aplicativo baseado em navegador, mas, no final do jogo, o marketing decide que o que eles realmente querem é um aplicativo móvel. Quão difícil seria isso para você? Em um mundo ideal, não deve afetar muito você, pelo menos no lado do servidor. Você estaria retirando alguma renderização em HTML e substituindo -a por uma API.

O erro está em assumir
que qualquer decisão seja lançada em pedra - e não se prepare para as contingências que possam surgir. Em vez de esculpir decisões em pedra, pense nelas mais como escritas na areia na praia. Uma grande onda pode aparecer e acabar com eles a qualquer momento.

Dica 18 Não há decisões finais





Arquitetura flexível


Enquanto muitas pessoas tentam manter seu código flexível, você também precisa pensar em manter a flexibilidade nas áreas de arquitetura, implantação e integração de fornecedores.

Estamos escrevendo isso em 2019. Desde a virada do século, vimos as seguintes arquiteturas do lado do servidor "Melhores Práticas":

Grande pedaço de ferro

Federações de Big Iron

Clusters balanceados de carga de hardware de commodity

Máquinas virtuais baseadas em nuvem executando aplicativos

Máquinas virtuais baseadas em nuvem Serviços de execução

Versões de contêiner do acima

Aplicativos sem servidores suportados por nuvens

E, inevitavelmente, um aparente movimento de volta a grandes pedaços de ferro para algumas tarefas



Vá em frente e adicione os melhores e mais recentes modismos a esta lista e, em seguida, considere -a com admiração: é um milagre que qualquer coisa já tenha funcionado.

Como você pode planejar esse tipo de volatilidade arquitetônica? Você não pode.

O que você pode fazer é facilitar a mudança. Esconda as APIs de terceiros por trás de suas próprias camadas de abstração. Divida seu código em componentes: mesmo se você acabar implantando -os em um único servidor massivo, essa abordagem é muito mais fácil do que tomar um aplicativo monolítico e dividi -lo. (Temos as cicatrizes para provar isso.)

E, embora isso não seja particularmente uma questão de reversibilidade, um conselho final.

Dica 19 Opgo a seguir os modismos



Ninguém sabe o que o futuro pode conter, especialmente não nós! Portanto, ative seu código para o rock-n-roll: para "rock on '' quando puder, role com os socos quando precisar.





Seções relacionadas incluem


Tópico 8, a essência do bom design

Tópico 10, Ortogonalidade

Tópico 19, controle de versão

Tópico 28, dissociação

Tópico 45, o poço de requisitos

Tópico 51, kit iniciante pragmático





Desafios


Hora de um pouco de mecânica quântica com o gato de Schrödinger.

Suponha que você tenha um gato em uma caixa fechada, junto com uma partícula radioativa. A partícula tem exatamente 50% de chance de fissurar em dois. Se isso acontecer, o gato será morto. Caso contrário, o gato ficará bem. Então, o gato está morto ou vivo? De acordo com Schrödinger, a resposta correta é ambos (pelo menos enquanto a caixa permanece fechada). Toda vez que ocorre uma reação subnuclear que tem dois resultados possíveis, o universo é clonado. Em um, o evento ocorreu, no outro não. O gato está vivo em um universo, morto em outro. Somente quando você abre a caixa, você sabe em qual universo você está.

Não é de admirar que codificar para o futuro seja difícil.

Mas pense na evolução do código na mesma linha que uma caixa cheia dos gatos de Schrödinger: toda decisão resulta em uma versão diferente do futuro. Quantos futuros possíveis seu código pode suportar? Quais são mais prováveis? Quão difícil será apoiá -los quando chegar a hora?

Você se atreve a abrir a caixa?





Tópico 12

Balas traçer




Pronto, fogo, mira ...



Anon



Frequentemente falamos em atingir alvos quando desenvolvemos software. Na verdade, não estamos disparando nada no campo de tiro, mas ainda é uma metáfora útil e muito visual. Em particular, é interessante considerar como atingir um alvo em um mundo complexo e mudador.

A resposta, é claro, depende da natureza do dispositivo com o qual você mira. Com muitos, você só tem uma chance de mirar e depois ver se você bate no Bullseye ou não. Mas há uma maneira melhor.

Você conhece todos esses filmes, programas de TV e videogames onde as pessoas estão filmando metralhadoras? Nessas cenas, você costuma ver o caminho das balas como estrias brilhantes no ar. Essas riscas vêm de balas de traçador.

As balas traçer são carregadas em intervalos ao lado da munição regular. Quando eles são demitidos, seu fósforo acende e deixa uma trilha pirotecnica da arma para o que quer que atinjam. Se os traçadores estão atingindo o alvo, também são as balas regulares. Os soldados usam essas rodadas de marcador para refinar seu objetivo: é pragmático e em tempo real feedback sob condições reais.

Esse mesmo princípio se aplica a projetos, principalmente quando você está construindo algo que nunca foi construído antes. Utilizamos o termo desenvolvimento de balas de rastreamento para ilustrar visualmente a necessidade de feedback imediato em condições reais com uma meta móvel.

Como os Gunners, você está tentando atingir um alvo no escuro. Porque seus usuários nunca viram um sistema
Assim antes, seus requisitos podem ser vagos. Como você pode estar usando algoritmos, técnicas, idiomas ou bibliotecas com as quais não conhece, você enfrenta um grande número de incógnitas. E como os projetos levam tempo para serem concluídos, você pode garantir que o ambiente em que está trabalhando mude antes de terminar.

A resposta clássica é especificar o sistema até a morte. Produza resmas de papel especificando todos os requisitos, amarrando todos os desconhecidos e restringindo o ambiente. Disparar a arma usando o cálculo morto. Um grande cálculo na frente, depois atire e espere.

Programadores pragmáticos, no entanto, tendem a preferir usar o equivalente de software das balas do Tracer.





Código que brilha no escuro


As balas do Tracer funcionam porque operam no mesmo ambiente e sob as mesmas restrições que as balas reais. Eles chegam ao alvo rapidamente, então o artilheiro recebe feedback imediato. E do ponto de vista prático, eles são uma solução relativamente barata.

Para obter o mesmo efeito no código, procuramos algo que nos exija de um requisito a algum aspecto do sistema final de maneira rápida, visível e repetida.

Procure os requisitos importantes, aqueles que definem o sistema. Procure as áreas em que você tem dúvidas e onde vê os maiores riscos. Em seguida, priorize seu desenvolvimento para que essas sejam as primeiras áreas que você codifica.

Dica 20 Use balas traçer para encontrar o alvo



De fato, dada a complexidade da configuração do projeto de hoje, com enxames de dependências e ferramentas externas, as balas do Tracer se tornam ainda mais importantes. Para nós, a primeira bala do Tracer é simplesmente criar o projeto, adicionar um "Hello World!" E verifique se ele compila e corre. Em seguida, procuramos áreas de incerteza na aplicação geral e adicionamos o esqueleto necessário para fazê -lo funcionar.

Dê uma olhada no seguinte diagrama. Este sistema possui cinco camadas arquitetônicas. Temos algumas preocupações sobre como eles se integrariam, por isso procuramos um recurso simples que nos permita exercê -los juntos. A linha diagonal mostra o caminho que o recurso segue através do código. Para fazê -lo funcionar, apenas precisamos implementar as áreas solidamente sombreadas em cada camada: as coisas com os rabiscos serão feitas mais tarde.



Certa vez, realizamos um projeto complexo de marketing de banco de dados cliente-servidor. Parte de seu requisito era a capacidade de especificar e executar consultas temporais. Os servidores eram uma variedade de bancos de dados relacionais e especializados. A interface do usuário do cliente, escrita na linguagem aleatória A, usou um conjunto de bibliotecas escritas em um idioma diferente para fornecer uma interface aos servidores. A consulta do usuário foi armazenada no servidor em uma notação do tipo LISP antes de ser convertida em SQL otimizado imediatamente antes da execução. Havia muitas incógnitas e muitos ambientes diferentes, e ninguém tinha certeza de como a interface do usuário deveria se comportar.

Esta foi uma ótima oportunidade para usar o código do rastreador. Desenvolvemos a estrutura para o front end, bibliotecas para representar as consultas e uma estrutura para converter uma consulta armazenada em uma consulta específica de banco de dados. Então juntamos tudo e verificamos que funcionou. Para essa compilação inicial, tudo o que podíamos fazer era enviar uma consulta que listou todas as linhas em uma tabela, mas provou que a interface do usuário poderia conversar com as bibliotecas, as bibliotecas poderiam serializar e não comunicar uma consulta, e o servidor poderia gerar SQL a partir do resultado. Nos meses seguintes, desenvolvemos gradualmente essa estrutura básica, adicionando uma nova funcionalidade aumentando cada componente do código do traçador em paralelo. Quando a interface do usuário adicionou um novo tipo de consulta, a biblioteca cresceu e a geração SQL foi tornada mais sofisticada.

O código do traçador não é descartável: você o escreve para manter. Ele contém toda a verificação, estruturação, documentação e auto-verificação de erros que qualquer código de produção possui. Simplesmente não é totalmente funcional. No entanto, depois de atingir uma conexão de ponta a ponta entre os componentes do seu sistema, você pode verificar o quão próximo o destino você está, ajustando, se necessário. Quando você estiver no alvo, adicionar funcionalidade é fácil.

O desenvolvimento do rastreador é consistente com a ideia de que um projeto nunca será concluído: sempre haverá alterações necessárias e funções para adicionar. É uma abordagem incremental.

A alternativa convencional é um tipo de abordagem de engenharia pesada: o código é dividido em módulos, que são codificados no vácuo. Os módulos são combinados em subconjuntos, que são então combinados, até que um dia você tenha um aplicativo completo. Somente então o aplicativo pode ser apresentado ao usuário e
testado.

A abordagem do Código do Tracer tem muitas vantagens:

Os usuários podem ver algo funcionando cedo

Se você comunicou com sucesso o que está fazendo (consulte o tópico 52, encanta seus usuários), seus usuários saberão que estão vendo algo imaturo. Eles não ficarão desapontados com a falta de funcionalidade; Eles ficarão em êxtase ao ver algum progresso visível em direção ao seu sistema. Eles também contribuem à medida que o projeto avança, aumentando sua adesão. Esses mesmos usuários provavelmente serão as pessoas que lhe dirão o quão perto do alvo está cada iteração.



Desenvolvedores constroem uma estrutura para trabalhar em

O pedaço de papel mais assustador é aquele sem nada escrito. Se você elaborou todas as interações de ponta a ponta do seu aplicativo e as incorporou no código, sua equipe não precisará puxar o máximo de ar. Isso torna todo mundo mais produtivo e incentiva a consistência.



Você tem uma plataforma de integração

Como o sistema está conectado de ponta a ponta, você tem um ambiente ao qual você pode adicionar novas peças de código depois que elas forem testadas na unidade. Em vez de tentar uma integração de grande porte, você estará se integrando todos os dias (geralmente muitas vezes por dia). O impacto de cada nova alteração é mais aparente e as interações são mais limitadas; portanto, a depuração e os testes são mais rápidos e precisos.



Você tem algo para demonstrar

Os patrocinadores do projeto e o topo de bronze tendem a querer ver demos nos momentos mais inconvenientes. Com o código do Tracer, você sempre terá algo para mostrá -los.



Você tem uma sensação melhor para o progresso

Em um desenvolvimento de código do Tracer, os desenvolvedores abordam os casos de uso, um por um. Quando um terminar, eles se mudam para o próximo. É muito mais fácil medir o desempenho e demonstrar progresso para o seu usuário. Como cada desenvolvimento individual é menor, você evita criar esses blocos monolíticos de código que são relatados como 95% completos semana após semana.





As balas traçer nem sempre atingem seu alvo


Bullets Tracer mostram o que você está batendo. Isso nem sempre pode ser o alvo. Você então ajusta seu objetivo até que eles estejam no alvo. Esse é o ponto.

É o mesmo com o código do rastreador. Você usa a técnica em situações em que não tem 100% de certeza de onde está indo. Você não deve se surpreender se suas primeiras tentativas perderem: o usuário diz: "Não é isso que eu quis dizer '' ou os dados que você precisa não estão disponíveis quando você precisar, ou os problemas de desempenho parecem prováveis. Portanto, mude o que você precisa para aproximá -lo do alvo, e é grato que você se lembre mais de uma metodologia de desenvolvimento enxuta; um pouco de um pouco de um pouco de um pouco de um pouco de um pouco que se lembra e é um pouco que se lembra e que se requer que seja um pouco mais rápido. E como todo componente de aplicativo importante é representado no seu código do traçador, seus usuários podem ter certeza de que o que está vendo é baseado na realidade, não apenas em uma especificação de papel.





Código traçador versus prototipagem


Você pode pensar que esse conceito de código do rastreador nada mais é do que prototipagem sob um nome agressivo. Há uma diferença. Com um protótipo, você pretende explorar aspectos específicos do sistema final. Com um protótipo verdadeiro, você jogará fora o que quer que se acertou ao experimentar o conceito e o recuperá corretamente usando as lições que aprendeu.

Por exemplo, diga que você está produzindo um aplicativo que ajuda os remetentes a determinar como embalar caixas de tamanho ímpar em contêineres. Entre outros problemas, a interface do usuário precisa ser intuitiva e os algoritmos que você usa para determinar a embalagem ideal são muito complexos.

Você pode prototipar uma interface do usuário para seus usuários finais em uma ferramenta de interface do usuário. Você codifica apenas o suficiente para tornar a interface responsiva às ações do usuário. Depois de concordarem com o layout, você poderá jogá -lo fora e recodcá -lo, desta vez com a lógica de negócios por trás dele, usando o idioma de destino. Da mesma forma, você pode querer prototipar vários algoritmos que executam a embalagem real. Você pode codificar testes funcionais em um idioma de alto nível, como Python, e codificar testes de desempenho de baixo nível em algo mais próximo da máquina. De qualquer forma, depois de tomar sua decisão, você começará de novo e codifica os algoritmos em seu ambiente final, interface -se no mundo real. Isso é prototipagem e é muito útil.

A abordagem do código do traçador aborda um problema diferente. Você precisa saber como o aplicativo como um todo fica juntos. Você quer mostrar a seus usuários como as interações funcionarão
Pratique e você deseja dar aos seus desenvolvedores um esqueleto arquitetônico para pendurar o código. Nesse caso, você pode construir um traçador que consiste em uma implementação trivial do algoritmo de embalagem de contêineres (talvez algo como o primeiro a chegar, primeiro servido) e uma interface de usuário simples, mas funcional. Depois de ter todos os componentes do aplicativo, você terá uma estrutura para mostrar seus usuários e seus desenvolvedores. Com o tempo, você adiciona a essa estrutura com nova funcionalidade, concluindo rotinas manchadas. Mas a estrutura permanece intacta, e você sabe que o sistema continuará se comportando da maneira que se saiu quando o seu primeiro código do traçador foi concluído.

A distinção é importante o suficiente para justificar a repetição. A prototipagem gera código descartável. O código do traçador é enxuto, mas completo, e faz parte do esqueleto do sistema final. Pense na prototipagem como a reunião de reconhecimento e inteligência que ocorre antes que uma única bala de traçador seja demitida.





Seções relacionadas incluem


Tópico 13, protótipos e notas post-it

Tópico 27, não supere seus faróis

Tópico 40, refatoração

Tópico 49, equipes pragmáticas

Tópico 50, cocos não o cortam

Tópico 51, kit iniciante pragmático

Tópico 52, encanta seus usuários





Tópico 13

Protótipos e notas post-it




Muitas indústrias usam protótipos para experimentar idéias específicas; A prototipagem é muito mais barata que a produção em larga escala. Os fabricantes de carros, por exemplo, podem construir muitos protótipos diferentes de um novo design de carro. Cada um foi projetado para testar um aspecto específico do carro - a aerodinâmica, estilo, características estruturais e assim por diante. O pessoal da velha escola pode usar um modelo de argila para testes de túneis de vento, talvez um modelo de madeira balsa e fita adesiva serve para o departamento de arte e assim por diante. Os menos românticos farão sua modelagem na tela do computador ou na realidade virtual, reduzindo ainda mais os custos. Dessa forma, elementos arriscados ou incertos podem ser testados sem se comprometer a criar o item real.

Construímos protótipos de software da mesma maneira e, pelas mesmas razões - analisar e expor riscos e oferecer chances de correção a um custo bastante reduzido. Como os fabricantes de carros, podemos atingir um protótipo para testar um ou mais aspectos específicos de um projeto.

Tendemos a pensar nos protótipos como baseados em código, mas eles nem sempre precisam ser. Como os fabricantes de carros, podemos construir protótipos a partir de diferentes materiais. As notas post-it são ótimas para prototipagem de coisas dinâmicas, como fluxo de trabalho e lógica de aplicativo. Uma interface do usuário pode ser prototipada como um desenho em um quadro branco, como uma maquete não funcional desenhada com um programa de pintura ou com um construtor de interface.

Os protótipos são projetados para responder apenas algumas perguntas, por isso são muito mais baratas e mais rápidas para desenvolver do que os aplicativos que entram em produção. O código pode ignorar detalhes sem importância - sem importância para você no momento, mas provavelmente muito importante para o usuário posteriormente. Se você estiver prototipando uma interface do usuário, por exemplo, pode se safar de resultados ou dados incorretos. Por outro lado, se você está apenas investigando aspectos computacionais ou de desempenho, poderá se safar de uma interface do usuário muito pobre, ou talvez até nenhuma interface do usuário.

Mas se você se encontrar em um ambiente em que não pode desistir dos detalhes, precisa se perguntar se está realmente construindo um protótipo. Talvez um estilo de desenvolvimento de marcadores traçadores seja mais apropriado neste caso (ver tópico 12, marcadores de rastreamento).





Coisas para o protótipo


Que tipo de coisa você pode escolher investigar com um protótipo? Qualquer coisa que carregue riscos. Qualquer coisa que nunca tenha sido tentada antes, ou isso é absolutamente crítico para o sistema final. Qualquer coisa não comprovada, experimental ou duvidosa. Tudo o que você não se sente confortável. Você pode prototipo:

Arquitetura

Nova funcionalidade em um sistema existente

Estrutura ou conteúdo de dados externos

Ferramentas ou componentes de terceiros

Questões de desempenho

Design da interface do usuário



A prototipagem é uma experiência de aprendizado. Seu valor não está no código produzido, mas nas lições aprendidas. Esse é realmente o ponto de prototipagem.

Dica 21 Prototipo para aprender





Como usar protótipos


Ao criar um protótipo, que detalhes você pode ignorar?

Correção

Você pode usar dados fictícios, quando apropriado.



Integridade

O protótipo pode funcionar apenas em um sentido muito limitado, talvez com apenas uma peça pré -selecionada de dados de entrada e um item de menu.



Robustez

A verificação de erros provavelmente será incompleta ou ausente completamente. Se você se afastar de
O caminho predefinido, o protótipo pode travar e queimar em uma exibição gloriosa de pirotecnia. Tudo bem.



Estilo

O código do protótipo não deve ter muito em termos de comentários ou documentação (embora você possa produzir resmas de documentação como resultado de sua experiência com o protótipo).





Os protótipos encobrem os detalhes e concentram-se em aspectos específicos do sistema que está sendo considerado; portanto, você pode implementá-los usando uma linguagem de script de alto nível-mais alta que o restante do projeto (talvez um idioma como Python ou Ruby), pois esses idiomas podem sair do seu caminho. Você pode optar por continuar se desenvolvendo no idioma usado para o protótipo ou pode alternar; Afinal, você vai jogar o protótipo de qualquer maneira.

Para protótipo de interfaces de usuário, use uma ferramenta que permita se concentrar na aparência e/ou interações sem se preocupar com código ou marcação.

As linguagens de script também funcionam bem como a "cola" para combinar peças de baixo nível em novas combinações. Usando essa abordagem, você pode montar rapidamente componentes existentes em novas configurações para ver como as coisas funcionam.





Arquitetura de prototipagem


Muitos protótipos são construídos para modelar todo o sistema em consideração. Ao contrário das balas do Tracer, nenhum dos módulos individuais no sistema de protótipo precisa ser particularmente funcional. De fato, você pode nem precisar codificar para protótipo de arquitetura-você pode prototipar em um quadro branco, com notas post-it ou cartões de índice. O que você está procurando é como o sistema se une como um todo, mais novamente adiando os detalhes. Aqui estão algumas áreas específicas que você pode querer procurar no protótipo arquitetônico:

As responsabilidades das principais áreas são bem definidas e apropriadas?

As colaborações entre os principais componentes estão bem definidas?

O acoplamento é minimizado?

Você pode identificar possíveis fontes de duplicação?

As definições e restrições de interface são aceitáveis?

Todo módulo tem um caminho de acesso aos dados de que precisa durante a execução? Tem esse acesso quando precisa?



Este último item tende a gerar as mais surpresas e os resultados mais valiosos da experiência de prototipagem.





Como não usar protótipos


Antes de embarcar em qualquer prototipagem baseada em código, verifique se todos entendem que você está escrevendo código descartável. Os protótipos podem ser enganosamente atraentes para pessoas que não sabem que são apenas protótipos. Você deve deixar bem claro que esse código é descartável, incompleto e não pode ser concluído.

É fácil ficar enganado pela aparente integridade de um protótipo demonstrado, e os patrocinadores ou gerenciamento do projeto podem insistir em implantar o protótipo (ou sua progênie) se você não definir as expectativas certas. Lembre-os de que você pode construir um ótimo protótipo de um carro novo a partir de madeira de balsa e fita adesiva, mas não tentaria conduzi-lo no tráfego de hora do rush!

Se você acha que existe uma forte possibilidade em seu ambiente ou cultura de que o objetivo do código do protótipo possa ser mal interpretado, você pode estar melhor com a abordagem de bala do Tracer. Você acabará com uma estrutura sólida na qual basear o desenvolvimento futuro.

Os protótipos adequadamente usados podem economizar grandes quantidades de tempo, dinheiro e dor, identificando e corrigindo possíveis pontos problemáticos no início do ciclo de desenvolvimento - o tempo em que corrigir erros é barato e fácil.





Seções relacionadas incluem


Tópico 12, balas de traçador

Tópico 14, idiomas de domínio

Tópico 17, jogos de shell

Tópico 27, não supere seus faróis

Tópico 37, ouça seu cérebro de lagarto

Tópico 45, o poço de requisitos

Tópico 52, encanta seus usuários





Exercícios


Exercício 3 (resposta possível)

O marketing gostaria de se sentar e debater alguns designs de página da web com você. Eles estão pensando em mapas de imagem clicáveis para levá -lo a outras páginas e assim por diante. Mas eles não podem decidir sobre um modelo para a imagem - talvez seja um carro, um telefone ou uma casa. Você tem uma lista de páginas de destino e conteúdo; Eles gostariam de ver alguns protótipos. Ah, a propósito, você tem 15 minutos. Quais ferramentas você pode usar?





Tópico 14

Idiomas de domínio




Os limites da linguagem são os limites do mundo de alguém.



Ludwig Wittgenstein



As linguagens do computador influenciam como você pensa sobre um problema e como pensa em se comunicar. Cada idioma vem com uma lista de recursos: palavras -chave, como digitação estática versus dinâmica, ligação precoce versus tardio, funcional versus OO, modelos de herança, mixins, macros - todos os quais podem sugerir ou obscurecer ou obscurecer
certas soluções. Projetar uma solução com C ++ em mente produzirá resultados diferentes de uma solução baseada no pensamento no estilo Haskell e vice-versa. Por outro lado, e pensamos mais importante, o idioma do domínio do problema também pode sugerir uma solução de programação.

Sempre tentamos escrever código usando o vocabulário do domínio do aplicativo (consulte Manter um glossário). Em alguns casos, os programadores pragmáticos podem ir para o próximo nível e realmente programar usando o vocabulário, a sintaxe e a semântica - o idioma - do domínio.

Dica 22 Programa próximo ao domínio do problema





Algumas línguas de domínio do mundo real


Vejamos alguns exemplos em que as pessoas fizeram exatamente isso.





RSPEC


RSPEC [19] é uma biblioteca de testes para Ruby. Ele inspirou versões para a maioria dos outros idiomas modernos. Um teste no RSPEC visa refletir o comportamento que você espera do seu código.

Descreva o BowlingScore fazer

"Total 12 se você marcar 3 quatro vezes" faz

Pontuação = BowlingsCore.New

4.Times {score.add_pins (3)}

Espere (Score.Total) .To Eq (12)

Fim

Fim





Pepino


O pepino [20] é uma maneira neutra em linguagem de programação de especificar testes. Você executa os testes usando uma versão do pepino apropriada para o idioma que você está usando. Para suportar a sintaxe da linguagem natural, você também precisa escrever correspondências específicas que reconheçam frases e extraem parâmetros para os testes.

Recurso: pontuação

​

Antecedentes:

Dado um scorecard vazio

​

Cenário: boliche muitos 3s

Dado que eu jogo um 3

E eu jogo um 3

E eu jogo um 3

E eu jogo um 3

Então a pontuação deve ser 12



Os testes de pepino pretendiam ser lidos pelos clientes do software (embora isso aconteça bastante raramente na prática; o seguinte ao lado considera por que isso pode ser).


Por que muitos usuários de negócios não leem os recursos do CUCUMER?

Uma das razões pelas quais o clássico reunir requisitos, design, código, abordagem de navio não funciona é que ela está ancorada pelo conceito de que sabemos quais são os requisitos. Mas raramente fazemos. Os usuários de seus negócios terão uma vaga idéia do que querem alcançar, mas não sabem nem se importam com os detalhes. Isso faz parte do nosso valor: Intuit Intent e o convertemos em código.

Portanto, quando você forçar uma pessoa de negócios a assinar um documento de requisitos ou fazê -la concordar com um conjunto de recursos de pepino, você está fazendo o equivalente a fazê -los verificar a ortografia em um ensaio escrito em sumério. Eles farão algumas alterações aleatórias para salvar o rosto e assiná -lo para tirá -lo do escritório deles.

Dê -lhes código que executa, no entanto, e eles podem brincar com ele. É aí que suas necessidades reais surgirão.





Rotas de Phoenix


Muitas estruturas da Web têm uma instalação de roteamento, mapeando solicitações HTTP recebidas para funções de manipulador no código. Aqui está um exemplo de Phoenix. [21]

Escopo "/", hellophoenix do

Pipe_through: navegador# Use a pilha de navegador padrão

​

Get "/", PageController ,: ÍNDICE

Recursos "/Usuários", UserController

Fim



Isso diz que solicitações iniciais “/” serão executadas através de uma série de filtros apropriados para os navegadores. Uma solicitação para "/" será tratada pela função de índice no módulo PageController. O UsuáriosController implementa as funções necessárias para gerenciar um recurso acessível através do URL /Usuários.





Ansible


Ansible [22] é uma ferramenta que configura o software, normalmente em um monte de servidores remotos. Faz isso lendo uma especificação que você fornece, fazendo o que for necessário nos servidores para fazê -los refletir essa especificação. A especificação pode ser escrita em YAML, [23] Um idioma que cria estruturas de dados a partir de descrições de texto:

----

- Nome: instale nginx

Apt: nome = nginx state = mais recente

​

- Nome: verifique se o nginx está sendo executado (e habilite -o na inicialização)

Serviço: Nome = Nginx State = Iniciado Ativado = Sim

​

- Nome: Escreva o arquivo de configuração nginx

Modelo: src = modelos/nginx.conf.j2 dest =/etc/nginx/nginx.conf

Notificar:

- Reinicie o nginx



Este exemplo garante que a versão mais recente do NGINX seja instalada nos meus servidores, que seja iniciada por padrão e que use um arquivo de configuração que você forneceu.





Características dos idiomas de domínio


Vejamos esses exemplos mais de perto.

O RSPEC e o roteador Phoenix estão escritos em seus idiomas hospedeiros (Ruby e Elixir). Eles empregam algum código bastante desonesto, incluindo metaprogramação e macros, mas, finalmente, são compilados e executados como código regular.

Testes de pepino e Ansible
As configurações são escritas em seus próprios idiomas. Um teste de pepino é convertido em código para ser executado ou em umaestrutura de dados, enquanto as especificações do Ansible são sempre convertidas em uma estrutura de dados executada pela própria Ansible.

Como resultado, o RSPEC e o código do roteador são incorporados ao código que você executa: são extensões verdadeiras ao vocabulário do seu código. O pepino e o Ansible são lidos por código e convertidos em algum formulário que o código pode usar.

Chamamos o RSPEC e os exemplos do roteador de linguagens de domínio interno, enquanto o pepino e o Ansible usam idiomas externos.





Trade-offs entre idiomas internos e externos


Em geral, uma linguagem de domínio interno pode aproveitar os recursos de sua linguagem host: o idioma do domínio que você cria é mais poderoso e esse poder vem gratuitamente. Por exemplo, você pode usar algum código Ruby para criar vários testes RSPEC automaticamente. Nesse caso, podemos testar as pontuações onde não há peças de reposição ou greves:

Descreva o BowlingScore fazer

(0..4) .Comestem os pinos |

(1..20) .Each do | joga |

Target = pinos * lança

​

"Totals#{Target} se você marcar#{pins}#{throws} vezes" do

Pontuação = BowlingsCore.New

Throws.times {score.add_pins (pinos)}

Espere (Score.Total) .To Eq (Target)

Fim

Fim

Fim

Fim



São 100 testes que você acabou de escrever. Tire o resto do dia de folga.

A desvantagem dos idiomas de domínio interno é que você está vinculado pela sintaxe e semântica desse idioma. Embora alguns idiomas sejam notavelmente flexíveis nesse sentido, você ainda é forçado a comprometer entre o idioma que deseja e o idioma que pode implementar.

Por fim, tudo o que você criar ainda deve ser uma sintaxe válida em seu idioma de destino. Idiomas com macros (como elixir, clojure e cristal) oferecem um pouco mais de flexibilidade, mas, em última análise, a sintaxe é a sintaxe.

Idiomas externos não têm essas restrições. Contanto que você possa escrever um analisador para o idioma, estará pronto. Às vezes, você pode usar o analisador de outra pessoa (como Ansible fez usando o YAML), mas depois voltará a fazer um compromisso.

Escrever um analisador provavelmente significa adicionar novas bibliotecas e possivelmente ferramentas ao seu aplicativo. E escrever um bom analisador não é um trabalho trivial. Mas, se você estiver se sentindo forte de coração, poderá olhar para geradores de analisador como Bison ou Antlr, e a análise de estruturas como os muitos analisadores de cantos por aí.

Nossa sugestão é bastante simples: não gaste mais esforço do que você economiza. Escrever um idioma de domínio adiciona algum custo ao seu projeto e você precisará estar convencido de que há economias compensadas (potencialmente a longo prazo).

Em geral, use idiomas externos prontos para uso (como YAML, JSON ou CSV), se puder. Caso contrário, observe os idiomas internos. Recomendamos o uso de idiomas externos apenas nos casos em que seu idioma será gravado pelos usuários do seu aplicativo.





Uma linguagem de domínio interno em barato


Por fim, há um trapaceiro para criar idiomas de domínio interno se você não se importar com a sintaxe do host. Não faça um monte de metaprogramação. Em vez disso, apenas escreva funções para fazer o trabalho. De fato, é isso que o RSPEC faz:

Descreva o BowlingScore fazer

"Total 12 se você marcar 3 quatro vezes" faz

Pontuação = BowlingsCore.New

4.Times {score.add_pins (3)}

Espere (Score.Total) .To Eq (12)

Fim

Fim



Neste código, descreva, espera, e o EQ são apenas métodos de rubi. Há um pouco de encanamento nos bastidores em termos de como os objetos são transmitidos, mas tudo é apenas código. Vamos explorar isso um pouco nos exercícios.





Seções relacionadas incluem


Tópico 8, a essência do bom design

Tópico 13, protótipos e notas post-it

Tópico 32, configuração





Desafios


Alguns dos requisitos do seu projeto atual poderiam ser expressos em um idioma específico do domínio? Seria possível escrever um compilador ou tradutor que pudesse gerar a maior parte do código necessário?



Se você decidir adotar mini-idiomas como uma maneira de programar mais perto do domínio do problema, estará aceitando que algum esforço será necessário para implementá-los. Você pode ver maneiras pelas quais a estrutura que você desenvolve para um projeto pode ser reutilizada em outras pessoas?





Exercícios


Exercício 4 (resposta possível)

Queremos implementar uma mini-linguagem para controlar um sistema simples de tartarugas. O idioma consiste em comandos de letra única, alguns seguidos por um único número. Por exemplo, a seguinte entrada desenharia um retângulo:

P 2 #
Selecione Pen 2

D # Pen Down

W 2 # Draw West 2cm

N 1 # então norte 1

E 2 # então leste 2

S 1 # Então volte para o sul

U # Pen Up



Implementar o código que analisa esse idioma. Ele deve ser projetado para que seja simples adicionar novos comandos.

Exercício 5 (resposta possível)

No exercício anterior, implementamos um analisador para a linguagem de desenho - era um idioma de domínio externo. Agora implemente -o novamente como um idioma interno. Não faça nada inteligente: apenas escreva uma função para cada um dos comandos. Você pode ter que alterar os nomes dos comandos para minúsculos e talvez envolvê -los dentro de algo para fornecer algum contexto.

Exercício 6 (possível resposta)

Projete uma gramática BNF para analisar uma especificação de tempo. Todos os exemplos a seguir devem ser aceitos:

16:00, 19:38, 23:42, 3:16, 3:16



Exercício 7 (possível resposta)

Implemente um analisador para a gramática BNF no exercício anterior usando um gerador de analisador PEG no idioma de sua escolha. A saída deve ser um número inteiro contendo o número de minutos depois da meia -noite.

Exercício 8 (resposta possível)

Implemente o analisador de tempo usando uma linguagem de script e expressões regulares.





Tópico 15

Estimativa




A Biblioteca do Congresso em Washington, DC, atualmente possui cerca de 75 terabytes de informações digitais on -line. Rápido! Quanto tempo levará para enviar todas essas informações em uma rede de 1 Gbps? Quanta armazenamento você precisará para um milhão de nomes e endereços? Quanto tempo leva para comprimir 100 MB de texto? Quantos meses levará para entregar seu projeto?

Em um nível, todas essas são perguntas sem sentido - todas estão ausentes de informações. E, no entanto, todos eles podem ser respondidos, desde que você esteja confortável em estimar. E, no processo de produção de uma estimativa, você entenderá mais sobre o mundo que seus programas habitam.

Ao aprender a estimar e desenvolvendo essa habilidade a ponto de ter uma sensação intuitiva pelas magnitudes das coisas, você poderá mostrar uma aparente capacidade mágica de determinar sua viabilidade. Quando alguém disser "enviaremos o backup sobre uma conexão de rede com o S3", você poderá saber intuitivamente se isso é prático. Ao codificar, você poderá saber quais subsistemas precisam otimizar e quais podem ser deixados em paz.

Dica 23 Estimativa para evitar surpresas



Como bônus, no final desta seção, revelaremos a resposta correta para dar sempre que alguém pedir uma estimativa.





Quão preciso é preciso o suficiente?


Até certo ponto, todas as respostas são estimativas. Só que alguns são mais precisos que outros. Portanto, a primeira pergunta que você deve fazer a si mesmo quando alguém lhe pedir uma estimativa é o contexto em que sua resposta será levada. Eles precisam de alta precisão ou estão procurando uma figura de estádio?

Uma das coisas interessantes sobre estimar é que as unidades que você usa fazem a diferença na interpretação do resultado. Se você disser que algo levará cerca de 130 dias úteis, as pessoas esperam que ele chegue bem perto. No entanto, se você disser "Oh, cerca de seis meses", eles sabem procurá -lo a qualquer momento entre cinco e sete meses daqui. Ambos os números representam a mesma duração, mas "130 dias" provavelmente implica um maior grau de precisão do que você. Recomendamos que você escala estimativas de tempo da seguinte forma:



Duração

Estimativa de citação em





1–15 dias

Dias





3-6 semanas

Semanas





8 a 20 semanas

Meses





Mais de 20 semanas

Pense muito antes de dar uma estimativa





Portanto, se, depois de fazer todo o trabalho necessário, você decidir que um projeto levará 125 dias úteis (25 semanas), convém entregar uma estimativa de "cerca de seis meses".

Os mesmos conceitos se aplicam a estimativas de qualquer quantidade: escolha as unidades de sua resposta para refletir a precisão que você pretende transmitir.





De onde vêm as estimativas?


Todas as estimativas são baseadas nos modelos do problema. Mas antes de entrarmos profundamente nas técnicas de construção de modelos, precisamos mencionar um truque de estimativa básica que sempre dê boas respostas: pergunte a alguém que já o fez. Antes de se comprometer demais com a construção de modelos, lançado para alguém que esteve em uma situação semelhante no passado. Veja como o problema deles foi resolvido. É improvável que você encontre uma correspondência exata, mas ficará surpreso com quantas vezes pode atrair com sucesso as experiências de outras pessoas.





Entenda o que está sendo perguntado


A primeira parte de qualquer exercício de estimativa é construir uma compreensão do que está sendo solicitado. Bem como a precisão
Questões discutidas acima, você precisa ter uma compreensão do escopo do domínio. Muitas vezes, isso está implícito na questão, mas você precisa criar o hábito de pensar no escopo antes de começar a adivinhar. Freqüentemente, o escopo que você escolhe faz parte da resposta que você dá: "Supondo que não haja acidentes de trânsito e que haja gás no carro, eu deveria estar lá em 20 minutos".





Construir um modelo do sistema


Esta é a parte divertida da estimativa. A partir da sua compreensão da pergunta, construa um modelo mental de ossos nus e prontos. Se você estiver estimando os tempos de resposta, seu modelo pode envolver um servidor e algum tipo de tráfego que chega. Para um projeto, o modelo pode ser as etapas que sua organização usa durante o desenvolvimento, juntamente com uma imagem muito difícil de como o sistema pode ser implementado.

A construção de modelos pode ser criativa e útil a longo prazo. Freqüentemente, o processo de construção do modelo leva a descobertas de padrões e processos subjacentes que não eram aparentes na superfície. Você pode até querer reexaminar a pergunta original: “Você pediu uma estimativa para fazer X. No entanto, parece que Y, uma variante de X, pode ser feita em cerca de metade do tempo e você perde apenas um recurso.”

A construção do modelo introduz imprecisões no processo de estimativa. Isso é inevitável e também benéfico. Você está trocando a simplicidade do modelo por precisão. Dobrar o esforço do modelo pode dar apenas um ligeiro aumento de precisão. Sua experiência lhe dirá quando parar de refinar.





Quebre o modelo em componentes


Depois de ter um modelo, você pode decompô -lo em componentes. Você precisará descobrir as regras matemáticas que descrevem como esses componentes interagem. Às vezes, um componente contribui com um único valor adicionado ao resultado. Alguns componentes podem fornecer fatores de multiplicação, enquanto outros podem ser mais complicados (como aqueles que simulam a chegada do tráfego em um nó).

Você descobrirá que cada componente normalmente terá parâmetros que afetam como isso contribui para o modelo geral. Nesta fase, basta identificar cada parâmetro.





Dê um valor a cada parâmetro


Depois de quebrar os parâmetros, você pode passar e atribuir um valor a cada um. Você espera apresentar alguns erros nesta etapa. O truque é descobrir quais parâmetros têm o maior impacto no resultado e se concentrar em acertá -los. Normalmente, os parâmetros cujos valores são adicionados em resultado são menos significativos do que os multiplicados ou divididos. Dobrar uma velocidade de linha pode dobrar a quantidade de dados recebidos em uma hora, enquanto a adição de um atraso no trânsito de 5ms não terá efeito perceptível.

Você deve ter uma maneira justificável de calcular esses parâmetros críticos. Para o exemplo de fila, você pode medir a taxa de chegada da transação real do sistema existente ou encontrar um sistema semelhante para medir. Da mesma forma, você pode medir o tempo atual para atender a uma solicitação ou obter uma estimativa usando as técnicas descritas nesta seção. Na verdade, você geralmente se baseia na estimativa de outros subestimados. É aqui que seus maiores erros entrarão.





Calcule as respostas


Somente nos casos mais simples, uma estimativa terá uma única resposta. Você pode ficar feliz em dizer: "Eu posso andar cinco blocos entre cidades em 15 minutos". No entanto, à medida que os sistemas ficam mais complexos, você deseja proteger suas respostas. Execute vários cálculos, variando os valores dos parâmetros críticos, até descobrir quais realmente dirigem o modelo. Uma planilha pode ser uma grande ajuda. Em seguida, forneça sua resposta em termos desses parâmetros. "O tempo de resposta é de aproximadamente três quartos de segundo se o sistema tiver SSDs e 32 GB de memória e um segundo com memória de 16 GB". (Observe como "três quartos de um segundo" transmite um sentimento diferente de precisão de 750ms.)

Durante a fase de cálculo, você obtém respostas que parecem estranhas. Não seja rápido demais para descartá -los. Se sua aritmética estiver correta, sua compreensão do problema ou do seu modelo provavelmente está errada. Esta é uma informação valiosa.





Acompanhe suas proezas de estimativa


Achamos que é uma ótima ideia gravar suas estimativas para que você possa ver o quão perto você estava. Se uma estimativa geral envolveu o cálculo dos subestimados, também acompanhe isso. Muitas vezes, você acha que suas estimativas são muito boas - na verdade, depois de um tempo, você espera isso.

Quando uma estimativa acabar errada, não apenas deça de ombros e vá embora - descubra o porquê. Talvez você tenha escolhido
Alguns parâmetros que não correspondem à realidade do problema. Talvez seu modelo estivesse errado. Seja qual for o motivo, reserve algum tempo para descobrir o que aconteceu. Se o fizer, sua próxima estimativa será melhor.





Estimativa de cronogramas do projeto


Normalmente, você será solicitado a estimar quanto tempo algo levará. Se esse "algo" for complexo, a estimativa pode ser muito difícil de produzir. Nesta seção, examinaremos duas técnicas para reduzir essa incerteza.





Pintando o míssil




"Quanto tempo levará para pintar a casa?"

"Bem, se tudo correr certo, e essa tinta tem a cobertura que afirmam, pode demorar apenas 10 horas. Mas isso é improvável: acho que uma figura mais realista está mais próxima de 18 horas. E, é claro, se o clima ficar ruim, isso pode empurrá -lo para 30 ou mais".

É assim que as pessoas estimam no mundo real. Não com um único número (a menos que você os force a dar um), mas com uma variedade de cenários.

Quando a Marinha dos EUA precisava planejar o projeto submarino Polaris, eles adotaram esse estilo de estimativa com uma metodologia que chamavam de técnica de revisão de avaliação do programa, ou PERT.

Toda tarefa PERT tem uma estimativa otimista, mais provável e pessimista. As tarefas são organizadas em uma rede de dependência e você usa algumas estatísticas simples para identificar os melhores e os piores momentos prováveis para o projeto geral.

Usar uma variedade de valores como essa é uma ótima maneira de evitar uma das causas mais comuns de erro de estimativa: preencher um número porque você não tem certeza. Em vez disso, as estatísticas por trás da PERT divulgam a incerteza para você, oferecendo melhores estimativas de todo o projeto.

No entanto, não somos grandes fãs disso. As pessoas tendem a produzir gráficos do tamanho de uma parede de todas as tarefas em um projeto e acreditam implicitamente que, apenas porque usaram uma fórmula, elas têm uma estimativa precisa. As chances são de que não, porque nunca fizeram isso antes.





Comer o elefante


Descobrimos que muitas vezes a única maneira de determinar o cronograma para um projeto é obter experiência no mesmo projeto. Isso não precisa ser um paradoxo se você praticar o desenvolvimento incremental, repetindo as etapas a seguir com fatias muito finas de funcionalidade:

Verifique os requisitos

Analisar o risco (e priorizar itens mais arriscados mais cedo)

Projetar, implementar, integrar

Validar com os usuários



Inicialmente, você pode ter apenas uma vaga idéia de quantas iterações serão necessárias ou quanto tempo elas podem levar. Alguns métodos exigem que você acerte isso como parte do plano inicial; No entanto, para todos, exceto o mais trivial dos projetos, isso é um erro. A menos que você esteja fazendo um aplicativo semelhante ao anterior, com a mesma equipe e a mesma tecnologia, você estaria apenas adivinhando.

Assim, você conclui a codificação e teste da funcionalidade inicial e marque isso como o final da primeira iteração. Com base nessa experiência, você pode refinar seu palpite inicial sobre o número de iterações e o que pode ser incluído em cada um. O refinamento fica cada vez melhor a cada vez, e a confiança no cronograma cresce junto com ele. Esse tipo de estimativa geralmente é feito durante a revisão da equipe no final de cada ciclo iterativo.

É também assim que a velha piada diz para comer um elefante: uma mordida de cada vez.

Dica 24 itera o cronograma com o código



Isso pode não ser popular entre a gerência, que normalmente deseja um único número e rápido antes mesmo do projeto começar. Você precisará ajudá -los a entender que a equipe, sua produtividade e o ambiente determinarão o cronograma. Ao formalizar isso e refinar o cronograma como parte de cada iteração, você estará dando a eles as estimativas de agendamento mais precisas possível.





O que dizer quando solicitado uma estimativa


Você diz: "Eu voltarei para você".

Você quase sempre obtém melhores resultados se desacelerar o processo e passar algum tempo passando pelas etapas que descrevemos nesta seção. As estimativas fornecidas na máquina de café (como o café) voltarão para assombrá -lo.





Seções relacionadas incluem


Tópico 7, comunique!

Tópico 39, velocidade do algoritmo





Desafios


Comece a manter um registro de suas estimativas. Para cada um, rastreie o quão preciso você se mostrou. Se seu erro foi superior a 50%, tente descobrir onde sua estimativa deu errado.





Exercícios


Exercício 9 (possível resposta)

Perguntou -se: "Qual tem uma largura de banda mais alta: uma conexão de rede de 1 Gbps ou uma pessoa que caminha entre dois computadores com 1 TB de dispositivo de armazenamento no bolso? '' Que restrições você colocará em sua resposta para
Garanta que o escopo da sua resposta esteja correto? (Por exemplo, você pode dizer que o tempo necessário para acessar o dispositivo de armazenamento é ignorado.)

Exercício 10 (resposta possível)

Então, qual tem a largura de banda mais alta?





Notas de rodapé


[13]

Parafraseando a velha música de Arlen/Mercer…



[14]

Ou, talvez, para manter sua sanidade, toda 10ª vez ...



[15]

https://github.com/oai/openapi-specification



[16]

Na realidade, isso é ingênuo. A menos que você tenha notavelmente sortudo, a maioria das alterações nos requisitos do mundo real afetará várias funções no sistema. No entanto, se você analisar a alteração em termos de funções, cada alteração funcional ainda deve afetar idealmente apenas um módulo.



[17]

De fato, este livro é escrito em Markdown e com o Typenet diretamente da fonte de marcação.



[18]

Pegue um sistema não linear ou caótico e aplique uma pequena alteração em um de seus insumos. Você pode obter um resultado grande e muitas vezes imprevisível. A borboleta clichê batendo suas asas em Tóquio pode ser o início de uma cadeia de eventos que acabam gerando um tornado no Texas. Isso soa como algum projeto que você conhece?



[19]

https://rspec.info



[20]

https://cucumber.io/



[21]

https://phoenixframework.org/



[22]

https://www.ansible.com/



[23]

https://yaml.org/





Copyright © 2020 Pearson Education, Inc.





Capítulo 3



As ferramentas básicas




Todo criador começa sua jornada com um conjunto básico de ferramentas de boa qualidade. Um marceneiro pode precisar de regras, medidores, duas serras, alguns bons aviões, cinzéis finos, exercícios e aparelhos, marretas e grampos. Essas ferramentas serão escolhidas com amor, serão construídas para durar, realizarão trabalhos específicos com pouca sobreposição com outras ferramentas e, talvez o mais importante, parecerão corretas nas mãos do empreendedor de madeira.

Em seguida, começa um processo de aprendizado e adaptação. Cada ferramenta terá sua própria personalidade e peculiaridades e precisará de seu próprio manuseio especial. Cada um deve ser afiado de uma maneira única, ou mantida exatamente assim. Com o tempo, cada um se desgastará de acordo com o uso, até que a aderência pareça um molde das mãos do marceneiro e a superfície de corte se alinhe perfeitamente com o ângulo no qual a ferramenta é mantida. Nesse ponto, as ferramentas se tornam condutas do cérebro do fabricante para o produto acabado - elas se tornaram extensões de suas mãos. Com o tempo, o trabalhador da madeira adicionará novas ferramentas, como cortadores de biscoitos, serras de mitra guiadas a laser, gabaritos de cauda-todas as maravilhosas peças de tecnologia. Mas você pode apostar que eles ficarão mais felizes com uma dessas ferramentas originais na mão, sentindo o avião cantar enquanto desliza pela madeira.

As ferramentas amplificam seu talento. Quanto melhores suas ferramentas e melhor você souber usá -las, mais produtiva poderá ser. Comece com um conjunto básico de ferramentas geralmente aplicáveis. À medida que você ganha experiência e, à medida que você se depara com requisitos especiais, você adiciona a esse conjunto básico. Como o fabricante, espere adicionar à sua caixa de ferramentas regularmente. Sempre esteja à procura de maneiras melhores de fazer as coisas. Se você se deparar com uma situação em que sente que suas ferramentas atuais não podem cortá -la, anote -se para procurar algo diferente ou mais poderoso que teria ajudado. Vamos precisar dirigir suas aquisições.

Muitos novos programadores cometem o erro de adotar uma única ferramenta elétrica, como um ambiente de desenvolvimento integrado específico (IDE), e nunca deixa sua interface aconchegante. Isso realmente é um erro. Você precisa se sentir confortável além dos limites impostos por um IDE. A única maneira de fazer isso é manter o conjunto básico de ferramentas nítido e pronto para uso.

Neste capítulo, falaremos sobre investir em sua própria caixa de ferramentas básica. Como em qualquer boa discussão sobre ferramentas, começaremos (no tópico 16, o poder do texto simples) olhando para as matérias -primas, as coisas que você estará moldando. A partir daí, mudaremos para a bancada de trabalho ou, no nosso caso, o computador. Como você pode usar seu computador para tirar o máximo proveito das ferramentas que você usa? Discutiremos isso no tópico 17, Shell Games. Agora que temos material e um banco para trabalhar, voltaremos para a ferramenta que você provavelmente usará mais do que qualquer outro, seu editor. No tópico 18, edição de energia, sugerimos maneiras de torná -lo mais eficiente.

Para garantir que nunca perdemos nenhum dos nossos preciosos trabalhos, devemos sempre usar um tópico 19, sistema de controle de versão - mesmo para coisas pessoais, como receitas ou notas. E, como Murphy era realmente um otimista, você não pode ser um ótimo programador até se tornar altamente qualificado no tópico 20, depuração.

Você precisará de alguma cola para unir grande parte da magia. Discutimos algumas possibilidades no tópico 21,
Manipulação de texto.

Finalmente, a tinta mais palestra ainda é melhor que a melhor memória. Acompanhe seus pensamentos e sua história, como descrevemos no tópico 22, Engenharia Daybooks.

Passe algum tempo aprendendo a usar essas ferramentas e, em algum momento, você ficará surpreso ao descobrir seus dedos se movendo sobre o teclado, manipulando texto sem pensar consciente. As ferramentas se tornarão extensões de suas mãos.





Tópico 16

O poder do texto simples




Como programadores pragmáticos, nosso material base não é madeira ou ferro, é conhecimento. Reunimos os requisitos como conhecimento e, em seguida, expressamos esse conhecimento em nossos projetos, implementações, testes e documentos. E acreditamos que o melhor formato para armazenar conhecimento persistentemente é um texto simples. Com o texto simples, nos damos a capacidade de manipular o conhecimento, tanto manual quanto programaticamente, usando praticamente todas as ferramentas à nossa disposição.

O problema com a maioria dos formatos binários é que o contexto necessário para entender os dados é separado dos próprios dados. Você está se divorciando artificialmente dos dados de seu significado. Os dados também podem ser criptografados; É absolutamente sem sentido sem a lógica do aplicativo analisá -la. Com o texto simples, no entanto, você pode obter um fluxo de dados auto-descritivo independente do aplicativo que o criou.





O que é texto simples?


O texto simples é composto de caracteres imprimíveis em um formulário que transmite informações. Pode ser tão simples quanto uma lista de compras:

* Leite

* Alface

* Café



ou tão complexo quanto a fonte deste livro (sim, ele está em texto simples, para o desgosto do editor, que queria que usássemos um processador de texto).

A parte da informação é importante. A seguir, não é um texto simples útil:

Hlj; uijn bfjxrrctvh jkni'pio6p7gu; vh bjxrdi5rgvhj



Nem é isso:

Campo19 = 467ABE



O leitor não tem idéia de qual pode ser o significado do 467ABE. Gostamos que nosso texto simples seja compreensível para os seres humanos.

Dica 25 Mantenha o conhecimento em texto simples





O poder do texto


O texto simples não significa que o texto não é estruturado; HTML, JSON, YAML E assim por diante são todos os texto simples. O mesmo acontece com a maioria dos protocolos fundamentais na rede, como HTTP, SMTP, IMAP e assim por diante. E isso é por alguns bons motivos:

Seguro contra obsolescência

Aproveite as ferramentas existentes

Testes mais fáceis





Seguro contra obsolescência


Formas de dados legíveis por humanos e dados de auto-descrição sobreviverão a todas as outras formas de dados e os aplicativos que os criaram. Período. Enquanto os dados sobreviverem, você terá a chance de usá -los - potencialmente muito tempo depois do aplicativo original que o escreveu é extinto.

Você pode analisar esse arquivo com apenas conhecimento parcial de seu formato; Com a maioria dos arquivos binários, você deve conhecer todos os detalhes de todo o formato para analisá -lo com sucesso.

Considere um arquivo de dados de algum sistema herdado que você recebe. [24] Você sabe pouco sobre o aplicativo original; Tudo o que é importante para você é que ele manteve uma lista dos números de seguridade social dos clientes, que você precisa encontrar e extrair. Entre os dados, você vê

<Field10> 123-45-6789 </field10>

...

<Field10> 567-89-0123 </field10>

...

<Field10> 901-23-4567 </field10>



Reconhecendo o formato de um número de previdência social, você pode escrever rapidamente um pequeno programa para extrair esses dados - mesmo que você não tenha informações sobre mais nada no arquivo.

Mas imagine se o arquivo tivesse sido formatado desta maneira:

AC27123456789B11p

...

XY43567890123QTYL

...

6T2190123456788am



Você pode não ter reconhecido o significado dos números com a mesma facilidade. Essa é a diferença entre o humano legível e o humano compreensível.

Enquanto estamos nisso, o Field10 também não ajuda muito. Algo como

<Social-Security-não> 123-45-6789 </social-Security-não>



Torna o exercício um acéfalo-e garante que os dados sobrevilem a qualquer projeto que o criasse.





Aproveitar


Praticamente todas as ferramentas no universo de computação, desde sistemas de controle de versão a editores e ferramentas de linha de comando, podem operar em texto sem formatação.


A filosofia do UNIX

A Unix é famosa por ser projetada em torno da filosofia de pequenas ferramentas afiadas, cada uma pretendia fazer uma coisa bem. Essa filosofia é ativada usando um formato subjacente comum-o arquivo de texto simples, orientado a linha. Os bancos de dados usados para administração do sistema (usuários e senhas, configuração de rede e assim por diante) são mantidos como arquivos de texto simples. (Alguns sistemas também mantêm uma forma binária de determinados bancos de dados como desempenho
otimização. A versão em texto simples é mantido como uma interface para a versão binária.)

Quando um sistema trava, você pode enfrentar apenas um ambiente mínimo para restaurá -lo (talvez não consiga acessar drivers gráficos, por exemplo). Situações como essa podem realmente fazer você apreciar a simplicidade do texto simples.

O texto simples também é mais fácil de pesquisar. Se você não consegue se lembrar de qual arquivo de configuração gerencia os backups do sistema, um backup rápido de grep -r /etc. deve dizer.





Por exemplo, suponha que você tenha uma implantação de produção de um grande aplicativo com um arquivo de configuração específico do site complexo. Se este arquivo estiver em texto simples, você pode colocá -lo em um sistema de controle de versão (consulte o tópico 19, controle de versão), para manter automaticamente um histórico de todas as alterações. Ferramentas de comparação de arquivos, como DIFF e FC, permitem que você veja de relance quais mudanças foram feitas, enquanto a SUM permite gerar uma soma de verificação para monitorar o arquivo para modificação acidental (ou maliciosa).





Testes mais fáceis


Se você usar texto simples para criar dados sintéticos para direcionar testes do sistema, é uma questão simples de adicionar, atualizar ou modificar os dados de teste sem precisar criar nenhuma ferramenta especial para fazê -lo. Da mesma forma, a saída de texto simples dos testes de regressão pode ser analisado trivialmente com comandos de shell ou um script simples.





Denominador comum mais baixo


Mesmo no futuro dos agentes inteligentes baseados em blockchain que viajam pela Internet selvagem e perigosa da Internet, negociando o intercâmbio de dados entre si, o onipresente arquivo de texto ainda estará lá. De fato, em ambientes heterogêneos, as vantagens do texto simples podem superar todas as desvantagens. Você precisa garantir que todas as partes possam se comunicar usando um padrão comum. Texto simples é esse padrão.





Seções relacionadas incluem


Tópico 17, jogos de shell

Tópico 21, manipulação de texto

Tópico 32, configuração





Desafios


Projete um pequeno banco de dados de livro de endereços (nome, número de telefone e assim por diante) usando uma representação binária direta em seu idioma de escolha. Faça isso antes de ler o resto deste desafio.

Traduza esse formato em um formato de texto simples usando XML ou JSON.



Para cada versão, adicione um novo campo de comprimento variável chamado instruções nas quais você pode inserir instruções para a casa de cada pessoa.





Que problemas surgem em relação ao versão e extensibilidade? Qual forma era mais fácil de modificar? Que tal converter dados existentes?





Tópico 17

Jogos de concha




Todo marceneiro precisa de uma bancada boa, sólida e confiável, em algum lugar para manter peças de trabalho em uma altura conveniente enquanto elas estão sendo moldadas. A bancada se torna o centro da oficina, o fabricante retornando a ele uma e outra vez quando uma peça toma forma.

Para um programador manipulando arquivos de texto, esse workbench é o shell de comando. No prompt do Shell, você pode invocar todo o seu repertório de ferramentas, usando tubos para combiná -los de maneiras nunca sonhadas por seus desenvolvedores originais. Do shell, você pode lançar aplicativos, depuradores, navegadores, editores e serviços públicos. Você pode pesquisar arquivos, consultar o status do sistema e filtrar a saída. E ao programar o shell, você pode criar comandos macro complexos para atividades que executam com frequência.

Para programadores criados em interfaces da GUI e ambientes de desenvolvimento integrado (IDES), isso pode parecer uma posição extrema. Afinal, você não pode fazer tudo igualmente bem apontando e clicando?

A resposta simples é "não". 'As interfaces da GUI são maravilhosas e podem ser mais rápidas e mais convenientes para algumas operações simples. Mover arquivos, ler e escrever email e construir e implantar seu projeto é tudo o que você pode fazer em um ambiente gráfico. Mas você não faz o seu trabalho, que não pode ser usado para que você não use o seu ambiente. Ser capaz de combinar suas ferramentas para criar ferramentas de macro personalizadas.

Os ambientes da GUI são normalmente limitados aos recursos que seus designers pretendiam. Se você precisar ir além do modelo que o designer forneceu, geralmente está sem sorte - e na maioria das vezes, precisa ir além do modelo. Os programadores pragmáticos não apenas cortam código, ou desenvolvem modelos de objetos, ou escrevem documentação ou automatizam o processo de construção - fazemos todas essas coisas. O escopo
de qualquer ferramenta geralmente é limitada às tarefas que a ferramenta deve executar. Por exemplo, suponha que você precise integrar um pré-processador de código (para implementar o design por contrato, ou Pragmas com vários processos, ou algo assim) no seu IDE. A menos que o designer do IDE tenha fornecido explicitamente ganchos para esse recurso, você não pode fazê -lo.

Dica 26 Use o poder dos shells de comando



Fique familiarizado com o shell e você encontrará sua produtividade em alta. Precisa criar uma lista de todos os nomes exclusivos de pacotes explicitamente importados pelo seu código Java? Os seguintes armazenam em um arquivo chamado "Lista":

sh/packages.sh

Grep '^Import'*.Java |

Sed -e 's /.* import*//' -e 's /;.*$//' |

Classificar -u> Lista



Se você não passou muito tempo explorando os recursos do shell de comando nos sistemas que você usa, isso pode parecer assustador. No entanto, invista alguma energia para se familiarizar com sua concha e as coisas em breve começarão a se encaixar. Brinque com o seu shell de comando e você ficará surpreso com o quanto mais produtivo o torna.





Uma concha própria


Da mesma forma que um trabalhador marceneiro personalizará seu espaço de trabalho, um desenvolvedor deve personalizar seu shell. Isso normalmente também envolve alterar a configuração do programa de terminal que você usa.

As mudanças comuns incluem:

Definir temas de cores. Muitas, muitas horas podem ser gastas experimentando todos os temas disponíveis on -line para o seu shell específico.



Configurando um prompt. O aviso que informa que o shell está pronto para que você digite um comando pode ser configurado para exibir praticamente qualquer informação que você deseje (e um monte de coisas que você nunca deseja). As preferências pessoais são tudo aqui: tendemos a gostar de avisos simples, com um nome de diretório atual e status de controle de versão junto com o tempo.



Aliases e funções da concha. Simplifique seu fluxo de trabalho transformando os comandos que você usa muito em aliases simples. Talvez você atualize regularmente sua caixa Linux, mas nunca se lembra se você atualiza e atualiza ou atualiza e atualiza. Crie um pseudônimo:

Alias apt-up = 'sudo apt-get update && sudo apt-get upgrade'



Talvez você tenha excluído acidentalmente arquivos com o comando rm apenas uma vez. Escreva um pseudônimo para que sempre solicite no futuro:

Alias rm = 'rm -iv'





Conclusão de comando. A maioria dos shells concluirá os nomes de comandos e arquivos: digite os primeiros caracteres, pressione a guia e preencherá o que pode. Mas você pode levar isso muito mais longe, configurando o shell para reconhecer o comando que você está inserindo e oferecer conclusões específicas do contexto. Alguns até personalizam a conclusão, dependendo do diretório atual.





Você gastará muito tempo vivendo em uma dessas conchas. Seja como um caranguejo eremita e faça com que seja sua própria casa.





Seções relacionadas incluem


Tópico 13, protótipos e notas post-it

Tópico 16, o poder do texto simples

Tópico 21, manipulação de texto

Tópico 30, transformando a programação

Tópico 51, kit iniciante pragmático





Desafios


Há coisas que você está fazendo manualmente em uma GUI? Você já passa instruções para colegas que envolvem vários etapas individuais de “clique neste botão”, “selecione este item”? Isso poderia ser automatizado?



Sempre que você se mudar para um novo ambiente, faça um ponto de descobrir quais conchas estão disponíveis. Veja se você pode trazer sua concha atual com você.



Investigue alternativas ao seu shell atual. Se você encontrar um problema que seu shell não pode resolver, verifique se um shell alternativo seria melhor lidar.





Tópico 18

Edição de energia




Já conversamos antes sobre as ferramentas serem uma extensão da sua mão. Bem, isso se aplica aos editores mais do que a qualquer outra ferramenta de software. Você precisa ser capaz de manipular o texto da maneira mais fácil possível, porque o texto é a matéria -prima básica da programação.

Na primeira edição deste livro, recomendamos o uso de um único editor para tudo: código, documentação, memorandos, administração do sistema e assim por diante. Nós amolecemos um pouco essa posição. Estamos felizes por você usar quantos editores quiser. Gostaríamos que você trabalhasse em direção à fluência em cada um.

DICA 27 ALCHE



Por que isso é um grande negócio? Estamos dizendo que você economizará muito tempo? Na verdade, sim: ao longo de um ano, você pode realmente ganhar uma semana adicional se tornar sua edição apenas 4% mais eficiente e editar por 20 horas por semana.

Mas esse não é o benefício real. Não, o grande ganho é que, ao se tornar fluente, você não precisa mais pensar sobre o
mecânica da edição. A distância entre pensar em algo e fazê -lo aparecer em um buffer de editor cair. Seus pensamentos fluirão e sua programação se beneficiará. (Se você já ensinou alguém a dirigir, entenderá a diferença entre alguém que precisa pensar em todas as ações que tomam e um motorista mais experiente que controla o carro instintivamente.)





O que significa "fluente"?


O que conta como sendo fluente? Aqui está a lista de desafios:

Ao editar o texto, mova e faça seleções por personagem, palavra, linha e parágrafo.



Ao editar o código, mova -se por várias unidades sintáticas (correspondentes delimitadores, funções, módulos,…).



Código de reindicação após alterações.



Comentários e bloqueios de descomamento de código com um único comando.



Desfazer e refazer mudanças.



Divida a janela do editor em vários painéis e navegue entre eles.



Navegue para um número de linha específico.



Classificar linhas selecionadas.



Pesquise as cordas e expressões regulares e repita as pesquisas anteriores.



Crie temporariamente vários cursores com base em uma seleção ou em uma correspondência de padrão e edite o texto em cada um em paralelo.



Exibir erros de compilação no projeto atual.



Execute os testes do projeto atual.





Você pode fazer tudo isso sem usar um mouse/trackpad?

Você pode dizer que seu editor atual não pode fazer algumas dessas coisas. Talvez seja hora de mudar?





Movendo -se em direção à fluência


Duvidamos que haja mais do que um punhado de pessoas que conhecem todos os comandos em qualquer editor poderoso em particular. Também não esperamos que você o faça. Em vez disso, sugerimos uma abordagem mais pragmática: aprenda os comandos que facilitam sua vida.

A receita para isso é bastante simples.

Primeiro, olhe para si mesmo enquanto você está editando. Toda vez que você se encontra fazendo algo repetitivo, adquira o hábito de pensar: "deve haver uma maneira melhor". Em seguida, encontre -o.

Depois de descobrir um recurso novo e útil, agora você precisa instalá -lo na memória muscular, para que você possa usá -lo sem pensar. A única maneira de fazer isso é através da repetição. Conscientemente, procure oportunidades de usar sua nova superpotência, idealmente muitas vezes por dia. Depois de uma semana, você descobrirá que o usa sem pensar.





Cultivando seu editor


A maioria dos poderosos editores de código é construída em torno de um núcleo básico que é aumentado através de extensões. Muitos são fornecidos com o editor e outros podem ser adicionados posteriormente.

Quando você se deparar com uma aparente limitação do editor que está usando, procure uma extensão que fará o trabalho. As chances são de que você não esteja sozinho precisando dessa capacidade e, se você tiver sorte, outra pessoa terá publicado sua solução.

Dê isso um passo adiante. Prove no idioma de extensão do seu editor. Descubra como usá -lo para automatizar algumas das coisas repetitivas que você faz. Muitas vezes, você só precisa de uma ou duas linhas de código.

Às vezes, você pode levá-lo ainda mais ainda, e se vê escrevendo uma extensão completa. Nesse caso, publique -o: se você precisar, outras pessoas também.





Seções relacionadas incluem


Tópico 7, comunique!





Desafios


Não há mais autor de automóveis.

Todo mundo faz isso: você precisa excluir a última palavra que digitou, então pressiona o backspace e aguarda o início do AutoRepeat. Na verdade, apostamos que seu cérebro fez isso tanto que você pode julgar exatamente quando liberar a chave.

Portanto, desligue o AutorePeat e aprenda as seqüências de chave para mover, selecionar e excluir por caracteres, palavras, linhas e blocos.



Este vai doer.

Perca o mouse/trackpad. Por uma semana inteira, edite usando apenas o teclado. Você descobrirá um monte de coisas que não pode fazer sem apontar e clicar, então agora é a hora de aprender. Mantenha as anotações (recomendamos ir à velha escola e usar lápis e papel) das principais seqüências que você aprende.

Você sofrerá um golpe de produtividade por alguns dias. Mas, ao aprender a fazer coisas sem afastar as mãos da posição inicial, você descobrirá que sua edição se torna mais rápida e mais fluente do que nunca foi no passado.



Procure integrações. Ao escrever este capítulo, Dave se perguntou se poderia visualizar o layout final (um arquivo PDF) em um buffer do editor. Um download mais tarde, o layout está sentado ao lado do texto original, tudo no editor. Mantenha uma lista de coisas que você deseja trazer para o seu editor e procure -as.



Um pouco mais ambiciosamente, se você não conseguir encontrar um plug -in ou extensão que faça o que quiser, escreva um. Andy gosta de fazer costume, local
Plugins wiki baseados em arquivos para seus editores favoritos. Se você não conseguir encontrá -lo, construa!





Tópico 19

Controle de versão




O progresso, longe de consistir na mudança, depende da retenção. Aqueles que não conseguem se lembrar do passado são condenados a repeti -lo.



George Santayana, vida da razão



Uma das coisas importantes que procuramos em uma interface do usuário é a chave de desfazer - um botão único que nos perdoa nossos erros. É ainda melhor se o ambiente suportar vários níveis de desfazer e refazer, para que você possa voltar e se recuperar de algo que aconteceu alguns minutos atrás.

Mas e se o erro acontecesse na semana passada, e você desligue o computador dez vezes desde então? Bem, esse é um dos muitos benefícios do uso de um sistema de controle de versão (VCS): é uma chave gigante de desfazer-uma máquina do tempo em todo o projeto que pode devolvê-lo aos dias da Halcyon da semana passada, quando o código realmente compilou e executou.

Para muitas pessoas, esse é o limite do uso do VCS. Essas pessoas estão perdendo um mundo totalmente maior de colaboração, pipelines de implantação, rastreamento de problemas e interação geral da equipe.

Então, vamos dar uma olhada no VCS, primeiro como um repositório de mudanças e depois como um local de encontro central para sua equipe e seu código.


Diretórios compartilhados não são controle de versão

Ainda encontramos a equipe ocasional que compartilha seus arquivos de origem do projeto em uma rede: internamente ou usando algum tipo de armazenamento em nuvem.

Isso não é viável.

As equipes que fazem isso estão constantemente atrapalhando o trabalho um do outro, perdendo mudanças, quebrando construções e entrando em brigas no estacionamento. É como escrever código simultâneo com dados compartilhados e nenhum mecanismo de sincronização. Use o controle da versão.

Mas há mais! Algumas pessoas usam o controle de versão e mantêm seu repositório principal em uma rede de rede ou nuvem. Eles argumentam que esse é o melhor dos dois mundos: seus arquivos são acessíveis em qualquer lugar e (no caso de armazenamento em nuvem), ele está backup do local.

Acontece que isso é ainda pior e você corre o risco de perder tudo. O software de controle de versão usa um conjunto de arquivos e diretórios de interação. Se duas instâncias fizeram alterações simultaneamente, o estado geral poderá ser corrompido e não há como dizer quanto dano será causado. E ninguém gosta de ver os desenvolvedores chorarem.





Começa na fonte


Os sistemas de controle de versão acompanham todas as alterações que você faz em seu código -fonte e documentação. Com um sistema de controle de código fonte configurado corretamente, você sempre pode voltar a uma versão anterior do seu software.

Mas um sistema de controle de versão faz muito mais do que os erros. Um bom VCS permitirá rastrear alterações, respondendo a perguntas como: quem fez alterações nessa linha de código? Qual é a diferença entre a versão atual e a semana passada? Quantas linhas de código mudamos nesta versão? Quais arquivos são alterados com mais frequência? Esse tipo de informação é inestimável para fins de rastreamento, auditoria, desempenho e qualidade de insetos.

Um VCS também permitirá que você identifique os lançamentos do seu software. Uma vez identificado, você sempre poderá voltar e regenerar a liberação, independentemente das alterações que podem ter ocorrido posteriormente.

Os sistemas de controle de versão podem manter os arquivos que mantêm em um repositório central - um ótimo candidato para o arquivamento.

Por fim, os sistemas de controle de versão permitem que dois ou mais usuários trabalhem simultaneamente no mesmo conjunto de arquivos, até fazendo alterações simultâneas no mesmo arquivo. O sistema gerencia a fusão dessas alterações quando os arquivos são enviados de volta ao repositório. Embora aparentemente arriscados, esses sistemas funcionam bem na prática em projetos de todos os tamanhos.

Dica 28 Sempre use o controle da versão



Sempre. Mesmo se você é uma equipe de uma única pessoa em um projeto de uma semana. Mesmo que seja um protótipo de "lançamento". Mesmo que as coisas em que você esteja trabalhando não seja o código-fonte. Verifique se tudo está sob controle da versão: documentação, listas de números de telefone, memorandos para fornecedores, makefiles, criação e liberação de procedimentos, que não se trata de um pouco de scripts que tivemos o texto, incluindo o tipo de texto, incluindo o que se trata de que o tipo de texto é que um pouco de trabalho, incluindo o que se trata de um pouco de que o texto é que o tipo de realização de um pouco de trabalho, incluindo o que se trata de um pouco de trabalho, incluindo o que se trata de um pouco de que o tipo de texto é que um pouco de trabalho. em um repositório.





Ramificando -se


Os sistemas de controle de versão não mantêm apenas um único histórico do seu projeto. Uma de suas características mais poderosas e úteis é a maneira como eles permitem que você isole ilhas de desenvolvimento em coisas chamadas ramos. Você pode criar uma filial em qualquer ponto do seu projeto
A história e qualquer trabalho que você fizer nesse ramo serão isolados de todos os outros ramos. Em algum momento, no futuro, você pode mesclar a filial em que está trabalhando em outra filial, para que o ramo de destino agora contenha as alterações que você fez em sua filial. Várias pessoas podem até trabalhar em uma filial: de certa forma, as filiais são como pequenos projetos de clones.

Um benefício dos ramos é o isolamento que eles lhe dão. Se você desenvolver o recurso A em uma filial e um companheiro de equipe trabalha no recurso B em outro, você não vai interferir um com o outro.

Um segundo benefício, o que pode ser surpreendente, é que as filiais geralmente estão no centro do fluxo de trabalho do projeto de uma equipe.

E é aqui que as coisas ficam um pouco confusas. As filiais de controle de versão e a organização de testes têm algo em comum: ambos têm milhares de pessoas por aí dizendo como você deve fazê -lo. E esse conselho é em grande parte sem sentido, porque o que eles realmente estão dizendo é "isso é o que funcionou para mim".

Portanto, use o controle da versão em seu projeto e, se você encontrar problemas de fluxo de trabalho, procure possíveis soluções. E lembre -se de revisar e ajustar o que você está fazendo ao ganhar experiência.


Um experimento de pensamento

Derrame uma xícara inteira de chá (café da manhã inglês, com um pouco de leite) no teclado do laptop. Leve a máquina para a barra de pessoa inteligente e peça a eles tut e franzir a testa. Compre um novo computador. Leve para casa.

Quanto tempo levaria para levar a máquina de volta ao mesmo estado em que estava (com todas as teclas SSH, configuração do editor, configuração do shell, aplicativos instalados etc.) no ponto em que você levantou a primeira Copa fatídica? Este foi um problema que um de nós enfrentou recentemente.

Quase tudo o que definiu a configuração e o uso da máquina original foi armazenado no controle de versão, incluindo:

Todas as preferências do usuário e dotfiles

A configuração do editor

A lista de software instalado usando homebrew

O script Ansible usado para configurar aplicativos

Todos os projetos atuais



A máquina foi restaurada até o final da tarde.





Controle de versão como um hub de projeto


Embora o controle de versão seja incrivelmente útil em projetos pessoais, ele realmente se aproxima ao trabalhar com uma equipe. E grande parte desse valor vem de como você hospeda seu repositório.

Agora, muitos sistemas de controle de versão não precisam de hospedagem. Eles são completamente descentralizados, com cada desenvolvedor cooperando em uma base ponto a ponto. Mas mesmo com esses sistemas, vale a pena ter um repositório central, porque, uma vez que você o fizer, você pode aproveitar uma tonelada de integrações para facilitar o fluxo do projeto.

Muitos dos sistemas de repositório são de código aberto, para que você possa instalá -los e executá -los em sua empresa. Mas essa não é realmente a sua linha de negócios, por isso recomendamos que a maioria das pessoas hospede com terceiros. Procure recursos como:

Boa segurança e controle de acesso

UI intuitiva

A capacidade de fazer tudo da linha de comando também (porque você pode precisar automatizá -la)

Construções e testes automatizados

Bom suporte para a fusão da filial (às vezes chamado de solicitações de tração)

Gerenciamento de problemas (idealmente integrado às comissões e fumegas, para que você possa manter as métricas)

Bons relatórios (uma exibição de questões e tarefas pendentes de tabuleiro Kanban pode ser muito útil)

Boas comunicações de equipe: e -mails ou outras notificações sobre mudanças, um wiki e assim por diante



Muitas equipes têm seus VCs configurados para que um impulso para uma filial específica construa automaticamente o sistema, execute os testes e se for bem -sucedido implantar o novo código na produção.

Parece assustador? Não quando você percebe que está usando o controle da versão. Você sempre pode rolar de volta.





Seções relacionadas incluem


Tópico 11, reversibilidade

Tópico 49, equipes pragmáticas

Tópico 51, kit iniciante pragmático





Desafios


Saber que você pode voltar a qualquer estado anterior usando o VCS é uma coisa, mas você pode realmente fazer isso? Você conhece os comandos para fazê -lo corretamente? Aprenda -os agora, não quando ocorre o desastre e você estará sob pressão.



Passe algum tempo pensando em recuperar seu próprio ambiente de laptop em caso de desastre. O que você precisaria se recuperar? Muitas das coisas que você precisa são apenas arquivos de texto. Se eles não estiverem em um VCS (hospedado em seu laptop), encontre uma maneira de adicioná -los. Em seguida, pense nas outras coisas: aplicativos instalados, configuração do sistema e assim por diante. Como você pode expressar tudo isso nos arquivos de texto para que também possa ser salvo?

Um experimento interessante, depois de fazer algum progresso, é encontrar um computador antigo que você não usa mais e ver se seu novo sistema pode ser usado
para configurá -lo.



Explore conscientemente os recursos do seu VCS atual e do provedor de hospedagem que você não está usando. Se sua equipe não estiver usando ramificações de recursos, experimente apresentá -las. O mesmo com solicitações de puxar/mesclagem. Integração contínua. Construir pipelines. Até mesmo implantação contínua. Olhe para as ferramentas de comunicação da equipe também: wikis, Kanban Boards e similares.

Você não precisa usar nada disso. Mas você precisa saber o que faz para que você possa tomar essa decisão.



Use o controle da versão para coisas sem projeto também.





Tópico 20

Depuração




É uma coisa dolorosa

Olhar para o seu próprio problema e saber

Que você mesmo e ninguém mais fez isso



Sófocles, Ajax



A palavra bug tem sido usada para descrever um "objeto de terror" desde o século XIV. O almirante traseiro Dr. Grace Hopper, o inventor de COBOL, é creditado por observar o primeiro bug do computador - literalmente, uma trapaça capturada em um relé em um sistema de computador ", quando foi perguntado por que a máquina não se comportou como se comportava, um técnico relatado que relatou que, em que se comportasse, que não se comportou, o que se comportava, o que se comportou, o que se comportava, que não era o que se comportava, o que se comportava, que não era o que se comportou, como se comportava, o que se comportou, o que se comportava, que não foi o que se comportava, como se comportasse, que não se comportava, que não se comportou, que não se comportou, como se comportava, que se comportou, como se comportava, que se comportou, que se comportou - relatou que um técnico relatou:" o livro de log.

Lamentavelmente, ainda temos bugs no sistema, embora não do tipo voador. Mas o significado do século XIV - um bicho -papão - talvez seja ainda mais aplicável agora do que era então. Os defeitos de software se manifestam de várias maneiras, de requisitos incompreendidos a erros de codificação. Infelizmente, os sistemas de computador modernos ainda se limitam a fazer o que você diz para eles, não necessariamente o que você quer que eles façam.

Ninguém escreve software perfeito, por isso é certo que a depuração ocupará uma grande parte do seu dia. Vejamos algumas das questões envolvidas na depuração e algumas estratégias gerais para encontrar bugs indescritíveis.





Psicologia da depuração


A depuração é um assunto sensível e emocional para muitos desenvolvedores. Em vez de atacá -lo como um quebra -cabeça a ser resolvido, você pode encontrar negação, apontar o dedo, desculpas coxas ou simplesmente apatia.

Abrace o fato de que a depuração é apenas a solução de problemas e atacá -la como tal.

Tendo encontrado o bug de outra pessoa, você pode gastar tempo e energia culpando o culpado imundo que o criou. Em alguns locais de trabalho, isso faz parte da cultura e pode ser catártico. No entanto, na arena técnica, você deseja se concentrar em corrigir o problema, não a culpa.

Dica 29 Corrija o problema, não a culpa



Realmente não importa se o bug é sua culpa ou de outra pessoa. Ainda é o seu problema.





Uma mentalidade de depuração


Antes de começar a depurar, é importante adotar a mentalidade certa. Você precisa desligar muitas das defesas que você usa todos os dias para proteger seu ego, ajustar as pressões do projeto que você estará e se sinta confortável. Acima de tudo, lembre -se da primeira regra de depuração:

Dica 30 não entre em pânico



É fácil entrar em pânico, especialmente se você estiver enfrentando um prazo ou tiver um chefe nervoso ou o cliente respirando seu pescoço enquanto estiver tentando encontrar a causa do bug. Mas é muito importante recuar e pensar no que poderia estar causando os sintomas que você acredita indicar um bug.

Se sua primeira reação ao testemunhar um bug ou ver um relatório de bug é "isso é impossível", você está claramente errado. Não desperdice um único neurônio na linha de pensamento que começa ", mas isso não pode acontecer", porque claramente pode e tem.

Cuidado com a miopia ao depurar. Resista ao desejo de corrigir apenas os sintomas que você vê: é mais provável que a falha real possa ser várias etapas removidas do que você está observando e pode envolver várias outras coisas relacionadas. Sempre tente descobrir a causa raiz de um problema, não apenas essa aparência específica.





Por onde começar


Antes de começar a olhar para o bug, verifique se você está trabalhando no código que construiu de maneira limpa - sem avisos. Rotineiramente, definimos os níveis de aviso do compilador o mais alto possível. Não faz sentido perder tempo tentando encontrar um problema que o computador possa encontrar para você! Precisamos nos concentrar nos problemas mais difíceis em questão.

Ao tentar resolver qualquer problema, você precisa reunir todos os dados relevantes. Infelizmente, o relatório de bugs não é uma ciência exata. É fácil ser enganado por coincidências, e você não pode se dar ao luxo de perder tempo depuração de tempo. Você primeiro precisa ser preciso em suas observações.

A precisão nos relatórios de bugs diminui ainda mais quando eles passarem por terceiros - você pode realmente precisar assistir ao usuário que relatou o bug em
ação para obter um nível de detalhe suficiente.

Andy já trabalhou em um grande aplicativo gráfico. No final da liberação, os testadores relataram que o aplicativo travava toda vez que pintava um golpe com um pincel específico. O programador responsável argumentou que não havia nada de errado nisso; Ele tentou pintar com ele, e funcionou muito bem. Esse diálogo voltou e voltou por vários dias, com os ânimos aumentando rapidamente.

Finalmente, nós os reunimos na mesma sala. O testador selecionou a ferramenta de pincel e pintou um golpe no canto superior direito até o canto inferior esquerdo. O aplicativo explodiu. "Oh", disse o programador, em uma pequena voz, que então admitiu timidamente que havia feito traços de teste apenas do canto inferior esquerdo para o canto superior direito, o que não expôs o bug.

Há dois pontos nesta história:

Pode ser necessário entrevistar o usuário que relatou o bug para coletar mais dados do que você foi fornecido inicialmente.



Testes artificiais (como a pincelada única do programador de baixo para cima) não exercem um aplicativo suficiente. Você deve testar brutalmente as condições de contorno e os padrões realistas de uso do usuário final. Você precisa fazer isso sistematicamente (consulte testes cruéis e contínuos).





Estratégias de depuração


Depois de pensar que sabe o que está acontecendo, é hora de descobrir o que o programa pensa que está acontecendo.





Reproduzindo bugs


Não, nossos bugs não estão realmente se multiplicando (embora alguns deles provavelmente tenham idade suficiente para fazê -lo legalmente). Estamos falando de um tipo diferente de reprodução.

A melhor maneira de começar a corrigir um bug é torná -lo reproduzível. Afinal, se você não pode reproduzi -lo, como saberá se já foi corrigido?

Mas queremos mais do que um bug que pode ser reproduzido seguindo algumas longas séries de etapas; Queremos um bug que possa ser reproduzido com um único comando. É muito mais difícil corrigir um bug se você precisar seguir 15 etapas para chegar ao ponto em que o bug aparece.

Então, aqui está a regra mais importante de depuração:

Dica 31 Teste de falha antes de corrigir o código



Às vezes, forçando -se a isolar as circunstâncias que exibem o bug, você ainda obtém uma visão de como corrigi -lo. O ato de escrever o teste informa a solução.





Codificador em uma terra estranha


Toda essa conversa sobre o isolamento do bug é boa, quando se depara com 50.000 linhas de código e um relógio, o que um pobre codificador deve fazer?

Primeiro, veja o problema. É um acidente? É sempre surpreendente quando ensinamos cursos que envolvem a programação de quantos desenvolvedores veem uma exceção aparecer em vermelho e imediatamente procurar no código.

Dica 32 Leia a maldita mensagem de erro



Nuf disse.





Resultados ruins


E se não for um acidente? E se for apenas um resultado ruim?

Entre lá com um depurador e use seu teste de falha para acionar o problema.

Antes de qualquer outra coisa, verifique se você também está vendo o valor incorreto no depurador. Nós dois perdemos horas tentando rastrear um bug apenas para descobrir que essa execução específica do código funcionou bem.

Às vezes, o problema é óbvio: o interesse_rate é 4,5 e deve ser 0,045. Mais frequentemente, você deve parecer mais profundo para descobrir por que o valor está errado em primeiro lugar. Certifique -se de saber como subir e descer a pilha de chamadas e examinar o ambiente de pilha local.

Achamos que muitas vezes ajuda a manter a caneta e o papel por perto, para que possamos anotar as notas. Em particular, geralmente encontramos uma pista e a perseguimos, apenas para descobrir que não deu certo. Se não anoçássemos onde estávamos quando começamos a perseguição, poderíamos perder muito tempo voltando para lá.

Às vezes, você está olhando para um rastreamento de pilha que parece rolar para sempre. Nesse caso, geralmente há uma maneira mais rápida de encontrar o problema do que examinar cada quadro de pilha: use uma costeleta binária. Mas antes de discutirmos isso, vejamos dois outros cenários comuns de insetos.





Sensibilidade aos valores de entrada


Você esteve lá. Seu programa funciona bem com todos os dados do teste e sobrevive à sua primeira semana em produção com honra. Então ele trava de repente quando alimentado um conjunto de dados específico.

Você pode tentar olhar para o local em que trava e trabalha para trás. Mas às vezes é mais fácil começar com os dados. Obtenha uma cópia do conjunto de dados e alimente -o através de uma cópia em execução localmente do aplicativo, certificando -se de que ele ainda trava. Em seguida, corte os dados binários até que você isole exatamente quais valores de entrada estão levando ao acidente.





Regressões entre lançamentos


Você está em uma boa equipe e libera seu software em produção. Em algum momento, um inseto aparece em
código que funcionou bem há uma semana. Não seria bom se você pudesse identificar a mudança específica que a introduziu? Adivinha? Tempo binário de corte.





A costeleta binária


Cada estudante de graduação do CS foi forçada a codificar uma costeleta binária (às vezes chamada de pesquisa binária). A ideia é simples. Você está procurando um valor específico em uma matriz classificada. Você pode apenas olhar para cada valor por sua vez, mas acaba olhando para aproximadamente metade das entradas, em média, até encontrar o valor que desejou ou encontrou um valor maior que ele, o que significaria que o valor não está na matriz.

Mas é mais rápido usar uma abordagem de divisão e conquista. Escolha um valor no meio da matriz. Se for o que você está procurando, pare. Caso contrário, você pode cortar a matriz em dois. Se o valor encontrado for maior que o alvo, você sabe que ele deve estar na primeira metade da matriz, caso contrário, será no segundo tempo. Repita o procedimento no subarray apropriado e, em pouco tempo, você terá um resultado. (Como veremos quando falamos sobre a notação Big-O, é uma pesquisa linear e uma costeleta binária é).

Portanto, a costeleta binária é muito mais rápida em qualquer problema de tamanho decente. Vamos ver como aplicá -lo na depuração.

Quando você está enfrentando um enorme stacktrace e está tentando descobrir exatamente qual função mutilou o valor em erro, você faz um corte escolhendo um quadro de pilha em algum lugar do meio e vendo se o erro é manifesto lá. Se for, você saberá se concentrar nos quadros antes, caso contrário, o problema estará nos quadros depois. Pique novamente. Mesmo se você tiver 64 quadros no Stacktrace, essa abordagem fornecerá uma resposta depois de no máximo seis tentativas.

Se você encontrar bugs que aparecem em determinados conjuntos de dados, poderá fazer a mesma coisa. Divida o conjunto de dados em dois e veja se o problema ocorre se você alimentar um ou outro através do aplicativo. Continue dividindo os dados até obter um conjunto mínimo de valores que exibem o problema.

Se sua equipe introduziu um bug durante um conjunto de lançamentos, você poderá usar o mesmo tipo de técnica. Crie um teste que faça com que a liberação atual falhe. Em seguida, escolha um lançamento metade do caminho entre agora e a última versão de trabalho conhecida. Execute o teste novamente e decida como restringir sua pesquisa. Ser capaz de fazer isso é apenas um dos muitos benefícios de ter um bom controle de versão em seus projetos. De fato, muitos sistemas de controle de versão levarão isso adiante e automatizarão o processo, escolhendo versões para você, dependendo do resultado do teste.





Registro e/ou rastreamento


Debuggers geralmente se concentram no estado do programa agora. Às vezes, você precisa de mais - você precisa assistir ao estado de um programa ou estrutura de dados ao longo do tempo. Ver um rastreamento de pilha só pode dizer como você chegou diretamente aqui. Normalmente, não pode dizer o que você estava fazendo antes dessa cadeia de chamadas, especialmente em sistemas baseados em eventos. [25]

As declarações de rastreamento são aquelas pequenas mensagens de diagnóstico que você imprime na tela ou em um arquivo que dizem coisas como "Get aqui" e "Valor de x = 2". É uma técnica primitiva em comparação com os depuradores no estilo IDE, mas é particularmente eficaz no diagnóstico de várias classes de erros que os depuradores não podem. O rastreamento é inestimável em qualquer sistema em que o tempo em si seja um fator: processos simultâneos, sistemas em tempo real e aplicativos baseados em eventos.

Você pode usar instruções de rastreamento para perfurar o código. Ou seja, você pode adicionar declarações de rastreamento ao descer a árvore de chamadas.

As mensagens de rastreamento devem estar em um formato regular e consistente, pois você pode analisá -las automaticamente. Por exemplo, se você precisava rastrear um vazamento de recursos (como o arquivo desequilibrado abre/fecha), você pode rastrear cada um aberto e cada um fechado em um arquivo de log. Ao processar o arquivo de log com ferramentas de processamento de texto ou comandos de shell, você pode identificar facilmente onde o aberto ofensivo estava ocorrendo.





Borracha se esquivando


Uma técnica muito simples, mas particularmente útil, para encontrar a causa de um problema, é simplesmente explicá -la a outra pessoa. A outra pessoa deve olhar por cima do ombro na tela e acenar com a cabeça constantemente (como um pato de borracha balançando para cima e para baixo em uma banheira). Eles não precisam dizer uma palavra; O simples ato de explicar, passo a passo, o que o código deve fazer geralmente faz com que o problema salte da tela e se anuncia. [26]

Parece simples, mas, ao explicar o problema para outra pessoa, você deve declarar explicitamente as coisas que você pode dar como certo ao passar pelo código. Tendo que verbalizar alguns deles
Suposições, de repente você pode obter uma nova visão do problema. E se você não tem uma pessoa, um pato de borracha ou ursinho de pelúcia, ou em vaso a planta. [27]





Processo de eliminação


Na maioria dos projetos, o código que você está depuração pode ser uma mistura de código de aplicativo escrito por você e outras pessoas em sua equipe de projeto, produtos de terceiros (banco de dados, conectividade, estrutura da web, comunicações ou algoritmos especializados e assim por diante) e o ambiente da plataforma (sistema operacional, bibliotecas de sistemas e compiladores).

É possível que exista um bug no sistema operacional, no compilador ou em um produto de terceiros-mas esse não deve ser o seu primeiro pensamento. É muito mais provável que o bug exista no código do aplicativo em desenvolvimento. Geralmente, é mais lucrativo supor que o código do aplicativo está entrando incorretamente em uma biblioteca do que assumir que a própria biblioteca está quebrada. Mesmo que o problema esteja com terceiros, você ainda precisará eliminar seu código antes de enviar o relatório de bug.

Trabalhamos em um projeto em que um engenheiro sênior estava convencido de que a chamada do sistema selecionada foi quebrada em um sistema UNIX. Nenhuma quantidade de persuasão ou lógica poderia mudar de idéia (o fato de que qualquer outro aplicativo de rede na caixa funcionou bem era irrelevante). Ele passou semanas escrevendo soluções alternativas, o que, por algum motivo estranho, não parecia resolver o problema. Quando finalmente forçado a sentar e ler a documentação em Select, ele descobriu o problema e o corrigiu em questão de minutos. Agora usamos a frase "Select está quebrada" como um lembrete suave sempre que um de nós começa a culpar o sistema por uma falha que provavelmente será nossa.

Dica 33 "Selecionar" não está quebrada



Lembre -se, se você vir impressão de casco, pense em cavalos - não zebras. O sistema operacional provavelmente não está quebrado. E selecionar provavelmente está bem.

Se você "mudou apenas uma coisa" e o sistema parou de funcionar, é provável que uma coisa seja responsável, direta ou indiretamente, não importa o quão exagerado pareça. Às vezes, o que mudou está fora do seu controle: novas versões do sistema operacional, o BOETUROND, o BOETS RETROTS, ou outro software de terceiros pode que os bugs de uso. mudanças;





O elemento de surpresa


Quando você se surpreende com um bug (talvez até murmurando "isso é impossível", na sua respiração, onde não podemos ouvi -lo), você deve reavaliar as verdades que você tem caro. Nesse algoritmo de cálculo de desconto - aquele que você conhecia era à prova de balas e não poderia ser a causa desse bug - você testou todas as condições de contorno? Esse outro código que você está usando há anos - ainda não poderia ter um bug. Poderia?

Claro que pode. A quantidade de surpresa que você sente quando algo dá errado é proporcional à quantidade de confiança e fé que você tem no código que está sendo executado. É por isso que, quando confrontado com um fracasso "surpreendente", você deve aceitar que uma ou mais de suas suposições estejam erradas. Não encomende uma rotina ou um código envolvido no bug porque você "sabe" que funciona. Prove. Prove -o nesse contexto, com esses dados, com essas condições de limite.

Dica 34 Não assuma isso - forneça



Quando você se depara com um bug surpresa, além de apenas corrigi -lo, precisa determinar por que essa falha não foi pega mais cedo. Considere se você precisa alterar a unidade ou outros testes para que eles o tenham pego.

Além disso, se o bug for o resultado de dados ruins que foram propagados através de alguns níveis antes de causar a explosão, veja se a melhor verificação de parâmetros nessas rotinas o isolaria anteriormente (consulte as discussões sobre travamento cedo e afirmações aqui e aqui, respectivamente).

Enquanto você está nisso, existem outros lugares no código que podem ser suscetíveis a esse mesmo bug? Agora é a hora de encontrá -los e consertá -los. Certifique -se de que o que acontecesse, você saberá se isso acontecer novamente.

Se demorou muito tempo para corrigir esse bug, pergunte a si mesmo. Há algo que você possa fazer para facilitar a fixação desse bug na próxima vez? Talvez você possa criar melhores ganchos de teste ou escrever um analisador de arquivos de log.

Finalmente, se o bug for o resultado da suposição errada de alguém, discuta o problema com o todo
Equipe: Se uma pessoa entende mal, é possível que muitas pessoas o façam.

Faça tudo isso e espero que você não fique surpreso na próxima vez.





Lista de verificação de depuração


O problema é relatado como resultado direto do bug subjacente, ou apenas um sintoma?



O bug está realmente na estrutura que você está usando? Está no sistema operacional? Ou está no seu código?



Se você explicasse esse problema em detalhes a um colega de trabalho, o que você diria?



Se o código suspeito passar em seus testes de unidade, os testes serão completos o suficiente? O que acontece se você executar os testes com esses dados?



As condições que causaram esse bug existem em qualquer outro lugar do sistema? Ainda existem outros bugs no estágio larval, apenas esperando para eclodir?





Seções relacionadas incluem


Tópico 24, programas mortos não contam mentiras





Desafios


A depuração é um desafio o suficiente.





Tópico 21

Manipulação de texto




Programadores pragmáticos manipulam o texto da mesma maneira que os trabalhadores de madeira moldam madeira. Nas seções anteriores, discutimos algumas ferramentas específicas - cascas, editores, depuradores - que usamos. Estes são semelhantes aos formadores, serras e aviões de um trabalhador de madeira - ferramentas especializadas para fazer bem um ou dois empregos. No entanto, de vez em quando precisamos executar alguma transformação não prontamente tratada pelo conjunto de ferramentas básicas. Precisamos de uma ferramenta de manipulação de texto de uso geral.

As linguagens de manipulação de texto devem programar o que os roteadores [28] são para trabalhar madeira. Eles são barulhentos, bagunçados e um tanto brutos. Começa erros com eles, e peças inteiras podem ser arruinadas. Algumas pessoas juram que não têm lugar na caixa de ferramentas. Mas nas mãos certas, os roteadores e as linguagens de manipulação de texto podem ser incrivelmente poderosas e versáteis. Você pode aparar rapidamente algo em forma, fazer articulações e esculpir. Usados corretamente, essas ferramentas têm uma delicadeza e sutileza surpreendente. Mas eles levam tempo para dominar.

Felizmente, existem várias ótimas linguagens de manipulação de texto. Os desenvolvedores da UNIX (e incluímos usuários do MacOS aqui) geralmente gostam de usar o poder de seus shells de comando, aumentados com ferramentas como awk e sed. As pessoas que preferem uma ferramenta mais estruturada podem preferir idiomas como Python ou Ruby.

Esses idiomas são importantes tecnologias de habilitação. Usando -os, você pode invadir rapidamente os utilitários e as idéias de protótipo - jobs que podem levar cinco ou dez vezes mais tempo usando idiomas convencionais. E esse fator de multiplicação é crucialmente importante para o tipo de experimentação que fazemos. Passar 30 minutos experimentando uma idéia maluca é muito melhor do que passar cinco horas. Passar um dia automatizando componentes importantes de um projeto é aceitável; Passar uma semana pode não ser. Em seu livro The Practice of Programming [KP99], Kernighan e Pike construíram o mesmo programa em cinco idiomas diferentes. A versão Perl foi a mais curta (17 linhas, em comparação com os 150 de C). Com o Perl, você pode manipular texto, interagir com programas, conversar sobre redes, dirigir páginas da web, executar aritmética de precisão arbitrária e escrever programas que parecem jusos bisbilhotivos.

Dica 35 Aprenda uma linguagem de manipulação de texto



Para mostrar a ampla aplicabilidade das linguagens de manipulação de texto, aqui está uma amostra de algumas coisas que fizemos com Ruby e Python relacionados à criação deste livro:

Construindo o livro

O sistema de construção para a estante pragmática é escrito em Ruby. Autores, editores, pessoas de layout e apoio às pessoas usam tarefas de rake para coordenar a construção de PDFs e eBooks.



Inclusão de código e destaque

Achamos que é importante que qualquer código apresentado em um livro tenha sido testado primeiro. A maior parte do código deste livro foi. No entanto, usando o princípio seco (ver tópico 9, seco - os males da duplicação), não queríamos copiar e colar linhas de código dos programas testados no livro. Isso significaria que estaríamos duplicando o código, praticamente garantindo que esqueceremos de atualizar um exemplo quando o programa correspondente foi alterado. Para alguns exemplos, também não queríamos aborrecê -lo com todo o código da estrutura necessário para fazer nosso exemplo compilar e executar. Nos viramos para Ruby. Um script relativamente simples é chamado quando formatamos o livro - extrai um segmento nomeado de um arquivo de origem, faz destaque da sintaxe e converte o resultado no idioma do tipoTenting que usamos.



Atualização do site

Temos um script simples que faz uma criação de livros parciais, extrai o índice e depois o carrega para a página do livro em nosso site. Também temos um script que extrai seções de um livro e as carrega como amostras.



Incluindo equações

Há um script python
que converte a marcação matemática do látex em texto bem formatado.



Geração de índice

A maioria dos índices é criada como documentos separados (o que dificulta a manutenção deles se um documento mudar). O nosso é marcado no próprio texto, e um script rubi coloca e formata as entradas.





E assim por diante. De uma maneira muito real, a estante pragmática é construída em torno da manipulação de texto. E se você seguir nosso conselho para manter as coisas em texto simples, o uso desses idiomas para manipular esse texto trará uma série de benefícios.





Seções relacionadas incluem


Tópico 16, o poder do texto simples

Tópico 17, jogos de shell





Exercícios


Exercício 11

Você está reescrevendo um aplicativo que costumava usar a YAML como uma linguagem de configuração. Sua empresa agora se padronizou no JSON, então você tem um monte de arquivos .yaml que precisam ser transformados em .json. Escreva um script que pegue um diretório e converte cada arquivo .yaml em um arquivo .json correspondente (então o banco de dados.yaml se torna database.json, e o conteúdo é válido JSON).

Exercício 12

Sua equipe inicialmente optou por usar nomes de camelcase para variáveis, mas depois mudou a mente coletiva e mudou para Snake_Case. Escreva um script que digitalize todos os arquivos de origem em busca de nomes e relatórios de camelcase.

Exercício 13

Seguindo o exercício anterior, adicione a capacidade de alterar esses nomes de variáveis automaticamente em um ou mais arquivos. Lembre -se de manter um backup dos originais, caso algo dê terrivelmente, terrivelmente errado.





Tópico 22

Daybooks de engenharia




Dave trabalhou uma vez para um pequeno fabricante de computadores, o que significava trabalhar ao lado de engenheiros eletrônicos e às vezes mecânicos.

Muitos deles andavam com um caderno de papel, normalmente com uma caneta enfiada na coluna. De vez em quando, quando estávamos conversando, eles abriam o caderno e rabiscariam alguma coisa.

Eventualmente, Dave fez a pergunta óbvia. Aconteceu que eles foram treinados para manter um dia de engenharia, uma espécie de diário em que registraram o que fizeram, coisas que aprenderam, esboços de idéias, leituras de medidores: basicamente qualquer coisa a ver com seu trabalho. Quando o caderno ficou cheio, eles escrevem o intervalo de data na coluna vertebral e depois o colocavam na prateleira ao lado dos diários anteriores. Pode ter havido uma concorrência gentil, para cujo conjunto de livros ocupou o espaço mais prateado.

Utilizamos diários para fazer anotações em reuniões, para anotar o que estamos trabalhando, para observar valores variáveis ao depurar, deixar lembretes onde colocamos as coisas, para gravar idéias selvagens e, às vezes, apenas para rabiscar. [29]

O diário tem três benefícios principais:

É mais confiável que a memória. As pessoas podem perguntar: “Qual era o nome daquela empresa que você ligou na semana passada sobre o problema da fonte de alimentação?” E você pode voltar uma página ou mais e dar o nome e o número.



Ele oferece um lugar para armazenar idéias que não são imediatamente relevantes para a tarefa em questão. Dessa forma, você pode continuar se concentrando no que está fazendo, sabendo que a grande ideia não será esquecida.



Ele atua como uma espécie de pato de borracha (descrito aqui). Quando você para para escrever algo, seu cérebro pode trocar de marcha, quase como se converse com alguém - uma grande chance de refletir. Você pode começar a anotar e, de repente, perceber que o que você acabou de fazer, o tópico da nota, está simplesmente errado.





Também há um benefício adicional. De vez em quando, você pode olhar para o que estava fazendo, tão muitos anos-e pensar nas pessoas, nos projetos e nas terríveis roupas e penteados.

Então, tente manter um diário de engenharia. Use papel, não um arquivo ou um wiki: há algo especial no ato de escrever em comparação com a digitação. Dê um mês e veja se você está obtendo algum benefício.

Se nada mais, facilitará a redação de suas memórias quando você é rico e famoso.





Seções relacionadas incluem


Tópico 6, seu portfólio de conhecimento

Tópico 37, ouça seu cérebro de lagarto





Notas de rodapé


[24]

Todo o software se torna software legado assim que estiver escrito.



[25]

Embora o idioma Elm tenha um depurador que viaja no tempo.



[26]

Por que "se esquivar de borracha"?



[27]

Versões anteriores do livro falaram sobre falar com o seu
planta de maconha. Foi um erro de digitação. Honesto.



[28]

Aqui, o roteador significa a ferramenta que gira lâminas de corte muito, muito rápida, não um dispositivo para interconectar redes.



[29]

Há alguma evidência de que o rabiscamento ajuda a focar e melhora as habilidades cognitivas, por exemplo, veja o que o Doodling faz? [E10].





Copyright © 2020 Pearson Education, Inc.





Capítulo 4



Paranóia pragmática




Dica 36 Você não pode escrever software perfeito



Isso doeu? Não deveria. Aceite -o como um axioma da vida. Abraçá -lo. Comemore. Porque o software perfeito não existe. Ninguém na breve história da computação já escreveu um pedaço de software perfeito. É improvável que você seja o primeiro. E, a menos que você aceite isso como um fato, acabará perdendo tempo e energia perseguindo um sonho impossível.

Então, dada essa realidade deprimente, como um programador pragmático a transforma em uma vantagem? Esse é o tópico deste capítulo.

Todo mundo sabe que eles pessoalmente são o único bom motorista na Terra. O resto do mundo está lá fora para obtê -los, soprando com sinais de parada, tecendo entre faixas, não indicando curvas, mensagens de texto no telefone e geralmente não cumpriam nossos padrões. Então dirigimos defensivamente. Apresentamos problemas antes que isso aconteça, antecipamos o inesperado e nunca nos colocamos em uma posição da qual não podemos nos libertar.

A analogia com a codificação é bastante óbvia. Estamos constantemente interagindo com o código de outras pessoas - código que pode não cumprir nossos altos padrões - e lidar com insumos que podem ou não ser válidos. Então, somos ensinados a codificar defensivamente. Se houver alguma dúvida, validamos todas as informações que recebemos. Utilizamos afirmações para detectar dados ruins e desconfiar de dados de possíveis atacantes ou trolls. Verificamos a consistência, colocamos restrições nas colunas do banco de dados e geralmente nos sentimos muito bem consigo mesmos.

Mas os programadores pragmáticos dão um passo adiante. Eles também não confiam em si mesmos. Sabendo que ninguém escreve código perfeito, inclusive eles mesmos, programadores pragmáticos constroem em defesas contra seus próprios erros. Descrevemos a primeira medida defensiva no tópico 23, projeto por contrato: clientes e fornecedores devem concordar com direitos e responsabilidades.

No tópico 24, os programas mortos não têm mentiras, queremos garantir que não causamos danos enquanto trabalhamos os bugs. Por isso, tentamos verificar as coisas com frequência e encerrar o programa se as coisas dão errado.

Tópico 25, a programação assertiva descreve um método fácil de verificar ao longo do caminho - escreva código que verifica ativamente suas suposições.

À medida que seus programas ficam mais dinâmicos, você se encontrará malabarismos com os recursos do sistema - memória, arquivos, dispositivos e similares. No tópico 26, como equilibrar recursos, sugerimos maneiras de garantir que você não solte nenhuma das bolas.

E o mais importante é que sempre aderimos a pequenos passos, conforme descrito no tópico 27, não supere seus faróis, para que não caímos na borda do penhasco.

Em um mundo de sistemas imperfeitos, escalas de tempo ridículas, ferramentas risíveis e requisitos impossíveis, vamos jogar com segurança. Como Woody Allen disse: "Quando todo mundo realmente quer pegá -lo, a paranóia é apenas um bom pensamento".





Tópico 23

Projeto por contrato




Nada surpreende tanto os homens quanto o bom senso e o acordo simples.



Ralph Waldo Emerson, ensaios



Lidar com sistemas de computador é difícil. Lidar com as pessoas é ainda mais difícil. Mas, como espécie, tivemos mais tempo para descobrir questões de interações humanas. Algumas das soluções que criamos durante os últimos milênios também podem ser aplicadas ao software de redação. Uma das melhores soluções para garantir a negociação simples é o contrato.

Um contrato define seus direitos e responsabilidades, bem como os da outra parte. Além disso, há um acordo sobre repercussões se uma das partes não cumprir o contrato.

Talvez você tenha um contrato de trabalho que especifique as horas em que trabalhará e as regras de conduta que você deve seguir. Em troca, a empresa paga um salário e outras vantagens. Cada parte cumpre suas obrigações e todos se beneficiam.

É uma ideia usada em todo o mundo - formal e informalmente - para ajudar os seres humanos a interagir. Podemos usar o mesmo conceito para ajudar os módulos de software a interagir? A resposta é "sim".





DBC


Bertrand Meyer (construção de software orientada a objetos [MEY97]) desenvolveu o conceito de design por contrato para o idioma eiffel. [30] É uma técnica simples e poderosa que se concentra em documentar (e concordar com) os direitos e
Responsabilidades dos módulos de software para garantir a correção do programa. O que é um programa correto? Um que não faz mais e nada menos do que afirma fazer. Documentar e verificar se a reivindicação é o coração do design por contrato (DBC, para abreviar).

Toda função e método em um sistema de software faz algo. Antes de começar, algo, a função pode ter alguma expectativa do estado do mundo, e pode ser capaz de fazer uma declaração sobre o estado do mundo quando concluir. Meyer descreve essas expectativas e reivindicações da seguinte forma:

Pré -condições

O que deve ser verdadeiro para que a rotina seja chamada; os requisitos da rotina. Uma rotina nunca deve ser chamada quando suas pré -condições seriam violadas. É responsabilidade do chamador passar bons dados (consulte a caixa aqui).



PostConditions

O que a rotina é garantida; o estado do mundo quando a rotina é feita. O fato de a rotina ter uma condição pós -condição implica que ela concluirá: os loops infinitos não são permitidos.



Invariantes de classe

Uma classe garante que essa condição seja sempre verdadeira da perspectiva de um chamador. Durante o processamento interno de uma rotina, o invariante não pode se manter, mas quando a rotina sai e o controle retorna ao chamador, o invariante deve ser verdadeiro. (Observe que uma classe não pode dar um acesso irrestrito a qualquer membro de dados que participe do invariante.)





O contrato entre uma rotina e qualquer chamador em potencial pode ser lido como

Se todas as pré -condições da rotina forem atendidas pelo chamador, a rotina garantirá que todas as ações e invariantes pós -condicionais sejam verdadeiros quando for concluído.



Se qualquer uma das partes não cumprir os termos do contrato, um remédio (que foi acordado anteriormente) será invocado - talvez seja levantada uma exceção ou o programa termina. Aconteça o que acontecer, não se engane com o fato de a falta de cumprir o contrato é um bug. Não é algo que nunca aconteça, e é por isso que as pré-condições não devem ser usadas para executar coisas como a validação de entrada do usuário.

Alguns idiomas têm melhor suporte para esses conceitos do que outros. O Clojure, por exemplo, suporta pré e pós-condições, bem como a instrumentação mais abrangente fornecida pelas especificações. Aqui está um exemplo de uma função bancária para fazer um depósito usando simples pré e pós-condicionas:

(Defn aceita-depositar [valor da conta-ID]

{: Pré [(> Valor 0,00)

(Conta-abertura? ID da conta)]]

: Post [(contém? (Conta-transações da conta-id) %)]}

"Aceite um depósito e devolva o novo ID da transação"

;; Algum outro processamento vai aqui ...

;; Retorne a transação recém -criada:

(Create-Transaction Account-ID: valor do depósito))))



Existem duas condições prévias para a função de depósito de aceitação. A primeira é que o valor é maior que zero e o segundo é que a conta é aberta e válida, conforme determinado por alguma função denominada conta-abertura?. Há também uma condição pós -condição: a função garante que a nova transação (o valor de retorno dessa função, representado aqui por '%') pode ser encontrado entre as transações para esta conta.

Se você ligar para aceitar depositar com uma quantidade positiva para o depósito e uma conta válida, ele continuará a criar uma transação do tipo apropriado e fazer qualquer outro processamento que ele fizer. No entanto, se houver um bug no programa e você, de alguma forma, passou em uma quantidade negativa para o depósito, você terá uma exceção de tempo de execução:

Exceção no tópico "Main" ...

Causado por: java.lang.assertionError: assert falhou: (> Valor 0.0)



Da mesma forma, essa função exige que a conta especificada seja aberta e válida. Caso contrário, você verá essa exceção:

Exceção no tópico "Main" ...

Causado por: java.lang.assertionError: assert falhou: (conta-abertura? ID da conta)



Outros idiomas têm recursos que, embora não sejam específicos do DBC, ainda podem ser usados com um bom efeito. Por exemplo, o Elixir usa cláusulas de guarda para despachar chamadas de funções contra vários órgãos disponíveis:

Depósitos de Defmodule fazem

Def aceit_deposit (account_id, quantidade) quando (quantidade> 100000)

# Ligue para o gerente!

Fim

Def aceit_deposit (account_id, quantidade) quando (quantidade> 10000)

# Requisitos federais extras para relatórios

# Algum processamento ...

Fim

Def aceit_deposit (account_id, quantidade) quando (quantidade> 0)

# Algum processamento ...

Fim

Fim



Nesse caso, chamar aceita_deposit com uma quantidade grande o suficiente pode desencadear etapas adicionais e
processamento. Tente chamá -lo com uma quantidade menor ou igual a zero, no entanto, e você terá uma exceção informando que não pode:

** (FunctionCauseError) Nenhuma cláusula de função correspondente em depósitos.accept_deposit/2



Esta é uma abordagem melhor do que simplesmente verificar suas entradas; Nesse caso, você simplesmente não pode chamar essa função se seus argumentos estiverem fora de intervalo.

Dica 37 Projeto com contratos



No tópico 10, Ortogonalidade, recomendamos a redação do código "tímido". Aqui, a ênfase está no código "preguiçoso": seja rigoroso no que você aceitará antes de começar e prometa o mínimo possível em troca. Lembre -se, se o seu contrato indicar que você aceitará qualquer coisa e promete ao mundo em troca, você terá muito código para escrever!

Em qualquer linguagem de programação, seja funcional, orientada a objetos ou processual, o DBC o obriga a pensar.


DBC e desenvolvimento orientado a testes

O design é o contrato necessário em um mundo em que os desenvolvedores praticam testes de unidade, desenvolvimento orientado a testes (TDD), testes baseados em propriedades ou programação defensiva?

A resposta curta é "sim".

DBC e testes são abordagens diferentes para o tópico mais amplo da correção do programa. Ambos têm valor e ambos têm usos em diferentes situações. O DBC oferece várias vantagens sobre abordagens de testes específicas:

O DBC não requer nenhuma configuração ou zombaria



O DBC define os parâmetros para o sucesso ou falha em todos os casos, enquanto os testes só podem direcionar um caso específico por vez



O TDD e outros testes acontecem apenas em "Teste" dentro do ciclo de construção. Mas o DBC e as afirmações são para sempre: durante o design, desenvolvimento, implantação e manutenção



O TDD não se concentra em verificar invariantes internos dentro do código em teste, é mais estilo de caixa preta para verificar a interface pública



O DBC é mais eficiente (e seco) do que a programação defensiva, onde todos precisam validar dados caso ninguém mais o faça.





O TDD é uma ótima técnica, mas, como em muitas técnicas, pode convidá -lo a se concentrar no "caminho feliz" e não no mundo real cheio de dados ruins, maus atores, versões ruins e especificações ruins.





Invariantes de classe e idiomas funcionais


É uma coisa de nomeação. Eiffel é uma linguagem orientada a objetos, então Meyer nomeou essa ideia de "invariável da classe". Mas, realmente, é mais geral do que isso. O que essa ideia realmente se refere é o estado. Em uma linguagem orientada a objetos, o estado está associado a instâncias de classes. Mas outros idiomas também têm estado.

Em um idioma funcional, você normalmente passa o estado para funções e recebe estado atualizado como resultado. Os conceitos de invariantes são igualmente úteis nessas circunstâncias.





Implementando DBC


Simplesmente enumerando qual é o intervalo de domínio de entrada, quais são as condições de contorno e o que a rotina promete entregar - ou, mais importante, o que ele não promete ser entregue - antes que você escreva o código seja um grande salto para escrever um software melhor. Ao não declarar essas coisas, você está de volta à programação por coincidência (veja a discussão aqui), que é onde muitos projetos começam, terminam e falham.

Em idiomas que não suportam o DBC no código, isso pode ser o mais longe possível - e isso não é tão ruim. Afinal, o DBC é uma técnica de design. Mesmo sem verificação automática, você pode colocar o contrato no código como comentários ou nos testes de unidade e ainda obter um benefício muito real.





Afirmações


Embora a documentação dessas suposições seja um ótimo começo, você pode obter um benefício muito maior ao fazer o compilador verificar seu contrato para você. Você pode imitar parcialmente isso em alguns idiomas usando asserções: verificações de tempo de execução de condições lógicas (consulte o tópico 25, programação assertiva). Por que apenas parcialmente? Você não pode usar as afirmações para fazer tudo o que o DBC pode fazer?

Infelizmente, a resposta é não. Para começar, em idiomas orientados a objetos, provavelmente não há suporte para propagar afirmações em uma hierarquia de herança. Isso significa que, se você substituir um método de classe base que possui um contrato, as afirmações que implementam esse contrato não serão chamadas corretamente (a menos que você as duplique manualmente no novo código). Você deve se lembrar de chamar o invariante da classe (e todos os invariantes da classe base) manualmente antes de sair de todos os métodos. O problema básico é que o contrato não é aplicado automaticamente.

Em outros ambientes, as exceções geradas a partir de afirmações no estilo DBC podem ser desligadas globalmente ou ignoradas no código.

Além disso, não há conceito interno de valores "antigos"; ou seja, valores como eles
existia na entrada de um método. Se você estiver usando afirmações para aplicar contratos, deverá adicionar código à pré -condição para salvar qualquer informação que você deseja usar na condição pós -condição, se o idioma permitir isso. Na língua Eiffel, onde o DBC nasceu, você pode apenas usar a expressão antiga.

Por fim, os sistemas e bibliotecas de tempo de execução convencionais não foram projetados para suportar contratos, portanto essas chamadas não são verificadas. Essa é uma grande perda, porque geralmente está na fronteira entre o seu código e as bibliotecas que ele usa que o maior número de problemas é detectado (ver tópico 24, programas mortos não contem a mentira para uma discussão mais detalhada).


Quem é responsável?

Quem é responsável por verificar a pré -condição, o chamador ou a rotina sendo chamada? Quando implementado como parte do idioma, a resposta não é: a pré -condição é testada nos bastidores depois que o chamador invoca a rotina, mas antes que a própria rotina seja inserida. Portanto, se houver alguma verificação explícita dos parâmetros a serem feitos, deve ser realizado pelo chamador, porque a rotina em si nunca verá parâmetros que violam sua pré -condição. (Para idiomas sem suporte integrado, você precisaria entregar a rotina chamada com um preâmbulo e/ou pós-América que verifica essas afirmações.)

Considere um programa que lê um número do console, calcula sua raiz quadrada (chamando SQRT) e imprime o resultado. A função SQRT tem uma pré -condição - seu argumento não deve ser negativo. Se o usuário inserir um número negativo no console, cabe ao código de chamada para garantir que nunca seja passado para o SQRT. Esse código de chamada tem muitas opções: ele pode rescindir, pode emitir um aviso e ler outro número, ou pode tornar o número positivo e anexar um i ao resultado retornado pelo SQRT. Seja qual for a sua escolha, isso definitivamente não é o problema do SQRT.

Ao expressar o domínio da função raiz quadrada na pré -condição da rotina SQRT, você muda o ônus da correção para o chamador - onde ela pertence. Em seguida, você pode projetar a rotina SQRT segura, sabendo que sua entrada estará no intervalo.





DBC e travando cedo


O DBC se encaixa muito bem com o nosso conceito de colidir cedo (ver tópico 24, programas mortos não contam mentiras). Ao usar um mecanismo assert ou DBC para validar as pré -condições, pós -condicionas e invariantes, você pode travar mais cedo e relatar informações mais precisas sobre o problema.

Por exemplo, suponha que você tenha um método que calcule raízes quadradas. Ele precisa de uma pré -condição do DBC que restrinja o domínio a números positivos. Nos idiomas que suportam o DBC, se você passar por um parâmetro negativo, você receberá um erro informativo, como SQRT_ARG_MUST_BE_POSITIVE, juntamente com um rastreamento de pilha.

Isso é melhor do que a alternativa em outros idiomas, como Java, C e C ++, onde passar um número negativo para o SQRT retorna a nan de valor especial (não um número). Pode demorar algum tempo mais tarde no programa que você tenta fazer alguma matemática na NAN, com resultados surpreendentes.

É muito mais fácil encontrar e diagnosticar o problema travando cedo, no local do problema.





Invariantes semânticos


Você pode usar invariantes semânticos para expressar requisitos invioláveis, uma espécie de "contrato filosófico".

Uma vez, escrevemos um interruptor de transação de cartão de débito. Um grande requisito era que o usuário de um cartão de débito nunca tenha a mesma transação aplicada à sua conta duas vezes. Em outras palavras, não importa que tipo de modo de falha possa acontecer, o erro deve estar do lado de não processar uma transação em vez de processar uma transação duplicada.

Essa lei simples, dirigida diretamente dos requisitos, provou ser muito útil para classificar cenários complexos de recuperação de erros e guiou o design e a implementação detalhados em muitas áreas.

Certifique -se de não confundir requisitos fixos, as leis invioladas com aquelas que são meramente políticas que podem mudar com um novo regime de gerenciamento. É por isso que usamos o termo invariante semântico - deve ser central para o próprio significado de uma coisa e não estar sujeito aos caprichos da política (e é para isso que servem as regras de negócios dinâmicas).

Quando você encontrar um requisito que se qualifique, verifique se ela se torna uma parte bem conhecida de qualquer documentação que você esteja produzindo-seja uma lista de marcadores no documento de requisitos que é assinado em triplicado ou apenas uma grande nota no quadro branco comum que todos vêem. Tente declarar isso de forma clara e inequívoca. Por exemplo, no exemplo do cartão de débito, podemos escrever

Errar
a favor do consumidor.



Esta é uma declaração clara, concisa e inequívoca aplicável em muitas áreas diferentes do sistema. É o nosso contrato com todos os usuários do sistema, nossa garantia de comportamento.





Contratos e agentes dinâmicos


Até agora, conversamos sobre contratos como especificações imutáveis e fixas. Mas no cenário de agentes autônomos, esse não precisa ser o caso. Pela definição de "agentes autônomos", os agentes são livres para rejeitar os pedidos de que não querem honrar. Eles são livres para renegociar o contrato - "Não posso fornecer isso, mas se você me der isso, posso fornecer outra coisa".

Certamente qualquer sistema que depende da tecnologia de agentes tem uma dependência crítica de acordos contratuais - mesmo que sejam gerados dinamicamente.

Imagine: com componentes e agentes suficientes que podem negociar seus próprios contratos entre si para atingir uma meta, podemos apenas resolver a crise da produtividade do software, permitindo que o software a resolva.

Mas se não pudermos usar contratos manualmente, não poderemos usá -los automaticamente. Então, da próxima vez que você projetar um software, projete seu contrato também.





Seções relacionadas incluem


Tópico 24, programas mortos não contam mentiras

Tópico 25, programação assertiva

Tópico 38, Programação por coincidência

Tópico 42, teste baseado em propriedades

Tópico 43, fique seguro lá fora

Tópico 45, o poço de requisitos





Desafios


Pontos a ponderar: se o DBC é tão poderoso, por que não é usado mais amplamente? É difícil criar o contrato? Isso faz você pensar em problemas que prefere ignorar agora? Isso o forçará a pensar!? Claramente, esta é uma ferramenta perigosa!





Exercícios


Exercício 14 (resposta possível)

Projete uma interface para um liquidificador de cozinha. Eventualmente, será um liquidificador baseado na Web, habilitado para IoT, mas por enquanto precisamos apenas da interface para controlá-lo. Possui dez configurações de velocidade (0 significa desativado). Você não pode operá -lo vazio e pode alterar a velocidade apenas uma unidade de cada vez (ou seja, de 0 a 1 e de 1 para 2, não de 0 a 2).

Aqui estão os métodos. Adicione as pré e as pós-condicionas apropriadas e um invariante.

Int getspeed ()

Void Setspeed (int x)

Boolean Isfull ()

Vazio preenchimento ()

Vazio vazio ()



Exercício 15 (resposta possível)

Quantos números existem na série 0, 5, 10, 15,…, 100?





Tópico 24

Programas mortos não contam mentiras




Você notou que às vezes outras pessoas podem detectar que as coisas não estão bem com você antes que você esteja ciente do problema? É o mesmo com o código de outras pessoas. Se algo está começando a dar errado com um de nossos programas, às vezes é uma rotina de biblioteca ou estrutura que a captura primeiro. Talvez tenhamos passado um valor nulo ou uma lista vazia. Talvez haja uma chave ausente nesse hash, ou o valor que pensamos que continha um hash realmente contém uma lista. Talvez tenha havido um erro de rede ou erro de arquivos que não pegamos, e temos dados vazios ou corrompidos. Um erro lógico de alguns milhões de instruções atrás significa que o seletor para uma declaração de caso não é mais o 1, 2 ou 3 esperado. Vamos atingir o caso padrão inesperadamente. Essa também é uma das razões pelas quais cada declaração de casos/troca precisa ter uma cláusula padrão: queremos saber quando o "impossível" aconteceu.

É fácil cair na mentalidade "não pode acontecer". A maioria de nós escreveu código que não verificou se um arquivo foi fechado com sucesso ou se uma declaração de rastreio foi escrita como esperávamos. E todas as coisas são iguais, é provável que não precisássemos - o código em questão não falharia sob condições normais. Mas estamos codificando defensivamente. Estamos certificando -se de que os dados sejam o que achamos que é, que o código na produção seja o código que achamos que é. Estamos verificando se as versões corretas das dependências foram realmente carregadas.

Todos os erros fornecem informações. Você pode se convencer de que o erro não pode acontecer e optar por ignorá -lo. Em vez disso, os programadores pragmáticos dizem a si mesmos que, se houver um erro, algo muito, muito ruim aconteceu. Não se esqueça de ler a maldita mensagem de erro (consulte o codificador em uma terra estranha).





Captura e liberação são para peixes


Alguns desenvolvedores acham que é um bom estilo capturar ou resgatar todas as exceções, reiniciando-as depois de escrever algum tipo de mensagem. O código deles está cheio de coisas como essa (onde uma declaração de aumento nua leva a exceção atual):

Tente fazer

Add_score_to_board (pontuação);

Rescue Invalidscore

Logger.error ("Não é possível adicionar pontuação inválida. Exiting");

​
Levantar

BoardServerDown de resgate

Logger.error ("Não é possível adicionar a pontuação: placa está baixa. Saindo");

Levantar

Resgate staletransaction

Logger.error ("Não é possível adicionar pontuação: transação obsoleta. Exiting");

Levantar

Fim



Veja como os programadores pragmáticos escreveriam isso:

Add_score_to_board (pontuação);



Preferimos por dois motivos. Primeiro, o código do aplicativo não é eclipsado pelo manuseio de erros. Segundo, e talvez mais importante, o código é menos acoplado. No exemplo detalhado, precisamos listar todas as exceções que o método add_score_to_board pode aumentar. Se o escritor desse método adicionar outra exceção, nosso código está sutilmente desatualizado. Na segunda versão mais pragmática, a nova exceção é propagada automaticamente.

Dica 38 Crash cedo





Crash, não lixo


Um dos benefícios de detectar problemas o mais rápido possível é que você pode travar mais cedo, e travar geralmente é a melhor coisa que você pode fazer. A alternativa pode ser continuar, escrevendo dados corrompidos em algum banco de dados vital ou comandando a máquina de lavar para o seu vigésimo ciclo de rotação consecutiva.

As línguas Erlang e Elixir abraçam essa filosofia. Joe Armstrong, inventor de Erlang e autor de Programming Erlang: Software para um mundo simultâneo [ARM07], é frequentemente citado como tendo dito: "A programação defensiva é uma perda de tempo. Deixe -o travar!" Nesses ambientes, os programas são projetados para falhar, mas essa falha é gerenciada com supervisores. Um supervisor é responsável por executar o código e sabe o que fazer caso o código falhe, que pode incluir a limpeza após ele, reiniciá -lo e assim por diante. O que acontece quando o próprio supervisor falha? Seu próprio supervisor gerencia esse evento, levando a um design composto por árvores de supervisor. A técnica é muito eficaz e ajuda a explicar o uso desses idiomas em sistemas de alta disponibilidade e tolerantes a falhas.

Em outros ambientes, pode ser inapropriado simplesmente sair de um programa em execução. Você pode ter reivindicado recursos que podem não ser lançados ou pode precisar escrever mensagens de log, arrumar transações abertas ou interagir com outros processos.

No entanto, o princípio básico permanece o mesmo - quando seu código descobrir que algo que deveria ser impossível aconteceu, seu programa não é mais viável. Tudo o que faz a partir deste ponto se torna suspeito, então o encerre o mais rápido possível.

Um programa morto normalmente causa muito menos dano do que um aleijado.





Seções relacionadas incluem


Tópico 20, Depuração

Tópico 23, projeto por contrato

Tópico 25, programação assertiva

Tópico 26, como equilibrar recursos

Tópico 43, fique seguro lá fora





Tópico 25

Programação assertiva




Há um luxo em auto-abordagem. Quando nos culpamos, sentimos que ninguém mais tem o direito de nos culpar.



Oscar Wilde, a foto de Dorian Gray



Parece que há um mantra que todo programador deve memorizar no início de sua carreira. É um princípio fundamental da computação, uma crença central que aprendemos a aplicar a requisitos, projetos, código, comentários, quase tudo o que fazemos. Vai

Isso nunca pode acontecer ...



"Este aplicativo nunca será usado no exterior, então por que internacionalizá -lo?" "A contagem não pode ser negativa." "O registro não pode falhar."

Não vamos praticar esse tipo de auto-engano, principalmente ao codificar.

Dica 39 Use afirmações para impedir o impossível



Sempre que você se vê pensando "mas é claro que isso nunca poderia acontecer", adicione código para verificar. A maneira mais fácil de fazer isso é com as afirmações. Em muitas implementações de idiomas, você encontrará algum tipo de afirmação que verifica uma condição booleana. [31] Essas verificações podem ser inestimáveis. Se um parâmetro ou resultado nunca deve ser nulo, verifique explicitamente:

Assert (resultado! = Nulo);



Na implementação do Java, você pode (e deve) adicionar uma string descritiva:

ASSERT BRILT! = NULL && result.size ()> 0: "Resultado vazio de xyz";



As afirmações também são verificações úteis na operação de um algoritmo. Talvez você tenha escrito um algoritmo inteligente de classificação, chamado my_sort. Verifique se funciona:

Livros = my_sort (encontre ("scifi")))

Assert (is_sorted? (Livros))



Não use asserções no lugar do tratamento de erros reais. Asserções verificam coisas que nunca devem acontecer: você não quer escrever código como o seguinte:

Puts ("Enter 'y' ou 'n':")

ANS = Gets [0]# Pegue o primeiro personagem da resposta

Assert ((CH == 'y') || (CH == 'n'))# MUITO IDEIA MUITO!



E apenas porque a maioria das implementações afirma encerrará o
Processar quando uma afirmação falha, não há razão para que as versões que você escrevem devam. Se você precisar de recursos gratuitos, pegue a exceção da afirmação ou prenda a saída e execute seu próprio manipulador de erros. Apenas certifique -se de que o código que você execute naqueles milissegundos que morrem não depende das informações que desencadearam a falha de asserção em primeiro lugar.





Afirmações e efeitos colaterais


É embaraçoso quando o código que adicionamos para detectar erros acaba criando novos erros. Isso pode acontecer com afirmações se a avaliação da condição tiver efeitos colaterais. Por exemplo, seria uma má idéia codificar algo como

While (iter.hasMoreElements ()) {

Assert (iter.nextElement ()! = Null);

Objeto obj = iter.nextElement ();

// ....

}



A chamada .nextElement () na afirmação tem o efeito colateral de mover o iterador após o elemento que está sendo buscado e, portanto, o loop processará apenas metade dos elementos da coleção. Seria melhor escrever

While (iter.hasMoreElements ()) {

Objeto obj = iter.nextElement ();

Assert (obj! = Null);

// ....

}



Esse problema é uma espécie de Heisenbug [32] - adotando que muda o comportamento do sistema que está sendo depurado.

(Também acreditamos que hoje em dia, quando a maioria dos idiomas tem suporte decente para funções de iteração sobre coleções, esse tipo de loop explícito é desnecessário e ruim.)





Deixar afirmações ativadas


Há um mal -entendido comum sobre as afirmações. Vai algo assim:

As afirmações adicionam algumas despesas gerais ao código. Como eles verificam as coisas que nunca devem acontecer, eles serão acionados apenas por um bug no código. Depois que o código for testado e enviado, eles não são mais necessários e devem ser desligados para tornar o código funcionar mais rapidamente. As afirmações são uma instalação de depuração.



Existem duas suposições claramente erradas aqui. Primeiro, eles assumem que os testes encontram todos os bugs. Na realidade, para qualquer programa complexo, é improvável que você teste uma porcentagem minúscula das permutações que seu código será colocado. Segundo, os otimistas estão esquecendo que seu programa é executado em um mundo perigoso. Durante os testes, os ratos provavelmente não roncam um cabo de comunicação, alguém jogando um jogo não esgota a memória e os arquivos de log não preencherão a partição de armazenamento. Essas coisas podem acontecer quando seu programa é executado em um ambiente de produção. Sua primeira linha de defesa está checando qualquer erro possível, e o segundo está usando afirmações para tentar detectar aqueles que você perdeu.

Despertar as afirmações quando você entrega um programa para a produção é como atravessar um fio alto sem uma rede, porque você já o atravessou na prática. Há um valor dramático, mas é difícil obter seguro de vida.

Mesmo se você tiver problemas de desempenho, desligue apenas as afirmações que realmente atingem você. O exemplo de classificação acima pode ser uma parte crítica do seu aplicativo e pode precisar ser rápido. Adicionar a verificação significa outra passagem pelos dados, o que pode ser inaceitável. Faça essa verificação em particular opcional, mas deixe o restante dentro.


Use afirmações na produção, ganhe muito dinheiro

Um ex -vizinho da Andy liderou uma pequena empresa de startups que fabricou dispositivos de rede. Um de seus segredos para o sucesso foi a decisão de deixar as afirmações em vigor nos lançamentos de produção. Essas afirmações foram bem criadas para relatar todos os dados pertinentes que levaram à falha e apresentados por meio de uma interface do usuário de boa aparência ao usuário final. Esse nível de feedback, de usuários reais em condições reais, permitiu aos desenvolvedores conectar os orifícios e consertar esses bugs obscuros e difíceis de reproduzir, resultando em software notavelmente estável à prova de balas.

Esta empresa pequena e desconhecida tinha um produto tão sólido que logo foi adquirido por centenas de milhões de dólares.

Apenas dizendo.





Exercício 16 (resposta possível)

Uma rápida verificação da realidade. Qual dessas coisas "impossíveis" podem acontecer?

Um mês com menos de 28 dias

Código de erro de uma chamada do sistema: não consigo acessar o diretório atual

Em c ++: a = 2; b = 3; Mas (a + b) não é igual a 5

Um triângulo com uma soma de ângulo interior ≠ 180 °

Um minuto que não tem 60 segundos

(a + 1) <= a





Seções relacionadas incluem


Tópico 23, projeto por contrato

Tópico 24, programas mortos não contam mentiras

Tópico 42, teste baseado em propriedades

Tópico 43, fique seguro lá fora





Tópico 26

Como equilibrar recursos




Aceitar uma vela é lançar uma sombra ...



Ursula K. Le Guin, um mago de Earthsea



Todos gerenciamos recursos sempre que codificamos: memória, transações, threads, rede
Conexões, arquivos, temporizadores - todos os tipos de coisas com disponibilidade limitada. Na maioria das vezes, o uso de recursos segue um padrão previsível: você aloca o recurso, o usa e o desalocula.

No entanto, muitos desenvolvedores não têm um plano consistente para lidar com a alocação de recursos e a desalocação. Então, vamos sugerir uma dica simples:

Dica 40 Termine o que você começa



Esta dica é fácil de aplicar na maioria das circunstâncias. Significa simplesmente que a função ou objeto que aloca um recurso deve ser responsável por negociá -la. Vamos ver como ele se aplica ao analisar um exemplo de algum código ruim - parte de um programa Ruby que abre um arquivo, lê as informações do cliente, atualiza um campo e grava o resultado de volta. Eliminamos o manuseio de erros para tornar o exemplo mais claro:

Def Read_customer

@Customer_file = file.open (@name + ".rec", "r +")

@Balance = BigDecimal ( @Customer_File.gets)

Fim

​

Def write_customer

@Customer_File.rewind

@Customer_File.puts @balance.to_s

@Customer_File.close

Fim

​

Def update_customer (transaction_amount)

Read_customer

@Balance = @balance.add (transaction_amount, 2)

Write_customer

Fim



À primeira vista, a rotina update_customer parece razoável. Parece implementar a lógica que exigimos - lendo um registro, atualizando o saldo e escrevendo o registro de volta. No entanto, essa arrumação esconde um grande problema. As rotinas read_customer e write_customer estão fortemente acopladas [33] - elas compartilham a variável de instância Customer_File. Read_customer abre o arquivo e armazena a referência do arquivo em Customer_File e, em seguida, Write_customer usa essa referência armazenada para fechar o arquivo quando terminar. Essa variável compartilhada nem aparece na rotina update_customer.

Por que isso é ruim? Vamos considerar o infeliz programador de manutenção que é informado de que a especificação mudou - o saldo deve ser atualizado apenas se o novo valor não for negativo. Eles entram na fonte e alteram a atualização_customer:

Def update_customer (transaction_amount)

Read_customer

If (transaction_amount> = 0,00)

@Balance = @balance.add (transaction_amount, 2)

Write_customer

Fim

Fim



Tudo parece bom durante o teste. No entanto, quando o código entra em produção, ele entra em colapso após várias horas, reclamando de muitos arquivos abertos. Acontece que Write_customer não está sendo chamado em algumas circunstâncias. Quando isso acontece, o arquivo não está sendo fechado.

Uma solução muito ruim para esse problema seria lidar com o caso especial em update_customer:.

Def update_customer (transaction_amount)

Read_customer

If (transaction_amount> = 0,00)

@Balance += BigDecimal (transaction_amount, 2)

Write_customer

Outra pessoa

@Customer_File.close# Más ideia!

Fim

Fim



Isso resolverá o problema - o arquivo agora será fechado, independentemente do novo saldo - mas a correção agora significa que três rotinas são acopladas através da variável compartilhada Customer_File e acompanhar quando o arquivo está aberto ou não, começará a ficar confuso. Estamos caindo em uma armadilha, e as coisas vão começar a descer rapidamente se continuarmos neste curso. Isso não está equilibrado!

O acabamento que você inicia a dica nos diz que, idealmente, a rotina que aloca um recurso também deve libertá -lo. Podemos aplicá -lo aqui refatorando o código um pouco:

Def read_customer (arquivo)

@Balance = bigdecimal (file.gets)

Fim

​

Def write_customer (arquivo)

File.rewind

File.puts @balance.to_s

Fim

​

Def update_customer (transaction_amount)

File = file.open (@Name + ".rec", "r +")#>-

Read_customer (arquivo)# |

@Balance = @balance.add (transaction_amount, 2)# |

File.close# <-

Fim



Em vez de manter a referência do arquivo, alteramos o código para passá -lo como um parâmetro. [34] Agora, toda a responsabilidade pelo arquivo está na rotina update_customer. Ele abre o arquivo e (terminando o que ele começa) o fecha antes de retornar. A rotina equilibra o uso do arquivo: o aberto e o fechamento estão no mesmo local, e é evidente que, para cada aberto, haverá um fechamento correspondente. A refatoração também remove uma variável compartilhada feia.

Há outra melhoria pequena, mas importante, que podemos fazer. Em muitos idiomas modernos, você pode procurar a vida útil de um recurso para um bloco fechado de algum tipo. Em Ruby, há uma variação do arquivo aberto que passa na referência de arquivo aberto a um bloco, mostrado aqui entre o DO e o
fim:

Def update_customer (transaction_amount)

File.open (@name + ".rec", "r +") do | arquivo | #>-

Read_customer (arquivo)# |

@Balance = @balance.add (transaction_amount, 2)# |

Write_customer (arquivo)# |

Final# <-

Fim



Nesse caso, no final do bloco, a variável de arquivo sai do escopo e o arquivo externo está fechado. Período. Não há necessidade de se lembrar de fechar o arquivo e liberar a fonte, é garantido que isso aconteça para você.

Em caso de dúvida, sempre vale a pena reduzir o escopo.

Dica 41 ACT localmente




Equilibrando com o tempo

Neste tópico, estamos analisando principalmente os recursos efêmeros usados pelo seu processo de execução. Mas você pode querer considerar que outras bagunças você pode estar deixando para trás.

Por exemplo, como seus arquivos de log são tratados? Você está criando dados e usando o espaço de armazenamento para cima. Existe algo no lugar para girar os troncos e limpá -los? Que tal para seus arquivos de depuração não oficiais que você está abandonando? Se você está adicionando registros de registro em um banco de dados, existe um processo semelhante para expndê -los? Para qualquer coisa que você crie que ocupa um recurso finito, considere como equilibrá -lo.

O que mais você está deixando para trás?





Alocações de ninhos


O padrão básico para alocação de recursos pode ser estendido para rotinas que precisam de mais de um recurso por vez. Existem apenas mais duas sugestões:

Dealpor os recursos na ordem oposta àquele em que você os aloca. Dessa forma, você não terá recursos órfãos se um recurso contiver referências a outro.



Ao alocar o mesmo conjunto de recursos em locais diferentes do seu código, sempre os alocem na mesma ordem. Isso reduzirá a possibilidade de impasse. (Se o processo de reivindicações do processo está prestes a reivindicar o Resource2, enquanto o Process B reivindicou o Resource2 e estiver tentando obter o Resource1, os dois processos esperarão para sempre.)





Não importa que tipo de recursos que estamos usando - transações, conexões de rede, memória, arquivos, threads, Windows - o padrão básico se aplica: quem aloca um recurso deve ser responsável por negociá -lo. No entanto, em alguns idiomas, podemos desenvolver ainda mais o conceito.





Objetos e exceções


O equilíbrio entre alocações e desalocações lembra o construtor e o destruidor de uma classe orientada a objetos. A classe representa um recurso, o construtor fornece um objeto específico desse tipo de recurso e o destruidor o remove do seu escopo.

Se você estiver programando em uma linguagem orientada a objetos, poderá achar útil encapsular recursos nas classes. Cada vez que você precisa de um tipo de recurso específico, você instancia um objeto dessa classe. Quando o objeto sai do escopo ou é recuperado pelo coletor de lixo, o destruidor do objeto então negocia o recurso embrulhado.

Essa abordagem tem benefícios específicos quando você trabalha com idiomas em que exceções podem interferir na desalocação de recursos.





Equilíbrio e exceções


Os idiomas que suportam exceções podem tornar os desalocação de recursos complicados. Se uma exceção for lançada, como você garante que tudo alocado antes da exceção esteja arrumado? A resposta depende, em certa medida, do suporte ao idioma. Você geralmente tem duas opções:

Use escopo variável (por exemplo, variáveis de pilha em C ++ ou ferrugem)

Use uma cláusula finalmente em uma tentativa… Catch Block



Com as regras de escopo usuais em idiomas como C ++ ou Rust, a memória da variável será recuperada quando a variável sair do escopo por meio de um retorno, saída de bloco ou exceção. Mas você também pode conectar -se ao destruidor da variável para limpar quaisquer recursos externos. Neste exemplo, a variável de ferrugem nomeada contas fechará automaticamente o arquivo associado quando sair do escopo:

{

Deixe o Mut Accouts = File :: Open ("mydata.txt")?; //>-

// Use 'Contas' // |

... // |

} // <-

// 'contas' agora está fora de escopo, e o arquivo está

// fechado automaticamente



A outra opção, se o idioma suportar, é a cláusula finalmente. Uma cláusula finalmente garantirá que o código especificado seja executado se uma exceção foi levantada ou não na tentativa ... Catch Block:

Tente

// Algumas coisas desonestas

Pegar

// A exceção foi levantada

Finalmente

// Limpe em ambos os casos



No entanto, há um problema.





Uma exceção antipathern


Geralmente vemos pessoas escrevendo algo assim:

Comece

Coisa = alocate_resource ()

Processo (coisa)

Finalmente

Dealpor (coisa)

Fim



Você pode ver o que está errado?

O que
Acontece se a alocação de recursos falhar e aumentar uma exceção? A cláusula finalmente o pegará e tentará negociar uma coisa que nunca foi alocada.

O padrão correto para lidar com a desalocação de recursos em um ambiente com exceções é

Coisa = alocate_resource ()

Comece

Processo (coisa)

Finalmente

Dealpor (coisa)

Fim





Quando você não pode equilibrar recursos


Há momentos em que o padrão básico de alocação de recursos não é apropriado. Geralmente, isso é encontrado em programas que usam estruturas dinâmicas de dados. Uma rotina alocará uma área de memória e a vinculará a uma estrutura maior, onde pode permanecer por algum tempo.

O truque aqui é estabelecer um invariante semântico para a alocação de memória. Você precisa decidir quem é responsável pelos dados em uma estrutura de dados agregados. O que acontece quando você negocia a estrutura de nível superior? Você tem três opções principais:

A estrutura de nível superior também é responsável por liberar quaisquer subestruturas que ele contém. Essas estruturas excluem recursivamente os dados que eles contêm e assim por diante.



A estrutura de nível superior é simplesmente desalocada. Quaisquer estruturas que apontassem (que não são referenciadas em outros lugares) são órfãs.



A estrutura de nível superior se recusa a se negociar se contiver alguma subestrutura.





A escolha aqui depende das circunstâncias de cada estrutura de dados individual. No entanto, você precisa torná -lo explícito para cada um e implementar sua decisão de forma consistente. A implementação de qualquer uma dessas opções em um idioma processual, como C, pode ser um problema: as próprias estruturas de dados não estão ativas. Nossa preferência nessas circunstâncias é escrever um módulo para cada estrutura principal que fornece instalações de alocação e desalocação padrão para essa estrutura. (Este módulo também pode fornecer instalações como impressão de depuração, serialização, deserialização e ganchos de travessia.)





Verificando o equilíbrio


Como os programadores pragmáticos não confiam em ninguém, inclusive nós mesmos, sentimos que é sempre uma boa idéia criar código que realmente verifica se os recursos são realmente libertados adequadamente. Para a maioria das aplicações, isso normalmente significa produzir invólucros para cada tipo de recurso e usar esses invólucros para acompanhar todas as alocações e desalocações. Em certos pontos do seu código, a lógica do programa determinará que os recursos estarão em um determinado estado: use os invólucros para verificar isso. Por exemplo, um programa de longa duração que os serviços de serviços provavelmente terão um único ponto na parte superior de seu loop de processamento principal, onde aguarda a chegada da próxima solicitação. Este é um bom lugar para garantir que o uso de recursos não tenha aumentado desde a última execução do loop.

Em um nível mais baixo, mas não menos útil, você pode investir em ferramentas que (entre outras coisas) verificam seus programas em execução para vazamentos de memória.





Seções relacionadas incluem


Tópico 24, programas mortos não contam mentiras

Tópico 30, transformando a programação

Tópico 33, quebrando o acoplamento temporal





Desafios


Embora não haja maneiras garantidas de garantir que você sempre livre recursos, certas técnicas de design, quando aplicadas de forma consistente, ajudarão. No texto, discutimos como o estabelecimento de um invariante semântico para as principais estruturas de dados poderia direcionar as decisões de desalocação de memória. Considere como o tópico 23, design por contrato, pode ajudar a refinar essa ideia.



Exercício 17 (resposta possível)

Alguns desenvolvedores de C e C ++ fazem questão de definir um ponteiro para nulo depois que eles negociam a memória que ela faz referência. Por que isso é uma boa ideia?

Exercício 18 (resposta possível)

Alguns desenvolvedores de Java fazem questão de definir uma variável de objeto para NULL depois de terminarem de usar o objeto. Por que isso é uma boa ideia?





Tópico 27

Não supere seus faróis




	É difícil fazer previsões, especialmente sobre o futuro.



Lawrence "Yogi" Berra, depois de um provérbio dinamarquês



É tarde da noite, escuro, chovendo. Os dois lugares chicoteando em torno das curvas apertadas das pequenas estradas de montanha, mal segurando os cantos. Um gancho de cabelo aparece e o carro sente falta, batendo no corrimão acanhado e subindo para um acidente ardente no vale abaixo. Os soldados estaduais chegam ao local, e o oficial sênior trata tristemente a cabeça. "Deve ter superado seus faróis."

O excesso de velocidade de dois lugares estava indo mais rápido que a velocidade da luz? Não, esse limite de velocidade é firmemente fixo. O que o oficial se referiu foi a capacidade do motorista de parar ou dirigir a tempo em resposta à iluminação do farol.

Os faróis têm um
Certa faixa limitada, conhecida como distância de arremesso. Passado a esse ponto, a propagação da luz é muito difusa para ser eficaz. Além disso, os faróis apenas se projetam em linha reta e não iluminam nada fora do eixo, como curvas, colinas ou mergulhos na estrada. De acordo com a Administração Nacional de Segurança no Trânsito nas Rodovias, a distância média iluminada pelos faróis de vigas baixas é de cerca de 160 pés. Infelizmente, a distância de parar a 40 mph é de 189 pés e a 70 km / h por 464 pés. [35] Então, de fato, é realmente muito fácil superar seus faróis.

No desenvolvimento de software, nossos "faróis" são igualmente limitados. Não podemos ver muito à frente no futuro, e quanto mais o eixo você olha, mais escuro fica. Então, programadores pragmáticos têm uma regra firme:

Dica 42 Dê pequenos passos - sempre



Sempre faça etapas pequenas e deliberadas, verificando feedback e ajustando antes de prosseguir. Considere que a taxa de feedback é o seu limite de velocidade. Você nunca dá um passo ou uma tarefa que é "grande demais".

O que queremos dizer exatamente por feedback? Qualquer coisa que confirme ou refuta independentemente sua ação. Por exemplo:

Resultados em um REPL Forneça feedback sobre sua compreensão de APIs e algoritmos

Os testes de unidade fornecem feedback sobre sua última mudança de código

Demo e conversa do usuário fornecem feedback sobre recursos e usabilidade



O que é uma tarefa muito grande? Qualquer tarefa que exija "informação para a fortuna". Assim como os faróis do carro têm arremesso limitado, só podemos ver no futuro, talvez uma ou duas etapas, talvez algumas horas ou dias no máximo. Além disso, você pode superar rapidamente o palpite e a especulação selvagem. Você pode se encontrar para a fortuna informando quando precisa:

A conclusão da estimativa data dos meses no futuro

Planeje um design para manutenção ou extensibilidade futura

Adivinhe as necessidades futuras do usuário

Adivinhe a disponibilidade de tecnologia futura



Mas ouvimos você chorar, não devemos projetar para manutenção futura? Sim, mas apenas até certo ponto: apenas o mais rápido possível. Quanto mais você precisar prever como será o futuro, mais riscos você incorre em que estará errado. Em vez de desperdiçar o esforço de projetar para um futuro incerto, você sempre pode recorrer ao projetar seu código para ser substituível. Facilite a reprodução do seu código e substitua -o por algo mais adequado. Fazer o código substituível também ajudará na coesão, acoplamento e seco, levando a um design melhor em geral.

Mesmo que você possa se sentir confiante no futuro, sempre há a chance de um cisne preto na esquina.





Cisnes negros


Em seu livro, The Black Swan: o impacto do altamente improvável [Tal10], Nassim Nicholas Taleb postula que todos os eventos significativos da história vieram de eventos de alto perfil, difícil de previsto e raros que estão além do domínio das expectativas normais. Esses outliers, embora estatisticamente raros, têm efeitos desproporcionais. Além disso, nossos próprios preconceitos cognitivos tendem a nos cegar para mudanças surgindo nas bordas do nosso trabalho (ver tópico 4, sopa de pedra e sapos cozidos).

Na época da primeira edição do programador pragmático, o debate se enfureceu em revistas de computadores e fóruns on -line sobre a pergunta ardente: “Quem ganharia as guerras da GUI, motivos ou o Openlook da GUI?” [36] Era a questão errada. As chances são de que você provavelmente nunca ouviu falar dessas tecnologias como nem "vencidas" e a Web centrada no navegador rapidamente dominou a paisagem.

Dica 43 Evite a sorte da sorte



Na maioria das vezes, amanhã se parece muito com hoje. Mas não conte com isso.





Seções relacionadas incluem


Tópico 12, balas de traçador

Tópico 13, protótipos e notas post-it

Tópico 40, refatoração

Tópico 41, teste para codificar

Tópico 48, a essência da agilidade

Tópico 50, cocos não o cortam





Notas de rodapé


[30]

Com base em parte em trabalhos anteriores de Dijkstra, Floyd, Hoare, Wirth e outros.



[31]

Em C e C ++, geralmente são implementados como macros. Em Java, as afirmações são desativadas por padrão. Invoque o Java VM com o sinalizador –EnableSertions para habilitá -los e deixe -os ativados.



[32]

http://www.eps.mcgill.ca/jargon/jargon.html#heisenbug



[33]

Para uma discussão sobre os perigos do código acoplado, consulte o tópico 28, desacoplando.



[34]

Veja a dica aqui.



[35]

De acordo com o NHTSA, a distância de parada = distância da reação + distância de frenagem, assumindo um tempo médio de reação de 1,5s e desaceleração de 17,02 pés/s².



[36]

Motif e OpenLlook eram padrões da GUI para estações de trabalho do UNIX baseadas em Windows.





Copyright © 2020 Pearson Education, Inc.





Capítulo
5



Dobrar ou quebrar




A vida não fica parada. Nem o código que escrevemos. Para acompanhar o ritmo de mudança de hoje, precisamos fazer todos os esforços para escrever código tão frouxo-quanto flexível-como possível. Caso contrário, podemos encontrar nosso código rapidamente se tornando desatualizado ou muito quebradiço para corrigir, e pode ser deixado para trás na corrida louca em direção ao futuro.

De volta ao tópico 11, reversibilidade, conversamos sobre os perigos das decisões irreversíveis. Neste capítulo, diremos a você como tomar decisões reversíveis, para que seu código possa permanecer flexível e adaptável diante de um mundo incerto.

Primeiro, olhamos para o acoplamento - as dependências entre bits de código. Tópico 28, a desacoplamento mostra como manter conceitos separados separados e decrescentes.

Em seguida, examinaremos diferentes técnicas que você pode usar quando o Tópico 29, fazendo malabarismos com o mundo real. Examinaremos quatro estratégias diferentes para ajudar a gerenciar e reagir aos eventos - um aspecto crítico dos aplicativos modernos de software.

O código processual e orientado a objetos tradicional pode estar muito bem acoplado para seus propósitos. No tópico 30, transformando a programação, aproveitaremos o estilo mais flexível e mais claro oferecido pelos pipelines de função, mesmo que seu idioma não os suportasse diretamente.

O estilo comum orientado a objetos pode tentá-lo com outra armadilha. Não caia nisso, ou você acabará pagando um tópico 31, imposto sobre herança. Exploraremos melhores alternativas para manter seu código flexível e mais fácil de alterar.

E, é claro, uma boa maneira de permanecer flexível é escrever menos código. A mudança de código deixa você aberto à possibilidade de introduzir novos bugs. Tópico 32, a configuração explicará como mover completamente os detalhes do código, onde eles podem ser alterados com mais segurança e facilidade.

Todas essas técnicas ajudarão você a escrever código que se inclina e não quebre.





Tópico 28

Desacoplar




Quando tentamos escolher qualquer coisa por si só, a achamos preso a todo o resto do universo.



John Muir, meu primeiro verão na Serra



No tópico 8, a essência do bom design, afirmamos que o uso de bons princípios de design facilitará o código que você escreve fácil de alterar. O acoplamento é o inimigo da mudança, porque liga as coisas que devem mudar em paralelo. Isso dificulta a mudança: você gasta tempo rastreando todas as partes que precisam mudar, ou gasta tempo se perguntando por que as coisas quebraram quando você mudou "apenas uma coisa" e não as outras coisas às quais foi acoplado.

Quando você está projetando algo que deseja ser rígido, uma ponte ou uma torre, talvez, você coloca os componentes:



Os links funcionam juntos para tornar a estrutura rígida.

Compare isso com algo assim:



Aqui não há rigidez estrutural: os links individuais podem mudar e outros apenas a acomodam.

Quando você está projetando pontes, deseja que elas tenham a forma deles; Você precisa que eles sejam rígidos. Mas quando você está projetando software que deseja mudar, deseja exatamente o contrário: deseja que seja flexível. E para ser flexível, os componentes individuais devem ser acoplados ao menor número possível de componentes.

E, para piorar a situação, o acoplamento é transitivo: se a for acoplado a B e C, e B é acoplado a M e N e C a X e Y, então A é realmente acoplado a B, C, M, N, X e Y.

Isso significa que há um princípio simples que você deve seguir:

Dica 44 O código desacoplado é mais fácil de alterar



Dado que normalmente não codificamos o uso de vigas de aço e rebites, o que significa despachar o código? Nesta seção, falaremos sobre:

Naufrágios de trem - cadeias de chamadas de método

Globalização - os perigos das coisas estáticas

Herança - por que a subclasse é perigosa



Até certo ponto, essa lista é artificial: o acoplamento pode ocorrer a qualquer momento, duas peças de código compartilham algo; portanto, ao ler o que se segue, fique de olho nos padrões subjacentes para que você possa aplicá -los ao seu código. E mantenha uma atenção para alguns dos sintomas do acoplamento:

Dependências malucas entre módulos ou bibliotecas não relacionados.



Alterações "simples" em um módulo que se propagam através de módulos não relacionados no sistema ou quebram coisas em outras partes do sistema.



Os desenvolvedores que têm medo de alterar o código porque não têm certeza do que pode ser afetado.



Reuniões em que todos precisam comparecer, porque ninguém tem certeza de quem será afetado por uma mudança.





Naufrágios de trem


Todos nós vimos (e provavelmente escrito) código como este:

Public void ApplyDiscount (cliente, ordem_id, desconto) {

Totais = cliente

​
.Der

.Find (order_id)

.Gettotals ();

Totals.GrandTotal = Totals.grandtotal - desconto;

ToTals.discount = desconto;

}



Estamos recebendo uma referência a alguns pedidos de um objeto de cliente, usando isso para encontrar um pedido específico e, em seguida, obtendo o conjunto de totais para o pedido. Usando esses totais, subtraímos o desconto do pedido total do pedido e também os atualizamos com esse desconto.

Esse pedaço de código está atravessando cinco níveis de abstração, do cliente ao total. Por fim, nosso código de nível superior deve saber que um objeto de cliente expõe pedidos, que os pedidos têm um método de localização que leva um ID do pedido e retorna um pedido e que o objeto de ordem possui um objeto de totais que possui getters e setters para grandes totais e descontos. Isso é muito conhecimento implícito. Mas, pior, são muitas coisas que não podem mudar no futuro se esse código continuar a funcionar. Todos os carros em um trem são acoplados, assim como todos os métodos e atributos em um acidente de trem.

Vamos imaginar que o negócio decide que nenhum pedido pode ter um desconto de mais de 40%. Onde colocaríamos o código que aplicaria essa regra?

Você pode dizer que ele pertence à função ApplyDiscount que acabamos de escrever. Isso certamente faz parte da resposta. Mas com o código da maneira que está agora, você não pode saber que essa é a resposta toda. Qualquer pedaço de código, em qualquer lugar, poderia definir campos no objeto de totais e, se o mantenedor desse código não recebesse o memorando, não estaria checando contra a nova política.

Uma maneira de olhar para isso é pensar em responsabilidades. Certamente o objeto de totais deve ser responsável pelo gerenciamento dos totais. E, no entanto, não é: é realmente apenas um contêiner para um monte de campos que qualquer pessoa pode consultar e atualizar.

A correção é aplicar algo que chamamos:

Dica 45 Diga, não pergunte



Esse princípio diz que você não deve tomar decisões com base no estado interno de um objeto e, em seguida, atualize esse objeto. Fazer isso destrói totalmente os benefícios do encapsulamento e, ao fazê -lo, espalha o conhecimento da implementação ao longo do código. Portanto, a primeira correção para o nosso acidente de trem é delegar o desconto ao objeto total:

Public void ApplyDiscount (cliente, ordem_id, desconto) {

Cliente

.Der

.Find (order_id)

.Gettotals ()

.ApplyDiscount (desconto);

}



Temos o mesmo tipo de problema do Tell-não-OSC (TDA) com o objeto do cliente e seus pedidos: não devemos buscar sua lista de pedidos e pesquisá-los. Em vez disso, devemos receber o pedido que queremos diretamente do cliente:

Public void ApplyDiscount (cliente, ordem_id, desconto) {

Cliente

.Findorder (order_id)

.Gettotals ()

.ApplyDiscount (desconto);

}



O mesmo se aplica ao nosso objeto de ordem e seus totais. Por que o mundo exterior deve saber que a implementação de um pedido usa um objeto separado para armazenar seus totais?

Public void ApplyDiscount (cliente, ordem_id, desconto) {

Cliente

.Findorder (order_id)

.ApplyDiscount (desconto);

}



E é aqui que provavelmente pararíamos.

Nesse ponto, você pode estar pensando que o TDA nos faria adicionar um método ApplyDiscountToorder (Order_Id) aos clientes. E, se seguido, é esbelto, seria.

Mas o TDA não é uma lei da natureza; É apenas um padrão para nos ajudar a reconhecer problemas. Nesse caso, estamos à vontade para expor o fato de que um cliente tem pedidos e que podemos encontrar um desses pedidos pedindo ao objeto do cliente. Esta é uma decisão pragmática.

Em todas as aplicações, existem certos conceitos de nível superior que são universais. Neste aplicativo, esses conceitos incluem clientes e pedidos. Não faz sentido ocultar pedidos totalmente dentro de objetos do cliente: eles têm uma existência própria. Portanto, não temos nenhum problema em criar APIs que exponham objetos de ordem.





A lei do demeter


As pessoas costumam falar sobre algo chamado Lei de Deméter, ou LOD, em relação ao acoplamento. O LOD é um conjunto de diretrizes [37] escrito no final dos anos 80 por Ian Holland. Ele os criou para ajudar os desenvolvedores no projeto Demeter a manter suas funções mais limpas e dissociadas.

O LOD diz que um método definido em uma classe C só deve ligar:

Outros métodos de instância em C

Seus parâmetros

Métodos em objetos que ele cria, tanto na pilha quanto na pilha

Variáveis globais



Na primeira edição deste livro, passamos algum tempo descrevendo o LOD. Nos 20 anos intermediários, a flor desapareceu nessa rosa em particular. Agora não gostamos da "variável global"
Cláusula (por razões em que entraremos na próxima seção). Também descobrimos que é difícil usar isso na prática: é um pouco como ter que analisar um documento legal sempre que você chama um método.

No entanto, o princípio ainda é sólido. Apenas recomendamos uma maneira um pouco mais simples de expressar quase a mesma coisa:

Dica 46 Não encorrer as chamadas do método



Tente não ter mais de um "". Quando você acessa algo. E acessar algo também abrange casos em que você usa variáveis intermediárias, como no código a seguir:

# Isso é um estilo muito ruim

Quantidade = cliente.orders.Last (). Totals ().

​

# E isso também ...

Pedidos = cliente.orders;

Last = ordens.Last ();

Totais = last.totals ();

Vale = toTals.amount;



Há uma grande exceção à regra de um ponto: a regra não se aplica se as coisas que você está encadeando são realmente, muito improváveis de mudar. Na prática, qualquer coisa em seu aplicativo deve ser considerada provável que mude. Qualquer coisa em uma biblioteca de terceiros deve ser considerada volátil, principalmente se os mantenedores dessa biblioteca mudarem de APIs entre as liberações. As bibliotecas que acompanham o idioma, no entanto, provavelmente são bastante estáveis e, portanto, ficaremos felizes com o código como:

Pessoas

.Sort_by {| Person | pessoa.age}

. Primeiro (10)

.Map {| pessoa | pessoa.name}



Esse código Ruby funcionou quando escrevemos a primeira edição, há 20 anos, e provavelmente ainda funcionará quando entrarmos na casa para programadores antigos (a qualquer dia agora ...).





Correntes e oleodutos


No tópico 30, transformando a programação, conversamos sobre compor funções em pipelines. Esses pipelines transformam dados, passando de uma função para a próxima. Isso não é o mesmo que um acidente de trem de chamadas de método, pois não estamos confiando nos detalhes da implementação oculta.

Isso não quer dizer que os pipelines não introduzam algum acoplamento: eles o fazem. O formato dos dados retornados por uma função em um pipeline deve ser compatível com o formato aceito pelo próximo.

Nossa experiência é que essa forma de acoplamento é muito menos uma barreira para alterar o código do que o formulário introduzido pelos destroços de trem.





Os males da globalização


Os dados globalmente acessíveis são uma fonte insidiosa de acoplamento entre os componentes do aplicativo. Cada parte dos dados globais age como se todos os métodos em seu aplicativo ganhassem repentinamente um parâmetro adicional: afinal, que os dados globais estivessem disponíveis em todos os métodos.

Globals Couple Code por muitos motivos. O mais óbvio é que uma alteração na implementação do global afeta potencialmente todo o código do sistema. Na prática, é claro, o impacto é bastante limitado; O problema realmente se resume a saber que você encontrou todos os lugares que precisa mudar.

Os dados globais também criam acoplamento quando se trata de separar seu código.

Muito foi feito dos benefícios da reutilização do código. Nossa experiência foi que a reutilização provavelmente não deve ser uma preocupação principal ao criar código, mas o pensamento que é necessário para tornar o código reutilizável deve fazer parte da sua rotina de codificação. Quando você torna o código reutilizável, você fornece interfaces limpas, dissociando -o do restante do seu código. Isso permite extrair um método ou módulo sem arrastar todo o resto junto com ele. E se o seu código usar dados globais, ficará difícil dividi -los do resto.

Você verá esse problema ao escrever testes de unidade para código que usa dados globais. Você se encontrará escrevendo um monte de código de configuração para criar um ambiente global apenas para permitir que seu teste seja executado.

Dica 47 Evite dados globais





Dados globais incluem singletons


Na seção anterior, tivemos o cuidado de falar sobre dados globais e não variáveis globais. Isso ocorre porque as pessoas costumam nos dizer "Olhe! Sem variáveis globais. Enrolei tudo como dados de instância em um objeto singleton ou módulo global".

Tente novamente, Skippy. Se tudo o que você tem é um singleton com um monte de variáveis de instância exportadas, ainda são apenas dados globais. Só tem um nome mais longo.

Então, as pessoas pegam esse singleton e ocultam todos os dados por trás dos métodos. Em vez de codificar config.log_level, eles agora dizem config.log_level () ou config.getLoglevel (). Isso é melhor, porque significa que seus dados globais têm um pouco de inteligência por trás disso. Se você decidir alterar a representação dos níveis de log, poderá manter a compatibilidade mapeando entre o novo e o antigo na API Config. Mas você ainda tem apenas o único conjunto de dados de configuração.





Dados globais incluem recursos externos


Qualquer externo mutável
Recurso são dados globais. Se o seu aplicativo usar um banco de dados, armazenamento de dados, sistema de arquivos, API de serviço e assim por diante, ele corre o risco de cair na armadilha da globalização. Novamente, a solução é garantir que você sempre envolva esses recursos por trás do código que você controla.

Dica 48 Se for importante o suficiente para ser global, envolva -o em uma API





A herança adiciona acoplamento


O uso indevido da subclasse, onde uma classe herda o estado e o comportamento de outra classe, é tão importante que discutimos em sua própria seção, tópico 31, imposto sobre herança.





Novamente, é tudo sobre mudança


O código acoplado é difícil de alterar: as alterações em um só lugar podem ter efeitos secundários em outras partes do código e, geralmente, em locais difíceis de encontrar que só vêm à tona um mês depois na produção.

Manter seu código tímido: tê -lo apenas lida com as coisas que ele conhece diretamente ajudará a manter seus aplicativos dissociados, e isso os tornará mais passíveis de mudar.





Seções relacionadas incluem


Tópico 8, a essência do bom design

Tópico 9, seco - os males de duplicação

Tópico 10, Ortogonalidade

Tópico 11, reversibilidade

Tópico 29, manipulando o mundo real

Tópico 30, transformando a programação

Tópico 31, Imposto sobre Herança

Tópico 32, configuração

Tópico 33, quebrando o acoplamento temporal

Tópico 34, Estado compartilhado é um estado incorreto

Tópico 35, atores e processos

Tópico 36, Blackboards

Discutimos Tell, não pergunte em nosso artigo de construção de software de 2003 The Art of Enbugging. [38]





Tópico 29

Fazendo malabarismo com o mundo real




As coisas não acontecem; Eles são feitos para acontecer.



John F. Kennedy



Antigamente, quando seus autores ainda tinham boa aparência, os computadores não eram particularmente flexíveis. Normalmente, organizamos a maneira como interagimos com eles com base em suas limitações.

Hoje, esperamos mais: os computadores precisam se integrar ao nosso mundo, não o contrário. E nosso mundo está confuso: as coisas estão constantemente acontecendo, as coisas são movidas por aí, mudamos de idéia,…. E os aplicativos que escrevemos de alguma forma precisam descobrir o que fazer.

Esta seção trata de escrever esses aplicativos responsivos.

Começaremos com o conceito de um evento.





Eventos


Um evento representa a disponibilidade de informações. Pode vir do mundo exterior: um usuário clicando em um botão ou uma atualização de cotação de estoque. Pode ser interno: o resultado de um cálculo está pronto, uma pesquisa termina. Pode até ser algo tão trivial quanto buscar o próximo elemento em uma lista.

Qualquer que seja a fonte, se escrevermos aplicativos que respondem aos eventos e ajustem o que eles fazem com base nesses eventos, esses aplicativos funcionarão melhor no mundo real. Seus usuários acharão que eles são mais interativos e os próprios aplicativos farão melhor uso dos recursos.

Mas como podemos escrever esses tipos de aplicativos? Sem algum tipo de estratégia, nos encontraremos rapidamente confusos, e nossos aplicativos estarão uma bagunça de código fortemente acoplado.

Vejamos quatro estratégias que ajudam.

Máquinas de estado finitas

O padrão do observador

Publicar/assinar

Programação e riachos reativos





Máquinas de estado finitas


Dave descobre que escreve código usando uma máquina de estado finita (FSM) quase toda semana. Muitas vezes, a implementação do FSM será apenas algumas linhas de código, mas essas poucas linhas ajudam a desembaraçar muita bagunça em potencial.

O uso de um FSM é trivialmente fácil, e, no entanto, muitos desenvolvedores evitam -se deles. Parece haver uma crença de que eles são difíceis ou que se aplicam apenas se você estiver trabalhando com hardware ou que precisa usar uma biblioteca difícil de entender. Nada disso é verdadeiro.





A anatomia de um FSM pragmático


Uma máquina de estado é basicamente apenas uma especificação de como lidar com eventos. Consiste em um conjunto de estados, um dos quais é o estado atual. Para cada estado, listamos os eventos que são significativos para esse estado. Para cada um desses eventos, definimos o novo estado atual do sistema.

Por exemplo, podemos estar recebendo mensagens multipartidas de um WebSocket. A primeira mensagem é um cabeçalho. Isto é seguido por qualquer número de mensagens de dados, seguido de uma mensagem à direita. Isso pode ser representado como um FSM como este:



Começamos no "estado inicial". Se recebermos uma mensagem de cabeçalho, fazemos a transição para o estado de "mensagem de leitura". Se recebermos mais alguma coisa enquanto estivermos no estado inicial (a linha rotulada com um asterisco), fazemos a transição para o estado de "erro" e terminamos.

Enquanto estivermos no estado da "mensagem de leitura", podemos aceitar os dados
Mensagens, nesse caso, continuamos lendo no mesmo estado, ou podemos aceitar uma mensagem de reboque, que nos transita para o estado "feito". Qualquer outra coisa causa uma transição para o estado de erro.

O interessante sobre o FSMS é que podemos expressá -los puramente como dados. Aqui está uma tabela representando nossa mensagem analisadora:



As linhas da tabela representam os estados. Para descobrir o que fazer quando ocorrer um evento, procure a linha para o estado atual, proceda a coluna que representa o evento, o conteúdo dessa célula é o novo estado.

O código que lida com ele é igualmente simples:

Event/simples_fsm.rb

1: transições = {

- Inicial: {cabeçalho :: Reading},

- Reading: {Data :: Reading, Trailer :: done},

-}

5:

- estado =: inicial

-

- While State! =: Coned && State! =: Erro

- msg = get_next_message ()

10: estado = transições [estado] [msg.msg_type] || : Erro

- final



O código que implementa as transições entre os estados está na linha 10. Indexa a tabela de transição usando o estado atual e, em seguida, indexa as transições para esse estado usando o tipo de mensagem. Se não houver um novo estado correspondente, ele define o estado como: erro.





Adicionando ações


Um FSM puro, como o que estávamos apenas olhando, é um analisador de fluxo de eventos. Sua única saída é o estado final. Podemos reforçar, adicionando ações que são acionadas em determinadas transições.

Por exemplo, podemos precisar extrair todas as strings em um arquivo de origem. Uma string é o texto entre aspas, mas uma barra de barriga em uma string escapa do próximo caractere; portanto, "ignorar \" aspas \ "" é uma única string. Aqui está um FSM que faz isso:



Desta vez, cada transição tem dois rótulos. A parte superior é o evento que o desencadeia, e o inferior é a ação a ser tomada à medida que nos movemos entre os estados.

Expressaremos isso em uma tabela, como fizemos da última vez. No entanto, neste caso, cada entrada da tabela é uma lista de dois elementos que contém o próximo estado e o nome de uma ação:

Evento/Strings_fsm.rb

Transições = {

​

# Novo ação estatal atual para tomar

#---------------------------------------------------------

​

Look_for_string: {

'"' => [: In_string ,: start_new_string],

: Default => [: look_for_string ,: ignorar],

},

​

In_string: {

'"' => [: Look_for_string ,: finall_current_string],

'\\' => [: copy_next_char ,: add_current_to_string],

: Default => [: in_string ,: add_current_to_string],

},

​

Copy_next_char: {

: Default => [: in_string ,: add_current_to_string],

},

}



Também adicionamos a capacidade de especificar uma transição padrão, realizada se o evento não corresponder a nenhuma das outras transições para esse estado.

Agora vamos olhar para o código:

Evento/Strings_fsm.rb

Estado =: look_for_string

Resultado = []

​

Enquanto ch = stdin.getc

Estado, ação = transições [estado] [ch] || Transições [estado] [: padrão]

Ação de caso

Quando: ignore

Quando: start_new_string

Resultado = []

Quando: add_current_to_string

Resultado << Ch

Quando: finaliz_current_string

Coloca o resultado.Join

Fim

Fim



Isso é semelhante ao exemplo anterior, pois percorremos os eventos (os caracteres da entrada), desencadeando transições. Mas faz mais do que o código anterior. O resultado de cada transição é um novo estado e o nome de uma ação. Usamos o nome da ação para selecionar o código para ser executado antes de voltarmos ao loop.

Este código é muito básico, mas faz o trabalho. Existem muitas outras variantes: a tabela de transição pode usar funções anônimas ou ponteiros de função para as ações, você pode envolver o código que implementa a máquina de estado em uma classe separada, com seu próprio estado e assim por diante.

Não há nada a dizer que você deve processar todas as transições de estado ao mesmo tempo. Se você estiver passando pelas etapas para inscrever um usuário em seu aplicativo, é provável que haja várias transições ao entrar em seus detalhes, validar o email, concordar com os 107 avisos legislados diferentes que os aplicativos on -line devem agora dar e assim por diante. Manter o estado em armazenamento externo e usá -lo para dirigir uma máquina de estado é uma ótima maneira de lidar com esse tipo de requisitos de fluxo de trabalho.





Máquinas de estado são um começo


As máquinas estaduais são subutilizadas pelos desenvolvedores e gostaríamos de incentivá -lo a procurar oportunidades para aplicá -las. Mas eles não resolvem todos os problemas associados aos eventos. Então, vamos passar para algumas outras maneiras de olhar para os problemas de malabarismo
eventos.





O padrão do observador


No padrão do observador, temos uma fonte de eventos, chamada de observável e uma lista de clientes, os observadores, que estão interessados nesses eventos.

Um observador registra seu interesse com o observável, normalmente passando uma referência a uma função a ser chamada. Posteriormente, quando o evento ocorre, o observável itera sua lista de observadores e chama a função que cada um passou. O evento é dado como um parâmetro para essa chamada.

Aqui está um exemplo simples em Ruby. O módulo Terminator é usado para encerrar o aplicativo. Antes disso, no entanto, notifica todos os seus observadores que o aplicativo vai sair. [39] Eles podem usar essa notificação para arrumar recursos temporários, comprometer dados e assim por diante:

Evento/Observer.rb

Terminador do módulo

Retornos de chamada = []

​

Def Self.register (retorno de chamada)

Retornos de chamada << retorno de chamada

Fim

​

Def self.exit (exit_status)

Retorno de chamada.Each {| Retorno de chamada | retorno de chamada. (Exit_status)}

Saída! (Exit_status)

Fim

Fim

​

Terminator.register (-> (status) {coloca "Retorno de chamada 1 vê#{status}"})

Terminator.register (-> (status) {coloca "Retorno de chamada 2 vê#{status}"})

​

Terminator.Exit (99)



$ Ruby evento/observador.rb

Retorno de chamada 1 vê 99

Retorno de chamada 2 vê 99



Não há muito código envolvido na criação de um observável: você pressiona uma referência de função em uma lista e chama essas funções quando o evento ocorrer. Este é um bom exemplo de quando não usar uma biblioteca.

O padrão observador/observável é usado há décadas e nos serviu bem. É particularmente prevalente nos sistemas de interface do usuário, onde os retornos de chamada são usados para informar o aplicativo que ocorreu alguma interação.

Mas o padrão do observador tem um problema: como cada um dos observadores precisa se registrar no observável, ele introduz o acoplamento. Além disso, como na implementação típica, os retornos de chamada são tratados em linha pelos observáveis, de maneira síncrona, ela pode introduzir gargalos de desempenho.

Isso é resolvido pela próxima estratégia, publique/assine.





Publicar/assinar


Publicar/assinar (pubSub) generaliza o padrão de observador, ao mesmo tempo resolvendo os problemas de acoplamento e desempenho.

No modelo PubSub, temos editores e assinantes. Estes são conectados via canais. Os canais são implementados em um corpo separado de código: às vezes uma biblioteca, às vezes um processo e, às vezes, uma infraestrutura distribuída. Todos esses detalhes de implementação estão ocultos do seu código.

Cada canal tem um nome. Os assinantes registram interesse em um ou mais desses canais nomeados e os editores escrevem eventos para eles. Ao contrário do padrão do observador, a comunicação entre o editor e o assinante é tratada fora do seu código e é potencialmente assíncrona.

Embora você possa implementar um sistema PubSub muito básico, provavelmente não deseja. A maioria dos provedores de serviços em nuvem possui ofertas de pubsub, permitindo conectar aplicativos em todo o mundo. Todo idioma popular terá pelo menos uma biblioteca pubsub.

O PubSub é uma boa tecnologia para dissociar o manuseio de eventos assíncronos. Ele permite que o código seja adicionado e substituído, potencialmente enquanto o aplicativo estiver em execução, sem alterar o código existente. A desvantagem é que pode ser difícil ver o que está acontecendo em um sistema que usa muito o PubSub: você não pode olhar para um editor e ver imediatamente quais assinantes estão envolvidos com uma mensagem específica.

Comparado ao padrão do observador, o PubSub é um ótimo exemplo de redução do acoplamento, abstraindo por meio de uma interface compartilhada (o canal). No entanto, ainda é basicamente apenas um sistema de passagem de mensagens. A criação de sistemas que respondem a combinações de eventos precisarão de mais do que isso, então vamos procurar maneiras de adicionar uma dimensão de tempo ao processamento de eventos.





Programação, córregos e eventos reativos


Se você já usou uma planilha, estará familiarizado com a programação reativa. Se uma célula contiver uma fórmula que se refere a uma segunda célula, atualizar a segunda célula também faz com que a primeira atualize. Os valores reagem como os valores que eles usam mudam.

Existem muitas estruturas que podem ajudar com esse tipo de reatividade no nível de dados: no reino do navegador reagir e vue.js são os favoritos atuais (mas, sendo este JavaScript, essas informações estarão desatualizadas antes que este livro seja impresso).

Fica claro que os eventos também podem ser usados para desencadear reações no código, mas não é
necessariamente fácil de colocá -los. É aí que entra os fluxos.

Fluxos vamos tratar os eventos como se fossem uma coleção de dados. É como se tivéssemos uma lista de eventos, que ficaram mais longos quando novos eventos chegarem. A beleza disso é que podemos tratar fluxos como qualquer outra coleção: podemos manipular, combinar, filtrar e fazer todas as outras coisas de dados que conhecemos tão bem. Podemos até combinar fluxos de eventos e coleções regulares. E os fluxos podem ser assíncronos, o que significa que seu código tem a oportunidade de responder aos eventos à medida que chegam.

A linha de base de fato atual para o manuseio de eventos reativos é definida no site http://reactivex.io, que define um conjunto de princípios e documentos comuns. Aqui usaremos a biblioteca RXJS para JavaScript.

Nosso primeiro exemplo pega dois fluxos e os preenche: o resultado é um novo fluxo em que cada elemento contém um item do primeiro fluxo de entrada e um item do outro. Nesse caso, o primeiro fluxo é simplesmente uma lista de cinco nomes de animais. O segundo fluxo é mais interessante: é um cronômetro de intervalo que gera um evento a cada 500ms. Como os fluxos são fechados, um resultado é gerado apenas quando os dados estão disponíveis em ambos e, portanto, nosso fluxo de resultados emite apenas um valor a cada meio segundo:

Event/rx0/index.js

Importar * como observável de 'rxjs'

Importar {logValues} de "../rxcommon/logger.js"

​

Deixe os animais = observável. De ("Ant", "Bee", "Cat", "Dog", "Elk")

Deixe o ticker = observável.Interval (500)

​

Seja combinado = observável.zip (animais, ticker)

​

Combined.subScribe (Next => LogValues (JSON.Stringify (Next))))



Este código usa uma função de log simples [40] que adiciona itens a uma lista na janela do navegador. Cada item é o registro de data e hora com o tempo em milissegundos desde que o programa começou a ser executado. Aqui está o que mostra para o nosso código:



Observe os registros de data e hora: estamos recebendo um evento do fluxo a cada 500ms. Cada evento contém um número de série (criado pelo intervalo observável) e o nome do próximo animal da lista. Assistindo ao vivo em um navegador, as linhas de toras aparecem a cada meio segundo.

Os fluxos de eventos são normalmente preenchidos à medida que os eventos ocorrem, o que implica que os observáveis que os povoam podem ser executados em paralelo. Aqui está um exemplo que busca informações sobre usuários de um site remoto. Para isso, usaremos https://reqres.in, um site público que fornece uma interface de repouso aberta. Como parte de sua API, podemos buscar dados sobre um usuário específico (falso) executando uma solicitação GET para usuários/«id». Nosso código busca os usuários com os IDs 3, 2 e 1:

Event/rx1/index.js

Importar * como observável de 'rxjs'

Importar {Mergemap} de 'rxjs/operadores'

Importar {ajax} de 'rxjs/ajax'

Importar {logValues} de "../rxcommon/logger.js"

​

Deixe os usuários = observável. De (3, 2, 1)

​

Let Result = Users.pipe (

Mergemap ((usuário) => ajax.getjson (`https://reqres.in/api/users/ $ {user}`))

)

​

Resultado.Subscribe (

Resp => logValues (json.stringify (resp.data)),

Err => console.error (json.stringify (err))

)



Os detalhes internos do código não são muito importantes. O que é emocionante é o resultado, mostrado na captura de tela a seguir:



Veja os registros de data e hora: as três solicitações, ou três fluxos separados, foram processados em paralelo, o primeiro a voltar, para o ID 2, levou 82ms, e os dois próximos voltaram 50 e 51ms depois.





Fluxos de eventos são coleções assíncronas


No exemplo anterior, nossa lista de IDs de usuário (nos usuários observáveis) era estática. Mas não precisa ser. Talvez queremos coletar essas informações quando as pessoas fazem login em nosso site. Tudo o que precisamos fazer é gerar um evento observável contendo seu ID de usuário quando a sessão é criada e usar essa observável em vez da estática. Em seguida, estaríamos buscando detalhes sobre os usuários enquanto recebíamos esses IDs e, presumivelmente, armazenávamos em algum lugar.

Essa é uma abstração muito poderosa: não precisamos mais pensar no tempo como algo que temos que gerenciar. Os fluxos de eventos unificam o processamento síncrono e assíncrono por trás de uma API comum e conveniente.





Os eventos são onipresentes


Os eventos estão por toda parte. Alguns são óbvios: um clique de botão, um timer expirando. Outros são menos: alguém efetuando login, uma linha em um arquivo que corresponde a um padrão. Mas qualquer que seja sua fonte, o código criado em torno dos eventos pode ser mais receptivo e melhor desacoplado do que seu mais linear
contrapartida.





Seções relacionadas incluem


Tópico 28, dissociação

Tópico 36, Blackboards





Exercícios


Exercício 19 (resposta possível)

Na seção FSM, mencionamos que você poderia mover a implementação genérica da máquina de estado para sua própria classe. Essa classe provavelmente seria inicializada passando em uma tabela de transições e um estado inicial.

Tente implementar o extrator de string dessa maneira.

Exercício 20 (resposta possível)

Qual dessas tecnologias (talvez em combinação) seria uma boa opção para as seguintes situações:

Se você receber três eventos de interface de rede em cinco minutos, notifique a equipe de operações.



Se for após o pôr do sol, e há um movimento detectado no fundo da escada seguido de movimento detectado no topo da escada, ligue as luzes no andar de cima.



Você deseja notificar vários sistemas de relatórios de que um pedido foi concluído.



Para determinar se um cliente se qualifica para um empréstimo de carro, o aplicativo precisa enviar solicitações para três serviços de back -end e aguardar as respostas.





Tópico 30

Programação transformadora




Se você não pode descrever o que está fazendo como processo, não sabe o que está fazendo.



W. Edwards Deming, (Att)



Todos os programas transformam dados, convertendo uma entrada em uma saída. E, no entanto, quando pensamos em design, raramente pensamos em criar transformações. Em vez disso, nos preocupamos com classes e módulos, estruturas de dados e algoritmos, idiomas e estruturas.

Achamos que esse foco no código geralmente perde o ponto: precisamos voltar a pensar em programas como sendo algo que transforma as entradas em saídas. Quando o fazemos, muitos dos detalhes que nos preocupamos anteriormente evaporam. A estrutura se torna mais clara, o manuseio de erros mais consistente e o acoplamento cai muito para baixo.

Para iniciar nossa investigação, vamos levar a máquina do tempo de volta à década de 1970 e pedir a um programador do UNIX que nos escreva um programa que lista os cinco arquivos mais longos em uma árvore de diretórios, onde o mais longo significa "ter o maior número de linhas".

Você pode esperar que eles busquem um editor e comecem a digitar em C., mas não o fariam, porque estão pensando nisso em termos do que temos (uma árvore de diretório) e o que queremos (uma lista de arquivos). Então eles iam a um terminal e digitavam algo como:

$ Find. -Type f | xargs wc -l | sort -n | cauda -5



Esta é uma série de transformações:

encontrar . -Type f

Escreva uma lista de todos os arquivos (-Type f) dentro ou abaixo do diretório atual (.) Para saída padrão.



Xargs wc -l

Leia as linhas da entrada padrão e organize para que todas sejam passadas como argumentos para o comando wc -l. O programa WC com a opção -l conta o número de linhas em cada um de seus argumentos e grava cada resultado como "nome do arquivo de contagem" para a saída padrão.



classificar -n

Classifique a entrada padrão, assumindo que cada linha começa com um número (-n), escrevendo o resultado para a saída padrão.



cauda -5

Leia a entrada padrão e escreva apenas as últimas cinco linhas para a saída padrão.





Execute isso no diretório do nosso livro e nós obtemos

470 ./test_to_build.pml

487 ./dbc.pml

719 ./Domain_Languages.pml

727 ./dry.pml

9561 TOTAL



Essa última linha é o número total de linhas em todos os arquivos (não apenas os mostrados), porque é isso que o WC faz. Podemos retirá -lo solicitando mais uma linha da cauda e ignorando a última linha:

$ Find. -Type f | xargs wc -l | sort -n | cauda -6 | cabeça -5

470 ./debug.pml

470 ./test_to_build.pml

487 ./dbc.pml

719 ./Domain_Languages.pml

727 ./dry.pml



Figura 1. O pipeline de localização como uma série de transformações





Vejamos isso em termos dos dados que fluem entre as etapas individuais. Nosso requisito original, “5 principais arquivos em termos de linhas”, torna -se uma série de transformações (também mostram na figura).

Nome do diretório

→ Lista de arquivos

→ Liste com números de linha

→ Lista classificada

→ Total mais alto de cinco +

→ Cinco mais altos

É quase como uma linha de montagem industrial: alimentar dados brutos em uma extremidade e o produto acabado (informações) sai do outro.

E gostamos de pensar em todo o código dessa maneira.

Dica 49 A programação é sobre código, mas os programas são sobre dados





Encontrando transformações


Às vezes, a maneira mais fácil de encontrar as transformações é começar com o requisito e determinar suas entradas e saídas. Agora você definiu a função que representa o programa geral. Você pode então encontrar
Etapas que o levam da entrada para a saída. Esta é uma abordagem de cima para baixo.

Por exemplo, você deseja criar um site para pessoas que jogam jogos de palavras que encontram todas as palavras que podem ser feitas a partir de um conjunto de letras. Sua entrada aqui é um conjunto de letras, e sua saída é uma lista de palavras de três letras, palavras de quatro letras e assim por diante:

"Lvyin" é transformado para → 3 => Ivy, Lin, Nil, Yin

4 => inly, liney, viny

5 => vinil





(Sim, são todas as palavras, pelo menos de acordo com o dicionário MacOS.)

O truque por trás do aplicativo geral é simples: temos um dicionário que agrupa palavras por uma assinatura, escolhida para que todas as palavras que contenham as mesmas letras tenham a mesma assinatura. A função de assinatura mais simples é exatamente a lista classificada de letras na palavra. Podemos então procurar uma sequência de entrada gerando uma assinatura e, em seguida, vendo quais palavras (se houver) no dicionário têm a mesma assinatura.

Assim, o Anagram Finder se decompõe em quatro transformações separadas:

Dados da amostra de transformação de etapa

Etapa 0: entrada inicial "ylvin"

Etapa 1: Todas as combinações de três ou mais letras Vin, VIY, VIL, VNY, VNL, VYL, INY, INL, IYL, NYL, VINY, VINL, VIYL, VNYL, INYL, Vinil

Etapa 2: Assinaturas das combinações Inv, Ivy, Ilv, Nvy, Lnv, Lvy, Iny, Iln, Ily, Lny, Invy, Ilnv, Ilvy, Lnvy, Ilny, Ilnvy

Etapa 3: Lista de todas as palavras do dicionário que correspondem a qualquer uma das assinaturas Ivy, Yin, Nil, Lin, Viny, Liny, Inly, Vinil

Etapa 4: Palavras agrupadas por comprimento 3 => Ivy, lin, nil, yin

4 => inly, liney, viny

5 => vinil





Transformações até o fim


Vamos começar olhando para a Etapa 1, que pega uma palavra e cria uma lista de todas as combinações de três ou mais letras. Esta etapa pode ser expressa como uma lista de transformações:

Dados da amostra de transformação de etapa

Etapa 1.0: entrada inicial "vinil"

Etapa 1.1: converter para os caracteres V, i, n, y, l

Etapa 1.2: Obtenha todos os subconjuntos [], [v], [i],… [v, i], [v, n], [v, y],… [v, i, n], [v, i, y],… [v, n, y, l], [i, n, y, l], [v, i, n, y, l]

Etapa 1.3: Apenas aqueles mais de três caracteres [v, i, n], [v, i, y],… [i, n, y, l], [v, i, n, y, l]

Etapa 1.4: Converter de volta às cordas [Vin, VIY,… inyl, vinil]



Chegamos agora ao ponto em que podemos implementar facilmente cada transformação no código (usando o Elixir neste caso):

Função-Pipelines/anagrams/lib/anagrams.ex

DEFP ALL_SUBSETS_LONGER_THAN_THREE_CHARACTERS (Word) Do

Palavra

|> String.codePoints ()

|> Comb.subsets ()

|> Stream.Filter (subconjunto FN -> Comprimento (subconjunto)> = 3 FIM)

|> Stream.map (& list.to_string (& 1))

Fim





O que há com o operador |>?


Elixir, juntamente com muitas outras linguagens funcionais, possui um operador de pipeline, às vezes chamado de tubo para frente ou apenas um tubo. [41] Tudo o que faz é pegar o valor à sua esquerda e inseri -lo como o primeiro parâmetro da função à sua direita, então

"Vinil" |> String.CodePoints |> Comb.Subsets ()



é o mesmo que escrever

Comb.subsets (String.codePoints ("Vinil"))



(Outros idiomas podem injetar esse valor canalizado como o último parâmetro da próxima função-depende em grande parte do estilo das bibliotecas internas.)

Você pode pensar que isso é apenas açúcar sintático. Mas, de uma maneira muito real, o operador de pipeline é uma oportunidade revolucionária de pensar de maneira diferente. Usar um pipeline significa que você está pensando automaticamente em termos de transformação de dados; Cada vez que você vê |> Você está realmente vendo um lugar onde os dados estão fluindo entre uma transformação e a próxima.

Muitos idiomas têm algo semelhante: Elm, F#e Swift têm |>, Clojure tem -> e ->> (que funciona de maneira um pouco diferente), r tem %> %. A Haskell possui operadores de tubos e facilita a declaração de novos. Enquanto escrevemos isso, se fala em adicionar |> ao javascript.

Se o seu idioma atual suportar algo semelhante, você está com sorte. Caso contrário, veja o idioma x não possui pipelines.

Enfim, de volta ao código.





Continue transformando ...


Agora observe a etapa 2 do programa principal, onde convertemos os subconjuntos em assinaturas. Novamente, é uma transformação simples - uma lista de subconjuntos se torna uma lista de assinaturas:

Dados da amostra de transformação de etapa

Etapa 2.0: Entrada inicial VIN, VIY,… inyl, vinil

Etapa 2.1: Converta em assinaturas inv, Ivy… Ilny, Inlvy



O código Elixir na listagem a seguir é tão simples:

Função-Pipelines/anagrams/lib/anagrams.ex

DEFP as_unique_signatures (subconjuntos) fazem

Subconjuntos

|> Stream.map (& dictionary.signature_of/1)

Fim



Agora, transformamos essa lista de assinaturas: cada assinatura é mapeada para a lista de palavras conhecidas
com a mesma assinatura, ou nulo se não houver essas palavras. Temos então que remover os nilos e achatar as listas aninhadas em um único nível:

Função-Pipelines/anagrams/lib/anagrams.ex

DEFP find_in_dictionary (assinaturas) sim

Assinaturas

|> Stream.map (& dictionary.lookup_by_signature/1)

|> Stream.reject (& is_nil/1)

|> Stream.concat (& (& 1))

Fim



A etapa 4, agrupando as palavras por comprimento, é outra transformação simples, convertendo nossa lista em um mapa em que as chaves são os comprimentos, e os valores são todas as palavras com esse comprimento:

Função-Pipelines/anagrams/lib/anagrams.ex

DEFP group_by_length (palavras) sim

Palavras

|> Enum.sort ()

|> Enum.group_by (& string.length/1)

Fim




Idioma x não tem pipelines

Os oleodutos existem há muito tempo, mas apenas em idiomas de nicho. Eles só se mudaram para o mainstream recentemente, e muitos idiomas populares ainda não suportam o conceito.

A boa notícia é que pensar em transformações não requer uma sintaxe de linguagem específica: é mais uma filosofia de design. Você ainda constrói seu código como transformações, mas as escreve como uma série de tarefas:

Const content = file.read (file_name);

Const lines = find_matching_lines (conteúdo, padrão)

Const resultado = truncate_lines (linhas)



É um pouco mais tedioso, mas faz o trabalho.





Juntando tudo


Escrevemos cada uma das transformações individuais. Agora é hora de reuni -los todos em nossa função principal:

Função-Pipelines/anagrams/lib/anagrams.ex

Def anagrams_in (word) sim

Palavra

|> All_subsets_longer_than_three_characters ()

|> As_unique_signatures ()

|> Find_in_dictionary ()

|> Group_by_length ()

Fim



Funciona? Vamos tentar:

Iex (1)> anagrams.anagrams_in "lyvin"

%{

3 => ["Ivy", "lin", "nil", "yin"],

4 => ["Inly", "Liny", "Viny"],

5 => ["vinil"]

}





Por que isso é tão bom?


Vejamos o corpo da função principal novamente:

Palavra

|> All_subsets_longer_than_three_characters ()

|> As_unique_signatures ()

|> Find_in_dictionary ()

|> Group_by_length ()



É simplesmente uma cadeia das transformações necessárias para atender aos nossos requisitos, cada um recebendo informações da transformação anterior e passando a saída para a seguinte. Isso chega o mais próximo possível do código alfabetizado.

Mas há algo mais profundo também. Se o seu plano de fundo for uma programação orientada a objetos, seus reflexos exigem que você oculte dados, encapsulando-os dentro de objetos. Esses objetos conversam para frente e para trás, mudando o estado um do outro. Isso introduz muito acoplamento e é uma grande razão pela qual os sistemas OO podem ser difíceis de mudar.

Dica 50 Não acumular estado; Passe por isso



No modelo transformacional, viramos isso de cabeça para baixo. Em vez de pequenos pools de dados espalhados por todo o sistema, pense nos dados como um rio poderoso, um fluxo. Os dados se tornam um ponto para funcionalidade: um pipeline é uma sequência de código → dados → código → dados…. Os dados não estão mais vinculados a um grupo específico de funções, como estão em uma definição de classe. Em vez disso, é livre para representar o progresso que desdobra de nosso aplicativo, pois transforma suas entradas em suas saídas. Isso significa que podemos reduzir bastante o acoplamento: uma função pode ser usada (e reutilizada) em qualquer lugar que seus parâmetros correspondam à saída de alguma outra função.

Sim, ainda há um grau de acoplamento, mas, em nossa experiência, é mais gerenciável que o estilo OO de comando e controle. E, se você estiver usando um idioma com verificação de tipo, receberá avisos de tempo de compilação ao tentar conectar duas coisas incompatíveis.





E quanto ao manuseio de erros?


Até agora, nossas transformações funcionaram em um mundo onde nada dá errado. Como podemos usá -los no mundo real? Se pudermos construir apenas cadeias lineares, como podemos adicionar toda essa lógica condicional necessária para verificação de erros?

Existem muitas maneiras de fazer isso, mas todas elas dependem de uma convenção básica: nunca passamos por valores brutos entre transformações. Em vez disso, embrulhamos -os em uma estrutura de dados (ou tipo) que também nos diz se o valor contido é válido. Em Haskell, por exemplo, esse invólucro é chamado talvez. Em F# e Scala, é a opção.

Como você usa esse conceito é específico da linguagem. Em geral, porém, existem duas maneiras básicas de escrever o código: você pode lidar com a verificação de erros dentro de suas transformações ou fora delas.

Elixir, que usamos até agora, não tem esse suporte incorporado. Para nossos propósitos, isso é uma coisa boa, à medida que chegamos a
Mostre uma implementação desde o início. Algo semelhante deve funcionar na maioria dos outros idiomas.





Primeiro, escolha uma representação


Precisamos de uma representação para o nosso invólucro (a estrutura de dados que carrega um valor ou uma indicação de erro). Você pode usar estruturas para isso, mas o Elixir já tem uma convenção bastante forte: as funções tendem a retornar uma tupla contendo {: ok, valor} ou {: erro, razão}. Por exemplo, o arquivo.open retorna: OK e um processo de IO ou: erro e código de razão:

Iex (1)> file.open ("/etc/passwd")

{: Ok, #pid <0,109.0>}

Iex (2)> file.open ("/etc/wombat")

{: Erro, eneent}



Usaremos o: OK/: ERRO TUPLE como nosso invólucro ao passar as coisas através de um pipeline.





Em seguida, lide com ele dentro de cada transformação


Vamos escrever uma função que retorne todas as linhas em um arquivo que contém uma determinada string, truncada aos 20 primeiros caracteres. Queremos escrevê -lo como uma transformação, para que a entrada seja um nome de arquivo e uma string a ser combinada, e a saída será uma: Tupla: OK com uma lista de linhas ou uma tupla: erro com algum tipo de motivo. A função de nível superior deve parecer algo assim:

Função-Pipelines/anagrams/lib/grep.ex

Def find_all (file_name, padrão)

File.read (file_name)

|> Find_matching_lines (padrão)

|> Truncate_lines ()

Fim



Não há erro explícito de verificação aqui, mas se alguma etapa do pipeline retornar uma tupla de erro, o pipeline retornará esse erro sem executar as funções a seguir. [42] Fazemos isso usando a correspondência de padrões do Elixir:

Função-Pipelines/anagrams/lib/grep.ex

DEFP find_matching_lines ({: ok, content}, padrão)

Conteúdo

|> String.split (~ r/\ n/)

|> Enum.filter (& string.match? (& 1, padrão))

|> Ok_unless_empty ()

Fim

​

DEFP find_matching_lines (erro, _), faça: erro

​

# ----------

​

DEFP truncate_lines ({: ok, linhas}) fazer

Linhas

|> Enum.map (& string.slice (& 1, 0, 20))

|> Ok ()

Fim

​

DEFP truncate_lines (erro), faça: erro

​

# ----------

​

DEFP ok_unless_empty ([]), faça: erro ("nada encontrado")

DEFP ok_unless_empty (resultado), faça: ok (resultado)

​

DEFP ok (resultado), faça: {: ok, resultado}

Erro DEFP (Razão), faça: {: Erro, Razão}



Dê uma olhada na função find_matching_lines. Se seu primeiro parâmetro for um: ok tupla, ele usa o conteúdo nessa tupla para encontrar linhas que correspondam ao padrão. No entanto, se o primeiro parâmetro não for um: ok tuple, a segunda versão da função é executada, que apenas retorna esse parâmetro. Dessa forma, a função simplesmente encaminha um erro no pipeline. O mesmo se aplica a truncate_lines.

Podemos brincar com isso no console:

Iex> grep.find_all "/etc/passwd", ~ r/www/

{: Ok, ["_www:*: 70: 70: World W", "_wwwroxy:*: 252: 252:"]}



Iex> grep.find_all "/etc/passwd", ~ r/wombat/

{: Erro, "nada encontrado"}

Iex> grep.find_all "/etc/koala", ~ r/www/

{: Erro, eneent}



Você pode ver que um erro em qualquer lugar do pipeline se torna imediatamente o valor do pipeline.





Ou manuseie -o no pipeline


Você pode estar olhando para as funções find_matching_lines e truncate_lines pensando que movemos o ônus de lidar com o manuseio das transformações. Você estaria certo. Em um idioma que usa padrões correspondentes em chamadas de função, como o Elixir, o efeito é diminuído, mas ainda é feio.

Seria bom se Elixir tivesse uma versão do operador de pipeline |> que sabia sobre o: OK/: Erro tuplas e que execução curta-circuitada quando ocorreu um erro. [43] Mas o fato de não nos permitir adicionar algo semelhante e de uma maneira aplicável a vários outros idiomas.

O problema que enfrentamos é que, quando ocorre um erro, não queremos executar o código mais abaixo do pipeline e que não queremos que esse código saiba que isso está acontecendo. Isso significa que precisamos adiar as funções de execução do pipeline até sabermos que as etapas anteriores do pipeline foram bem -sucedidas. Para fazer isso, precisaremos alterá -los das chamadas de função para valores de função que podem ser chamados posteriormente. Aqui está uma implementação:

Pipelines de função/anagramas/lib/grep1.ex

Defmodule grep1 do

​

Def e_then ({: ok, valor}, func), do: func. (Valor)

Def e_then (qualquer coisa_else, _func), faça: qualquer coisa_else

​

Def find_all (file_name, padrão)

File.read (file_name)

|> E_then (& find_matching_lines (& 1, padrão))

|>
e_then (& truncate_lines (& 1))

Fim

​

DEFP find_matching_lines (conteúdo, padrão)

Conteúdo

|> String.split (~ r/\ n/)

|> Enum.filter (& string.match? (& 1, padrão))

|> Ok_unless_empty ()

Fim

​

DEFP truncate_lines (linhas) fazem

Linhas

|> Enum.map (& string.slice (& 1, 0, 20))

|> Ok ()

Fim

​

​

DEFP ok_unless_empty ([]), faça: erro ("nada encontrado")

DEFP ok_unless_empty (resultado), faça: ok (resultado)

​

DEFP ok (resultado), faça: {: ok, resultado}

Erro DEFP (Razão), faça: {: Erro, Razão}

Fim



A função And_HeThen é um exemplo de uma função de ligação: é necessário um valor embrulhado em algo e aplica uma função a esse valor, retornando um novo valor embrulhado. O uso da função And_Hesten no pipeline exige um pouco de pontuação extra, porque o Elixir precisa ser instruído a converter chamadas de função em valores de função, mas esse esforço extra é compensado pelo fato de as funções de transformação se tornarem simples: cada um apenas assume um valor (e qualquer parâmetros extras) e retorna {: ok, new_value} ou {: erro: razão, razão}.





Transformações transformam a programação


Pensar no código como uma série de transformações (aninhadas) pode ser uma abordagem libertadora para a programação. Demora um pouco para se acostumar, mas depois de desenvolver o hábito, você encontrará seu código se torna mais limpo, suas funções mais curtas e seus designs mais lisonjeados.

Experimente.





Seções relacionadas incluem


Tópico 8, a essência do bom design

Tópico 17, jogos de shell

Tópico 26, como equilibrar recursos

Tópico 28, dissociação

Tópico 35, atores e processos





Exercícios


Exercício 21 (resposta possível)

Você pode expressar os seguintes requisitos como uma transformação de nível superior? Isto é, para cada um, identifique a entrada e a saída.

O imposto de envio e vendas é adicionado a um pedido

Seu aplicativo carrega informações de configuração de um arquivo nomeado

Alguém faz login em um aplicativo da web



Exercício 22 (resposta possível)

Você identificou a necessidade de validar e converter um campo de entrada de uma string em um número inteiro entre 18 e 150. A transformação geral é descrita por

Conteúdo de campo como string

→ [Validar e converter]

→ {: ok, valor} | {: erro, razão}



Escreva as transformações individuais que compõem a validação e convertem.

Exercício 23 (possível resposta)

No idioma X não tem pipelines que escrevemos:

Const content = file.read (file_name);

Const lines = find_matching_lines (conteúdo, padrão)

Const resultado = truncate_lines (linhas)



Muitas pessoas escrevem o código OO encadeando chamadas de método e podem ser tentadas a escrever isso como algo como:

Const resultado = content_of (file_name)

.Find_matching_lines (padrão)

.Truncate_Lines ()



Qual é a diferença entre essas duas peças de código? Qual você acha que preferimos?





Tópico 31

Imposto sobre herança




Você queria uma banana, mas o que você conseguiu era um gorila segurando a banana e toda a selva.



Joe Armstrong



Você programa em uma linguagem orientada a objetos? Você usa herança?

Se sim, pare! Provavelmente não é o que você quer fazer.

Vamos ver o porquê.





Alguns antecedentes


A herança apareceu pela primeira vez em Simula 67 em 1969. Foi uma solução elegante para o problema de filitar vários tipos de eventos na mesma lista. A abordagem Simula era usar algo chamado classes de prefixo. Você poderia escrever algo assim:

Link Class Car;

... Implementação de carro

​

Link Class Bicycle;

... Implementação de bicicleta



O link é uma classe de prefixo que adiciona a funcionalidade das listas vinculadas. Isso permite adicionar carros e bicicletas à lista de coisas que aguardam (digamos) um semáforo. Na terminologia atual, o link seria uma classe pai.

O modelo mental usado pelos programadores da Simula foi que os dados de instância e a implementação do link de classe foram antecipados à implementação do Classes Car and Bicycle. A parte do link era quase vista como um recipiente que carregava carros e bicicletas. Isso lhes deu uma forma de polimorfismo: carros e bicicletas implementaram a interface do link porque ambos continham o código do link.

Depois que Simula veio Smalltalk. Alan Kay, um dos criadores de SmallTalk, descreve em uma resposta Quora de 2019 [44] Por que o SmallTalk tem herança:

Então, quando eu projetei SmallTalk-72-e foi uma brincadeira por diversão enquanto pensava em SmallTalk-71-achei que seria divertido usar sua dinâmica semelhante a Lisp para fazer experimentos com "programação diferencial" (significando: várias maneiras de realizar "isso é assim, exceto").



Esse
está subclassificando puramente para o comportamento.

Esses dois estilos de herança (que na verdade tinham uma quantia justa em comum) se desenvolveram nas décadas seguintes. A abordagem Simula, que sugeriu a herança era uma maneira de combinar tipos, continuou em idiomas como C ++ e Java. A Escola de Smalltalk, onde a herança era uma organização dinâmica de comportamentos, foi vista em idiomas como Ruby e JavaScript.

Então, agora estamos diante de uma geração de desenvolvedores de OO que usam herança por um dos dois motivos: eles não gostam de digitar ou gostam de tipos.

Aqueles que não gostam de digitar salvam os dedos usando a herança para adicionar funcionalidade comum de uma classe base nas classes infantis: o usuário da classe e o produto de classe são subclasses do ActiveRecord :: Base.

Aqueles que gostam de tipos usam herança para expressar o relacionamento entre as classes: um carro é um veículo.

Infelizmente, ambos os tipos de herança têm problemas.





Problemas usando a herança para compartilhar código


A herança é o acoplamento. A classe infantil não apenas está acoplada aos pais, aos pais e assim por diante, mas o código que usa a criança também é acoplado a todos os ancestrais. Aqui está um exemplo:

Veículo de classe

Def Initialize

@Speed = 0

Fim

Def Stop

@Speed = 0

Fim

Def move_at (velocidade)

@Speed = velocidade

Fim

Fim

​

Carro de aula <veículo

Def info

"Estou dirigindo carro em#{@speed}"

Fim

Fim

​

# Código de nível superior

My_ride = car.new

My_ride.move_at (30)



Quando o nível superior chama my_car.move_at, o método que está sendo chamado está no veículo, o pai do carro.

Agora, o desenvolvedor responsável pelo veículo altera a API, então move_at se torna set_velocity, e a variável de instância @speed se torna @velocity.

Espera -se que uma mudança de API quebre os clientes da aula de veículos. Mas o nível superior não é: no que diz respeito a estar usando um carro. O que a classe de carros faz em termos de implementação não é a preocupação do código de nível superior, mas ainda quebra.

Da mesma forma, o nome de uma variável de instância é puramente um detalhe de implementação interna, mas quando o veículo também muda (silenciosamente) quebra o carro.

Tanto acoplamento.





Problemas usando herança para construir tipos




Algumas pessoas vêem a herança como uma maneira de definir novos tipos. Seu diagrama de design favorito mostra hierarquias de classe. Eles veem os problemas da maneira como os cientistas vitorianos viam a natureza, como algo a ser dividido em categorias.



Infelizmente, esses diagramas logo se transformam em monstruosidades de cobertura de parede, a camada de camada adicionada adicionou-se para expressar a menor nuance de diferenciação entre as classes. Essa complexidade adicional pode tornar o aplicativo mais quebradiço, pois as alterações podem ondular para cima e para baixo em muitas camadas.

Pior ainda, porém, é a questão de herança múltipla. Um carro pode ser um tipo de veículo, mas também pode ser um tipo de ativo, segurado, loancollateral e assim por diante. Modelar isso corretamente precisaria de herança múltipla.

O C ++ deu à herança múltipla um nome ruim nos anos 90 por causa de alguma semântica de desambiguação questionável. Como resultado, muitos idiomas atuais do OO não o oferecem. Portanto, mesmo se você estiver satisfeito com árvores do tipo complexo, não poderá modelar seu domínio com precisão de qualquer maneira.

Dica 51 Não pague imposto sobre herança





As alternativas são melhores


Vamos sugerir três técnicas que significam que você nunca deve precisar usar a herança novamente:

Interfaces e protocolos

Delegação

Mixins e características





Interfaces e protocolos


A maioria dos idiomas OO permite especificar que uma classe implementa um ou mais conjuntos de comportamentos. Você poderia dizer, por exemplo, que uma classe de carro implementa o comportamento dirigível e o comportamento localizado. A sintaxe usada para fazer isso varia: em Java, pode ser assim:

Public Classe Carro implementos Drivable, Localizável {

​

// Código para carro de classe. Este código deve incluir

// A funcionalidade de ambos dirigíveis

// e localizável

​

}



Drivável e localizado são o que Java chama de interfaces; Outros idiomas os chamam de protocolos, e alguns os chamam de características (embora não seja isso que chamaremos uma característica mais tarde).

As interfaces são definidas assim:

Interface pública Drivable {

Duplo getspeed ();

Void stop ();

}

​

Interface pública localizável () {

Coordenar getLocation ();

Boolean LocationIsValid ();

}



Essas declarações não criam nenhum código: eles simplesmente dizem que qualquer classe que implementa o Drivable deve implementar os dois métodos que getize e param, e uma classe que é
Localizável deve implementar o GetLocation e o LocationIsValid. Isso significa que nossa definição anterior de classe de carro só será válida se incluir todos esses quatro métodos.

O que torna as interfaces e protocolos tão poderosos é que podemos usá -los como tipos, e qualquer classe que implementa a interface apropriada será compatível com esse tipo. Se o carro e o telefone implementarem localizáveis, poderíamos armazenar ambos em uma lista de itens localizáveis:

List <Crocatable> itens = new ArrayList <> ();

​

Items.add (carro novo (...));

Items.add (novo telefone (...));

Items.add (carro novo (...));

// ...



Em seguida, podemos processar essa lista, com segurança, sabendo que todo item possui getLocation e LocationIsValid:

Void PrintLocation (item localizável) {

If (item.LocationIsValid () {

Print (item.getLocation (). Asstring ());

}

​

// ...

​

Items.ForEach (printLocation);



Dica 52 prefere interfaces para expressar polimorfismo



Interfaces e protocolos nos dão polimorfismo sem herança.





Delegação


A herança incentiva os desenvolvedores a criar classes cujos objetos têm um grande número de métodos. Se uma classe pai tiver 20 métodos e a subclasse quiser usar apenas dois deles, seus objetos ainda terão os outros 18 que estão por aí e chamáveis. A classe perdeu o controle de sua interface. Este é um problema comum - muitas estruturas de persistência e interface do usuário insistem que os componentes do aplicativo subclassem alguma classe base fornecida:

Conta de classe <persistencebaseclass

Fim



A classe de conta agora carrega toda a API da classe de persistência. Em vez disso, imagine uma alternativa usando a delegação, como no exemplo a seguir:

Conta de classe

Def Initialize (...)

@Repo = persister.for (self)

Fim

​

Def Save

@Repo.save ()

Fim

Fim



Agora, expojamos nenhuma das API da estrutura aos clientes de nossa classe de conta: essa dissociação está quebrada agora. Mas há mais. Agora que não estamos mais restringidos pela API da estrutura que estamos usando, somos livres para criar a API de que precisamos. Sim, poderíamos fazer isso antes, mas sempre corremos o risco de que a interface que escrevemos possa ser ignorada e a API de persistência usada. Agora controlamos tudo.

Dica 53 Delegado aos Serviços: Has-A Trumps Is-A



De fato, podemos dar um passo adiante. Por que uma conta deve saber como se persistir? Não é seu trabalho saber e fazer cumprir as regras de negócios da conta?

Conta de classe

# Nada além de coisas de conta

Fim

​

Accountrecord de classe

# Envolve uma conta com a habilidade

# Para ser buscado e armazenado

Fim



Agora estamos realmente dissociados, mas isso tem um custo. Estamos tendo que escrever mais código e, normalmente, alguns deles serão caldeiras: é provável que todas as nossas classes de registro precisem de um método de localização, por exemplo.

Felizmente, é isso que mixins e traços fazem por nós.





Mixins, características, categorias, extensões de protocolo,…


Como setor, adoramos dar nomes de coisas. Muitas vezes, daremos a mesma coisa muitos nomes. Mais é melhor, certo?

É com isso que estamos lidando quando olhamos para Mixins. A idéia básica é simples: queremos poder estender classes e objetos com nova funcionalidade sem usar a herança. Por isso, criamos um conjunto dessas funções, damos um nome a esse nome e, de alguma forma, estendemos uma classe ou objeto com eles. Nesse ponto, você criou uma nova classe ou objeto que combina os recursos do original e de todos os seus mixins. Na maioria dos casos, você poderá fazer essa extensão, mesmo que não tenha acesso ao código -fonte da classe que está estendendo.

Agora, a implementação e o nome desse recurso variam entre os idiomas. Tenderemos a chamá-los de mixins aqui, mas realmente queremos que você pense nisso como um recurso agnóstico do idioma. O importante é a capacidade que todas essas implementações têm: mesclando a funcionalidade entre coisas existentes e coisas novas.

Como exemplo, vamos voltar ao nosso exemplo AccountRecord. Quando o deixamos, um AccountRecord precisava saber sobre as contas e sobre nossa estrutura de persistência. Também precisava delegar todos os métodos na camada de persistência que queria expor ao mundo exterior.

Mixins nos dão uma alternativa. Primeiro, poderíamos escrever um mixin que implementa (por exemplo) dois dos três dos métodos padrão do localizador. Poderíamos então adicioná -los ao Accountrecord como um mixin. E, enquanto escrevemos novas aulas para coisas persistentes, também podemos adicionar o mixin a elas:

Mixin Commonfinders {

​
Def Find (id) {...}

Def Findall () {...}

Fim

​

A classe AccountRecord estende o BasicRecord com os Commonfinders

Classe OrderRecord estende o Basicrecord com os Commonfinders



Podemos levar isso muito mais longe. Por exemplo, todos sabemos que nossos objetos de negócios precisam de código de validação para impedir que dados ruins se infilizem a nossos cálculos. Mas exatamente o que queremos dizer com validação?

Se levarmos uma conta, por exemplo, provavelmente existem muitas camadas diferentes de validação que poderiam ser aplicadas:

Validando que uma senha de hash corresponde a inserida pelo usuário

Validando os dados do formulário inseridos pelo usuário quando uma conta é criada

Validando os dados do formulário inseridos por um administrador atualizando os detalhes do usuário

Validando dados adicionados à conta por outros componentes do sistema

Validando dados para consistência antes de serem persistidos



Uma abordagem comum (e acreditamos que o ideal menos do que ideal) é agrupar todas as validações em uma única classe (o objeto de negócios/objeto de persistência) e depois adicionar sinalizadores para controlar qual fogo em que circunstâncias.

Achamos que uma maneira melhor é usar o Mixins para criar classes especializadas para situações apropriadas:

Classe AccountForCustomer estende a conta

Com vorações de conta, conta -customervoridations

​

Classe AccountForAdmin estende a conta

Com validações da conta, conta de válvulações de conta



Aqui, ambas as classes derivadas incluem validações comuns a todos os objetos da conta. A variante do cliente também inclui validações apropriadas para as APIs voltadas para o cliente, enquanto a variante do administrador continha (presumivelmente menos restritiva) validações de administração.

Agora, passando as instâncias do AccountForCustomer ou da AccountForAdmin, nosso código garante automaticamente que a validação correta seja aplicada.

Dica 54 Use Mixins para compartilhar a funcionalidade





A herança raramente é a resposta


Demos uma rápida olhada em três alternativas à herança tradicional de classe:

Interfaces e protocolos

Delegação

Mixins e características



Cada um desses métodos pode ser melhor para você em diferentes circunstâncias, dependendo se sua meta está compartilhando informações do tipo, adicionando funcionalidade ou métodos de compartilhamento. Como em qualquer coisa na programação, procure usar a técnica que melhor expressa sua intenção.

E tente não arrastar a selva inteira para o passeio.





Seções relacionadas incluem


Tópico 8, a essência do bom design

Tópico 10, Ortogonalidade

Tópico 28, dissociação





Desafios


Na próxima vez que você se subclasse, reserve um minuto para examinar as opções. Você pode alcançar o que deseja com interfaces, delegação e/ou mixins? Você pode reduzir o acoplamento fazendo isso?





Tópico 32

Configuração




Que todas as suas coisas tenham seus lugares; Deixe cada parte do seu negócio ter seu tempo.



Benjamin Franklin, treze virtudes, autobiografia



Quando o código depende de valores que podem mudar após o lançamento do aplicativo, mantenha esses valores externos ao aplicativo. Quando seu aplicativo será executado em diferentes ambientes e, potencialmente, para diferentes clientes, mantenha os valores específicos do ambiente e do cliente fora do aplicativo. Dessa forma, você está parametrizando seu aplicativo; O código se adapta aos lugares em que é executado.

Dica 55 Parametrize seu aplicativo usando configuração externa



As coisas comuns que você provavelmente desejará colocar nos dados de configuração incluem:

Credenciais para serviços externos (banco de dados, APIs de terceiros e assim por diante)

Níveis de registro e destinos

Nomes de porta, endereço IP, máquina e cluster que o aplicativo usa

Parâmetros de validação específicos do ambiente

Parâmetros definidos externamente, como taxas de imposto

Detalhes de formatação específicos do site

Chaves de licença



Basicamente, procure qualquer coisa que você saiba que terá que mudar que você pode expressar fora do seu corpo principal de código e investir em algum balde de configuração.





Configuração estática


Muitas estruturas e alguns aplicativos personalizados mantêm a configuração em arquivos simples ou tabelas de banco de dados. Se as informações estiverem em arquivos planos, a tendência deve usar algum formato de texto simples pronta para uso. Atualmente, Yaml e JSON são populares para isso. Às vezes, os aplicativos escritos em linguagens de script usam arquivos de código de fonte de finalidade especiais, dedicados a conter apenas a configuração. Se as informações forem estruturadas e provavelmente serão alteradas pelo cliente (taxas de imposto sobre vendas, por exemplo), pode ser melhor armazená -las em uma tabela de banco de dados. E, é claro, você pode usar os dois, dividindo as informações de configuração de acordo com o uso.

Qualquer que você use,
A configuração é lida em seu aplicativo como uma estrutura de dados, normalmente quando o aplicativo é iniciado. Geralmente, essa estrutura de dados é tornada global, o pensamento é que isso facilita para qualquer parte do código chegar aos valores que ele mantém.

Preferimos que você não faça isso. Em vez disso, embrulhe as informações de configuração por trás de uma API (fina). Isso separa seu código dos detalhes da representação da configuração.





Configuração como serviço


Embora a configuração estática seja comum, atualmente favorecemos uma abordagem diferente. Ainda queremos dados de configuração mantidos externos ao aplicativo, mas, em um arquivo ou banco de dados plano, gostaríamos de vê -lo armazenado atrás de uma API de serviço. Isso tem vários benefícios:

Vários aplicativos podem compartilhar informações de configuração, com autenticação e controle de acesso limitando o que cada um pode ver

Alterações de configuração podem ser feitas globalmente

Os dados de configuração podem ser mantidos por meio de uma interface do usuário especializada

Os dados de configuração se tornam dinâmicos



Esse último ponto, que a configuração deve ser dinâmica, é fundamental à medida que avançamos em direção a aplicativos altamente disponíveis. A idéia de que deveríamos ter que parar e reiniciar um aplicativo para alterar um único parâmetro está irremediavelmente fora de contato com as realidades modernas. Usando um serviço de configuração, os componentes do aplicativo podem se registrar para notificações de atualizações nos parâmetros que eles usam, e o serviço pode enviar mensagens que contêm novos valores se e quando forem alterados.

Qualquer que seja necessário, os dados de configuração acionam o comportamento de tempo de execução de um aplicativo. Quando os valores de configuração mudam, não há necessidade de reconstruir o código.





Não escreva código DODO


Sem configuração externa, seu código não é tão adaptável ou flexível quanto poderia ser. Isso é uma coisa ruim? Bem, aqui no mundo real, espécies que não se adaptam morrem.

O Dodo não se adaptou à presença de humanos e seu gado na ilha das Maurícias, e rapidamente se extinguiu. [45] Foi a primeira extinção documentada de uma espécie na mão do homem.

Não deixe seu projeto (ou sua carreira) seguir o caminho do Dodo.





Seções relacionadas incluem


Tópico 9, seco - os males de duplicação

Tópico 14, idiomas de domínio

Tópico 16, o poder do texto simples

Tópico 28, dissociação




Não exagere

Na primeira edição deste livro, sugerimos o uso de configuração em vez de código de maneira semelhante, mas aparentemente deveria ter sido um pouco mais específico em nossas instruções. Qualquer conselho pode ser levado a extremos ou usado de maneira inadequada, então aqui estão algumas precauções:

Não exagere. Um dos nossos primeiros clientes decidiu que todos os campos em seu aplicativo devem ser configuráveis. Como resultado, levou semanas para fazer a menor alteração, pois você precisava implementar o campo e todo o código de administrador para salvá -lo e editá -lo. Eles tinham cerca de 40.000 variáveis de configuração e um pesadelo de codificação em suas mãos.

Não pressione as decisões para a configuração da preguiça. Se houver um debate genuíno sobre se um recurso deve funcionar dessa maneira ou aquilo, ou se deve ser a escolha dos usuários, experimente uma maneira e obtenha feedback sobre se a decisão foi boa.





Notas de rodapé


[37]

Portanto, não é realmente uma lei. É mais como a boa ideia de Demeter.



[38]

https://media.pragprog.com/articles/jan_03_enbug.pdf



[39]

Sim, sabemos que o Ruby já tem esse recurso com sua função AT_EXIT.



[40]

https://media.pragprog.com/titles/tpp20/code/event/rxcommon/logger.js



[41]

Parece que o primeiro uso dos caracteres |> como um tubo data de 1994, em uma discussão sobre o idioma Isobelle/ml, arquivado em https://blogs.msdn.microsoft.com/dsyme/2011/05/17/archeological-semiotics-the-birth-the-pipline-sambol--1994/17/archeological-semiotics-the-birth-the-pipline-sambol--1944/17/17/archeological-semiotics-the-birth-the-pipline-sambol--1994/17/17/archeological-semióticos



[42]

Tomamos uma liberdade aqui. Tecnicamente, executamos as seguintes funções. Nós simplesmente não executamos o código neles.



[43]

Na verdade, você pode adicionar esse operador ao ELIXIR usando sua instalação de macro; Um exemplo disso é a Mônada Biblioteca em Hex. Você também pode usar o Elixir's com o construto, mas depois perde muito do senso de escrever transformações que recebe com os pipelines.



[44]

https://www.quora.com/what-does-alan-kay-think-about-neritance-in-objecject-oriented-programing



[45]

Não ajudou que os colonos vencessem os pássaros plácidos (leia -se: estúpidos) até a morte com clubes para o esporte.





Copyright © 2020 Pearson Education, Inc.





Capítulo 6



Simultaneidade




Só para que estamos todos na mesma página, vamos
Comece com algumas definições:

A simultaneidade é quando a execução de duas ou mais peças de código age como se elas fossem executadas ao mesmo tempo. O paralelismo é quando eles correm ao mesmo tempo.

Para ter simultaneidade, você precisa executar o código em um ambiente que possa alternar a execução entre diferentes partes do seu código quando estiver em execução. Isso geralmente é implementado usando coisas como fibras, threads e processos.

Para ter paralelismo, você precisa de hardware que possa fazer duas coisas ao mesmo tempo. Isso pode ser vários núcleos em uma CPU, várias CPUs em um computador ou vários computadores conectados.





Tudo é simultâneo


É quase impossível escrever código em um sistema de tamanho decente que não tenha aspectos simultâneos. Eles podem ser explícitos, ou podem ser enterrados dentro de uma biblioteca. A concorrência é um requisito se você deseja que seu aplicativo seja capaz de lidar com o mundo real, onde as coisas são assíncronas: os usuários estão interagindo, os dados estão sendo buscados, os serviços externos estão sendo chamados, tudo ao mesmo tempo. Se você forçar esse processo a ser serial, com uma coisa acontecendo, o próximo e assim por diante, seu sistema se sente lento e provavelmente não está aproveitando ao máximo o poder do hardware em que ele é executado.

Neste capítulo, examinaremos a simultaneidade e o paralelismo.

Os desenvolvedores costumam falar sobre o acoplamento entre pedaços de código. Eles estão se referindo a dependências e como essas dependências dificultam a mudança. Mas há outra forma de acoplamento. O acoplamento temporal acontece quando seu código impõe uma sequência sobre coisas que não são necessárias para resolver o problema em questão. Você depende do "tick" que vem antes do "TOCK"? Não se você quiser se manter flexível. Seu código acessa vários serviços de back-end sequencialmente, um após o outro? Não se você quiser manter seus clientes. No tópico 33, quebrando o acoplamento temporal, procuraremos maneiras de identificar esse tipo de acoplamento temporal.

Por que escrever código simultâneo e paralelo é tão difícil? Uma razão é que aprendemos a programar usando sistemas seqüenciais, e nossos idiomas têm recursos relativamente seguros quando usados sequencialmente, mas se tornam um passivo quando duas coisas podem acontecer ao mesmo tempo. Um dos maiores culpados aqui é o estado compartilhado. Isso não significa apenas variáveis globais: a qualquer momento dois ou mais pedaços de código referências de referência à mesma peça de dados mutáveis, você compartilhou o estado. E tópico 34, estado compartilhado é um estado incorreto. A seção descreve uma série de soluções alternativas para isso, mas em última análise elas são propensas a erros.

Se isso faz você se alimentar triste, Nil Despeandum! Existem melhores maneiras de construir aplicativos simultâneos. Um deles é usar o modelo de ator, onde processos independentes, que não compartilham dados, se comunicam em canais usando semântica definida, simples. Falamos sobre a teoria e a prática dessa abordagem no tópico 35, atores e processos.

Por fim, veremos o tópico 36, Blackboards. São sistemas que agem como uma combinação de um armazenamento de objetos e um corretor de publicação/subscrição inteligente. Na sua forma original, eles nunca decolaram. Hoje, porém, estamos vendo cada vez mais implementações de camadas de middleware com semântica do tipo Blackboard. Usados corretamente, esses tipos de sistemas oferecem uma quantidade séria de desacoplamento.

O código simultâneo e paralelo costumava ser exótico. Agora é necessário.





Tópico 33

Quebrando o acoplamento temporal




"O que é um acoplamento temporal?", Você pode perguntar. Está na hora.

O tempo é um aspecto muitas vezes ignorado das arquiteturas de software. A única vez que nos preocupa é o tempo da programação, o tempo restante até enviarmos - mas não é disso que estamos falando aqui. Em vez disso, estamos falando sobre o papel do tempo como um elemento de design do próprio software. Existem dois aspectos do tempo que são importantes para nós: simultaneidade (coisas que acontecem ao mesmo tempo) e pedidos (as posições relativas das coisas no tempo).

Normalmente, não abordamos a programação com nenhum desses aspectos em mente. Quando as pessoas se sentam para projetar uma arquitetura ou escrever um programa, as coisas tendem a ser lineares. É assim que a maioria das pessoas pensa - faz isso e sempre faz isso. Mas pensar dessa maneira leva ao acoplamento temporal: acoplamento no tempo. Método A sempre deve ser chamado antes do método B; Apenas um relatório pode ser executado de cada vez; Você deve esperar a tela redefinir antes que o clique do botão seja recebido. O carrapato deve acontecer antes de Tobk.

Essa abordagem não é muito flexível e não é muito realista.

Precisamos permitir
por simultaneidade e pensar em desacoplar a qualquer hora ou dependências de pedidos. Ao fazer isso, podemos obter flexibilidade e reduzir as dependências baseadas em tempo em muitas áreas de desenvolvimento: análise de fluxo de trabalho, arquitetura, design e implantação. O resultado serão sistemas mais fáceis de raciocinar, que potencialmente respondem mais rápido e de maneira mais confiável.





Procurando por simultaneidade


Em muitos projetos, precisamos modelar e analisar os fluxos de trabalho do aplicativo como parte do design. Gostaríamos de descobrir o que pode acontecer ao mesmo tempo e o que deve acontecer em uma ordem estrita. Uma maneira de fazer isso é capturar o fluxo de trabalho usando uma notação como o diagrama de atividades. [46]

Dica 56 Analise o fluxo de trabalho para melhorar a simultaneidade



Um diagrama de atividades consiste em um conjunto de ações desenhadas como caixas arredondadas. A seta que deixa uma ação leva a outra ação (que pode iniciar assim que a primeira ação for concluída) ou a uma linha espessa chamada barra de sincronização. Quando todas as ações que levam a uma barra de sincronização estiverem concluídas, você poderá prosseguir ao longo de todas as setas que saem da barra. Uma ação sem setas que levam a ele pode ser iniciada a qualquer momento.

Você pode usar diagramas de atividades para maximizar o paralelismo, identificando atividades que podem ser realizadas em paralelo, mas não são.

Por exemplo, podemos estar escrevendo o software para uma fabricante robótica de Piña Colada. Disseram -nos que as etapas são:

Liquidificador aberto

Mix de piña colada aberta

Coloque a mistura no liquidificador

Meça 1/2 xícara de rum branco

Despeje rum

Adicione 2 xícaras de gelo



Liquidificador próximo

Liquefazer por 1 minuto

Liquidificador aberto

Obtenha óculos

Obtenha guarda -chuvas rosa

Servir





No entanto, um barman perderia o emprego se seguisse essas etapas, uma a uma, em ordem. Embora descrevam essas ações em série, muitas delas poderiam ser realizadas em paralelo. Usaremos o seguinte diagrama de atividades para capturar e raciocinar sobre potencial simultaneidade.



Pode ser revelador ver onde as dependências realmente existem. Nesse caso, as tarefas de nível superior (1, 2, 4, 10 e 11) podem acontecer simultaneamente, na frente. As tarefas 3, 5 e 6 podem acontecer em paralelo mais tarde. Se você estivesse em um concurso de criação de Colada Piña, essas otimizações podem fazer toda a diferença.


Formatação mais rápida

Este livro está escrito em texto simples. Para construir a versão a ser impressa, ou um e -book, ou qualquer outra coisa, esse texto é alimentado através de um pipeline de processadores. Alguns procuram construções específicas (citações de bibliografia, entradas de índice, marcação especial para dicas e assim por diante). Outros processadores operam no documento como um todo.

Muitos dos processadores do pipeline precisam acessar informações externas (leitura de arquivos, escrevendo arquivos, passando por programas externos). Todo esse trabalho de velocidade relativamente lenta nos dá a oportunidade de explorar a simultaneidade: de fato, cada etapa do pipeline é executada simultaneamente, lendo a etapa anterior e escrevendo para a próxima.

Além disso, algumas partes do processo são relativamente intensivas em processador. Uma delas é a conversão de fórmulas matemáticas. Por várias razões históricas, cada equação pode levar até 500ms para converter. Para acelerar as coisas, aproveitamos o paralelismo. Como cada fórmula é independente dos outros, convertemos cada um em seu próprio processo paralelo e coletamos os resultados de volta ao livro à medida que estão disponíveis.

Como resultado, o livro constrói muito, muito mais rápido em máquinas multicore.

(E, sim, realmente descobrimos vários erros de simultaneidade em nosso pipeline ao longo do caminho….)





Oportunidades de simultaneidade


Os diagramas de atividades mostram as áreas potenciais de simultaneidade, mas não têm nada a dizer sobre se essas áreas valem a pena explorar. Por exemplo, no exemplo de Piña Colada, um barman precisaria de cinco mãos para poder executar todas as tarefas iniciais em potencial de uma só vez.

E é aí que entra a parte do design. Quando olhamos para as atividades, percebemos que o número 8, Liquify, levará um minuto. Durante esse período, nosso barman pode obter os óculos e guarda -chuvas (atividades 10 e 11) e provavelmente ainda tem tempo para servir outro cliente.

E é isso que procuramos quando estamos projetando a simultaneidade. Esperamos encontrar atividades que levem tempo, mas não o tempo em nosso código. Consultando um banco de dados, acessando um serviço externo, aguardando a entrada do usuário: todas essas coisas normalmente impediriam nosso programa até que sejam concluídas. E essas são todas as oportunidades de fazer algo mais produtivo do que o equivalente da CPU de girar os polegares.





Oportunidades de paralelismo


Lembrar
A distinção: a concorrência é um mecanismo de software e o paralelismo é uma preocupação de hardware. Se tivermos vários processadores, local ou remotamente, se pudermos dividir o trabalho entre eles, podemos reduzir o tempo geral que as coisas levam.

As coisas ideais para dividir dessa maneira são peças de trabalho que são relativamente independentes - onde cada um pode prosseguir sem esperar por nada dos outros. Um padrão comum é fazer um grande trabalho, dividi -lo em pedaços independentes, processar cada um em paralelo e combinar os resultados.

Um exemplo interessante disso na prática é a maneira como o compilador para a linguagem Elixir funciona. Quando começa, divide o projeto que está se formando em módulos e compila cada um em paralelo. Às vezes, um módulo depende de outro; nesse caso, sua compilação faz uma pausa até que os resultados da construção do outro módulo estejam disponíveis. Quando o módulo de nível superior é concluído, isso significa que todas as dependências foram compiladas. O resultado é uma compilação rápida que aproveita todos os núcleos disponíveis.





Identificar oportunidades é a parte mais fácil


De volta aos seus aplicativos. Identificamos lugares onde isso se beneficiará da simultaneidade e do paralelismo. Agora, para a parte complicada: como podemos implementá -la com segurança. Esse é o tópico do restante do capítulo.





Seções relacionadas incluem


Tópico 10, Ortogonalidade

Tópico 26, como equilibrar recursos

Tópico 28, dissociação

Tópico 36, Blackboards





Desafios


Quantas tarefas você executa em paralelo quando se prepara para o trabalho de manhã? Você poderia expressar isso em um diagrama de atividades UML? Você pode encontrar uma maneira de se preparar mais rapidamente, aumentando a simultaneidade?





Tópico 34

Estado compartilhado é um estado incorreto




Você está no seu restaurante favorito. Você termina seu prato principal e pergunta ao seu servidor se resta alguma torta de maçã. Ele olha por cima do ombro, vê uma peça na vitrine e diz que sim. Você pede e suspira contente.

Enquanto isso, do outro lado do restaurante, outro cliente faz o servidor a mesma pergunta. Ela também olha, confirma que há uma peça e que os pedidos de clientes.

Um dos clientes ficará desapontado.

Troque a vitrine de uma conta bancária conjunta e transforme o garçonete em dispositivos no ponto de venda. Você e seu parceiro decidem comprar um novo telefone ao mesmo tempo, mas há apenas o suficiente na conta de um. Alguém - o banco, a loja ou você - ficará muito infeliz.

Dica 57 O estado compartilhado é um estado incorreto



O problema é o estado compartilhado. Cada servidor do restaurante analisou a vitrine sem levar em consideração o outro. Cada dispositivo de ponto de venda analisou um saldo de conta sem levar em consideração o outro.





Atualizações não atômicas


Vejamos nosso exemplo de restaurante como se fosse código:



Os dois garçons operam simultaneamente (e, na vida real, em paralelo). Vejamos o código deles:

Se exibir_case.pie_count> 0

Promise_pie_to_customer ()

Display_case.take_pie ()

Give_pie_to_customer ()

Fim



O garçom 1 recebe a contagem atual de tortas e descobre que é uma. Ele promete a torta para o cliente. Mas nesse ponto, o garçom 2 corre. Ela também vê a contagem de tortas é uma e faz a mesma promessa para seu cliente. Um dos dois agarra o último pedaço de torta, e o outro garçom entra em algum tipo de estado de erro (que provavelmente envolve muita grife).

O problema aqui não é que dois processos possam gravar na mesma memória. O problema é que nenhum dos processos pode garantir que sua visão dessa memória seja consistente. Efetivamente, quando um garçom executa Display_Case.Pie_Count (), eles copiam o valor da vitrine em sua própria memória. Se o valor na vitrine mudar, sua memória (que eles estão usando para tomar decisões) agora estão desatualizados.

Tudo isso é porque a busca e a atualização da contagem de tortas não é uma operação atômica: o valor subjacente pode mudar no meio.

Então, como podemos torná -lo atômico?





Semáforos e outras formas de exclusão mútua


Um semáforo é simplesmente uma coisa que apenas uma pessoa pode possuir de cada vez. Você pode criar um semáforo e depois usá -lo para controlar o acesso a algum outro recurso. Em nosso exemplo, poderíamos criar um semáforo para controlar o acesso ao caso da torta e adotar a convenção de que quem deseja atualizar o conteúdo do caso da torta só pode fazê -lo se estiver mantendo esse semáforo.

Digamos que o restaurante decida resolver o problema da torta com um semáforo físico. Eles colocam um duende plástico no estojo da torta. Antes
Qualquer garçom pode vender uma torta, eles precisam estar segurando o duende na mão. Uma vez concluído o pedido (o que significa entregar a torta à mesa), eles podem devolver o duende ao seu local, guardando o tesouro das tortas, pronto para mediar a próxima ordem.

Vejamos isso no código. Classicamente, a operação para pegar o semáforo foi chamada P, e a operação para liberar foi chamada V. [47] Hoje, usamos termos como bloqueio/desbloqueio, reivindicação/liberação e assim por diante.

Case_semaphore.lock ()

​

Se exibir_case.pie_count> 0

Promise_pie_to_customer ()

Display_case.take_pie ()

Give_pie_to_customer ()

Fim

​

Case_semaphore.unlock ()



Este código pressupõe que um semáforo já tenha sido criado e armazenado na variável case_semaphore.

Vamos supor que os dois garçons executem o código ao mesmo tempo. Ambos tentam travar o semáforo, mas apenas um é bem -sucedido. O que recebe o semáforo continua a funcionar normalmente. O que não recebe o semáforo é suspenso até que o semáforo fique disponível (o garçom espera ...). Quando o primeiro garçom conclui o pedido, desbloqueia o semáforo e o segundo garçom continua em execução. Eles agora veem que não há torta no caso e pedem desculpas ao cliente.

Existem alguns problemas com essa abordagem. Provavelmente o mais significativo é que ele só funciona porque todos que acessa o caso PIE concordam na convenção de usar o semáforo. Se alguém esquece (ou seja, algum desenvolvedor escreve código que não segue a convenção), estamos de volta ao caos.





Fazer o recurso transacional


O design atual é ruim porque delega a responsabilidade de proteger o acesso ao caso da torta às pessoas que o usam. Vamos alterá -lo para centralizar esse controle. Para fazer isso, temos que alterar a API para que os garçons possam verificar a contagem e também fazer uma fatia de torta em uma única chamada:

Slice = display_case.get_pie_if_available ()

Se fatiar

Give_pie_to_customer ()

Fim



Para fazer isso funcionar, precisamos escrever um método que seja executado como parte da própria vitrine:

Def get_pie_if_available () ####

Se @slices.size> 0#

Update_sales_data (: torta)#

Retorne @slices.shift#

Else# código incorreto!

Falso#

Final#

END ####



Este código ilustra um equívoco comum. Mudamos o acesso de recursos para um lugar central, mas nosso método ainda pode ser chamado de vários tópicos simultâneos, por isso ainda precisamos protegê -lo com um semáforo:

Def get_pie_if_available ()

@Case_semaphore.lock ()

​

Se @slices.size> 0

Update_sales_data (: torta)

Retorne @slices.shift

Outra pessoa

Falso

Fim

​

@Case_semaphore.unlock ()

Fim



Mesmo esse código pode não estar correto. Se atualizar_sales_data aumentar uma exceção, o semáforo nunca será desbloqueado e todo o acesso futuro ao estojo da torta ficará indefinidamente. Precisamos lidar com isso:

Def get_pie_if_available ()

@Case_semaphore.lock ()

​

Tente {

Se @slices.size> 0

Update_sales_data (: torta)

Retorne @slices.shift

Outra pessoa

Falso

Fim

}

Garantir {

@Case_semaphore.unlock ()

}

Fim



Porque isso é um erro tão comum, muitos idiomas fornecem bibliotecas que lidam com isso para você:

Def get_pie_if_available ()

@Case_semaphore.protect () {

Se @slices.size> 0

Update_sales_data (: torta)

Retorne @slices.shift

Outra pessoa

Falso

Fim

}

Fim





Múltiplas transações de recursos


Nossa lanchonete acabou de instalar um freezer de sorvete. Se um cliente ordenar torta para o modo, o garçom precisará verificar se a torta e o sorvete estarão disponíveis.

Poderíamos mudar o código do garçom para algo como:

Slice = display_case.get_pie_if_available ()

Scoop = freezer.get_ice_cream_if_available ()

​

Se Slice && Scoop

Give_order_to_customer ()

Fim



Isso não funciona, no entanto. O que acontece se reivindicarmos uma fatia de torta, mas quando tentamos obter uma colher de sorvete que descobrimos que não existe? Agora ficamos segurando uma torta com a qual não podemos fazer nada (porque nosso cliente deve tomar sorvete). E o fato de estarmos segurando a torta significa que não está no caso, por isso não está disponível para outro cliente que (ser purista) não quer sorvete com ele.

Poderíamos consertar isso adicionando um método ao caso que nos permite retornar uma fatia de torta. Precisamos adicionar o manuseio de exceções para garantir que não mantenhamos recursos se algo falhar:

Slice = display_case.get_pie_if_available ()

​

Se
fatiar

Tente {

Scoop = freezer.get_ice_cream_if_available ()

Se escapar

Tente {

Give_order_to_customer ()

}

Resgate {

Freezer.give_back (scoop)

}

Fim

}

Resgate {

Display_case.give_back (fatia)

}

Fim



Novamente, isso é menos que o ideal. O código agora é realmente feio: descobrir o que realmente faz é difícil: a lógica de negócios está enterrada em todas as tarefas domésticas.

Anteriormente, corrigimos isso movendo o código de manuseio de recursos para o próprio recurso. Aqui, porém, temos dois recursos. Devemos colocar o código na vitrine ou no freezer?

Achamos que a resposta é "não" para as duas opções. A abordagem pragmática seria dizer que "Apple Pie à la Mode" é seu próprio recurso. Mudamos esse código para um novo módulo e, em seguida, o cliente pode apenas dizer "Pegue -me torta de maçã com sorvete" e ele é bem -sucedido ou falha.

É claro que, no mundo real, é provável que haja muitos pratos compostos como esse, e você não gostaria de escrever novos módulos para cada um. Em vez disso, você provavelmente deseja algum tipo de item de menu que continha referências aos seus componentes e, em seguida, tenha um método GET_MENU_ITEM GENERIC GEGNU_IVEM que faz a dança de recursos com cada um.





Atualizações não transacionais


É dada muita atenção à memória compartilhada como fonte de problemas de simultaneidade, mas, na verdade, os problemas podem aparecer em qualquer lugar em que o código do aplicativo compartilha recursos mutáveis: arquivos, bancos de dados, serviços externos e assim por diante. Sempre que duas ou mais instâncias do seu código podem acessar algum recurso ao mesmo tempo, você está analisando um problema em potencial.

Às vezes, o recurso não é tão óbvio. Ao escrever esta edição do livro, atualizamos a cadeia de ferramentas para fazer mais trabalho em paralelo usando threads. Isso fez com que a construção falhasse, mas de maneiras bizarras e lugares aleatórios. Um tópico comum em todos os erros foi que os arquivos ou diretórios não puderam ser encontrados, mesmo que eles estivessem realmente exatamente no lugar certo.

Nós rastreamos isso para alguns lugares no código que alteraram temporariamente o diretório atual. Na versão não paralela, o fato de esse código restaurar o diretório foi bom o suficiente. Mas na versão paralela, um thread alteraria o diretório e, enquanto nesse diretório, outro thread começaria a ser executado. Esse tópico esperaria estar no diretório original, mas como o diretório atual é compartilhado entre threads, esse não foi o caso.

A natureza desse problema leva outra dica:

Dica 58 falhas aleatórias são frequentemente problemas de simultaneidade





Outros tipos de acesso exclusivo


A maioria dos idiomas possui suporte da biblioteca para algum tipo de acesso exclusivo a recursos compartilhados. Eles podem chamá -lo de mutexes (para exclusão mútua), monitores ou semáforos. Tudo isso é implementado como bibliotecas.

No entanto, alguns idiomas têm suporte de simultaneidade incorporado ao próprio idioma. Rust, por exemplo, aplica o conceito de propriedade de dados; Apenas uma variável ou parâmetro pode manter uma referência a qualquer peça específica de dados mutáveis por vez.

Você também pode argumentar que os idiomas funcionais, com sua tendência a tornar todos os dados imutáveis, simplificarem a simultaneidade. No entanto, eles ainda enfrentam os mesmos desafios, porque em algum momento eles são forçados a entrar no mundo real e mutável.





Doutor, dói ...


Se você não tirar mais nada desta seção, aceite o seguinte: a simultaneidade em um ambiente de recursos compartilhados é difícil e gerenciá -lo está repleto de desafios.

É por isso que recomendamos a piada da velha piada:

Doutor, dói quando eu faço isso.



Então não faça isso.



As próximas duas seções sugerem maneiras alternativas de obter os benefícios da simultaneidade sem a dor.





Seções relacionadas incluem


Tópico 10, Ortogonalidade

Tópico 28, dissociação

Tópico 38, Programação por coincidência





Tópico 35

Atores e processos




Sem escritores, as histórias não seriam escritas,

Sem atores, as histórias não puderam ser trazidas à vida.



Angie-Marie Delsante



Atores e processos oferecem maneiras interessantes de implementar simultaneidade sem o ônus de sincronizar o acesso à memória compartilhada.

Antes de entrarmos neles, no entanto, precisamos definir o que queremos dizer. E isso vai parecer acadêmico. Não tema, estaremos trabalhando nisso em pouco tempo.

Um ator é um processador virtual independente com seu próprio estado local (e privado). Cada ator tem uma caixa de correio. Quando uma mensagem aparece na caixa de correio e o ator está ocioso, ela entra na vida e processa o
mensagem. Quando termina o processamento, processa outra mensagem na caixa de correio ou, se a caixa de correio estiver vazia, voltará a dormir.

Ao processar uma mensagem, um ator pode criar outros atores, enviar mensagens para outros atores que conhece e criar um novo estado que se tornará o estado atual quando a próxima mensagem for processada.



Um processo é tipicamente um processador virtual de uso mais geral, geralmente implementado pelo sistema operacional para facilitar a simultaneidade. Os processos podem ser restringidos (por convenção) de se comportar como atores, e esse é o tipo de processo que queremos dizer aqui.





Os atores só podem ser simultâneos


Existem algumas coisas que você não encontrará na definição de atores:

Não há uma única coisa que esteja no controle. Nada agenda o que acontece a seguir ou orquestra a transferência de informações dos dados brutos para a saída final.



O único estado do sistema é mantido em mensagens e no estado local de cada ator. As mensagens não podem ser examinadas, exceto por serem lidas por seu destinatário, e o estado local é inacessível fora do ator.



Todas as mensagens são de uma maneira - não há conceito de resposta. Se você deseja que um ator retorne uma resposta, inclua seu próprio endereço de caixa de correio na mensagem que você o envia e ele (eventualmente) enviará a resposta como apenas mais uma mensagem para essa caixa de correio.



Um ator processa cada mensagem até a conclusão e processa apenas uma mensagem de cada vez.





Como resultado, os atores executam simultaneamente, assíncronos e não compartilham nada. Se você tivesse processadores físicos suficientes, poderá administrar um ator em cada um. Se você possui um único processador, algum tempo de execução pode lidar com a troca de contexto entre eles. De qualquer maneira, o código em execução nos atores é o mesmo.

Dica 59 Use atores para simultaneidade sem estado compartilhado





Um ator simples


Vamos implementar nosso restaurante usando atores. Nesse caso, teremos três (o cliente, o garçom e o caso da torta).

O fluxo geral de mensagens ficará assim:

Nós (como algum tipo de ser externo e de Deus) dizemos ao cliente que eles estão com fome



Em resposta, eles pedem torta ao garçom



O garçom pedirá ao caso da torta para obter uma torta para o cliente



Se o caso da torta tiver uma fatia disponível, ele o enviará ao cliente e também notificará o garçom para adicioná -lo à conta



Se não houver torta, o caso diz ao garçom e o garçom pede desculpas ao cliente





Optamos para implementar o código em JavaScript usando a biblioteca NACT. [48] Adicionamos um pouco de invólucro a isso que nos permite escrever atores como objetos simples, onde as teclas são os tipos de mensagens que ele recebe e os valores são funções para executar quando essa mensagem específica for recebida. (A maioria dos sistemas de atores tem um tipo de estrutura semelhante, mas os detalhes dependem da linguagem do host.)

Vamos começar com o cliente. O cliente pode receber três mensagens:

Você está com fome (enviado pelo contexto externo)

Há torta na mesa (enviada pelo estojo da torta)

Desculpe, não há torta (enviada pelo garçom)



Aqui está o código:

Concorrente/atores/index.js

Const CustomerActor = {

'Faminto por torta': (msg, ctx, estado) => {

Dispatch Return (State.waiter,

{Tipo: "Order", Cliente: Ctx.self, quer: 'Pie'})

},

​

'Coloque na mesa': (msg, ctx, _state) =>

Console.log (`$ {ctx.self.name} vê" $ {msg.food} "aparece na tabela`),

​

'Sem torta saiu': (_msg, ctx, _state) =>

Console.log (`$ {ctx.self.name} fica de mau humor…`)

}



O caso interessante é quando recebemos uma mensagem "faminta por torta", onde enviamos uma mensagem para o garçom. (Veremos como o cliente sabe sobre o ator de garçom em breve.)

Aqui está o código do garçom:

Concorrente/atores/index.js

Const waiteractor = {

"Ordem": (msg, ctx, estado) => {

If (msg.wants == "torta") {

Dispatch (State.Piecase,

{Tipo: "Get Slice", Cliente: Msg.customer, garçom: ctx.self})

}

Else {

Console.dir (`não sei como pedir $ {msg.wants}`);

}

},

​

"Adicionar ao pedido": (msg, ctx) =>

Console.log (`Waiter adiciona $ {msg.food} a $ {msg.customer.name} 's order`),

​

"Erro": (msg, ctx) => {

Dispatch (msg.customer, {type: 'sem torta esquerda', msg: msg.msg});

Console.log (`\ nA garçom pede desculpas a $ {msg.customer.name}: $ {msg.msg}`)

}

​

};



Quando recebe a mensagem 'Pedido' do cliente, ele verifica se a solicitação é para torta. Nesse caso, ele envia uma solicitação ao caso da torta, passando referências a si mesma e ao cliente.

O caso da torta
tem estado: uma variedade de todas as fatias de torta que ele mantém. (Novamente, vemos como isso é configurado em breve.) Quando recebe uma mensagem 'Get Slice' do garçom, ele vê se tiver alguma fatia restante. Se isso acontecer, passa a fatia para o cliente, diz ao garçom para atualizar o pedido e, finalmente, retorna um estado atualizado, contendo uma fatia a menos. Aqui está o código:

Concorrente/atores/index.js

Const pequeaseActor = {

'Get Slice': (msg, contexto, estado) => {

If (state.slices.length == 0) {

Dispatch (msg.waiter,

{Tipo: 'Error', msg: "sem torta deixada", cliente: msg.customer})

Estado de retorno

}

Else {

Var slice = state.slices.shift () + "slice de torta";

Dispatch (msg.customer,

{Type: 'Coloque na mesa', comida: slice});

Dispatch (msg.waiter,

{TIPO: 'Adicione ao pedido', comida: fatia, cliente: msg.customer});

Estado de retorno;

}

}

}



Embora você ache que os atores são iniciados dinamicamente por outros atores, no nosso caso, vamos simplificar e iniciar nossos atores manualmente. Também passaremos a cada algum estado inicial:

O estojo da torta recebe a lista inicial de fatias de torta que ele contém

Vamos dar ao garçom uma referência ao caso da torta

Vamos dar aos clientes uma referência ao garçom



Concorrente/atores/index.js

Const ActorSystem = start ();

​

Deixe PiCase = start_actor (

ATORSYSTEM,

'Pie-Case',

PieSeActor,

{Slies: ["Apple", "Peach", "Cherry"]});

​

Deixe Waiter = start_actor (

ATORSYSTEM,

'Garçom',

WaiterActor,

{PiCase: PiTase});



Seja c1 = start_actor (atorsystem, 'cliente1',

CustomerActor, {Waiter: Waiter});

Seja c2 = start_actor (atorsystem, 'cliente2',

CustomerActor, {Waiter: Waiter});



E finalmente começamos. Nossos clientes são gananciosos. O cliente 1 pede três fatias de torta, e o cliente 2 pede dois:

Concorrente/atores/index.js

Despacho (c1, {type: 'faminto por torta', garçom: garçom});

Despacho (c2, {type: 'faminto por torta', garçom: garçom});

Despacho (c1, {type: 'faminto por torta', garçom: garçom});

Despacho (c2, {type: 'faminto por torta', garçom: garçom});

Despacho (c1, {type: 'faminto por torta', garçom: garçom});

Sono (500)

.Then (() => {

Pare (atorsystem);

})



Quando o executamos, podemos ver os atores se comunicando. [49] A ordem que você vê pode muito bem ser diferente:

$ Node index.js

Cliente1 vê "Apple Pie Slice" aparecer na mesa

Cliente2 vê "pêssego de pêssego" aparece na mesa

Garçom adiciona fatia de torta de maçã ao pedido do cliente1

Garçom adiciona fatia de torta de pêssego ao pedido do Cliente2

Cliente1 vê "Slice de torta de cereja" aparecer na mesa

Garçom adiciona fatia de torta de cereja ao pedido do cliente1

​

O garçom pede desculpas ao cliente1: Nenhuma torta foi embora

Cliente1 fica de mau humor…

​

O garçom pede desculpas ao cliente2: nenhuma torta foi embora

Cliente2 fica de mau humor…





Sem concorrência explícita


No modelo de ator, não há necessidade de escrever nenhum código para lidar com a simultaneidade, pois não há estado compartilhado. Também não há necessidade de codificar na lógica explícita de "Faça isso, faça isso", pois os atores trabalham por si mesmos com base nas mensagens que recebem.

Também não há menção à arquitetura subjacente. Esse conjunto de componentes funciona igualmente bem em um único processador, em vários núcleos ou em várias máquinas em rede.





Erlang prepara o cenário


O idioma e o tempo de execução de Erlang são ótimos exemplos de uma implementação de ator (mesmo que os inventores de Erlang não tenham lido o artigo do ator original). Erlang chama os processos dos atores, mas eles não são processos regulares do sistema operacional. Em vez disso, assim como os atores que discutimos, os processos Erlang são leves (você pode executar milhões deles em uma única máquina) e eles se comunicam enviando mensagens. Cada um é isolado dos outros, então não há compartilhamento de estado.

Além disso, o tempo de execução do Erlang implementa um sistema de supervisão, que gerencia a vida útil dos processos, potencialmente reiniciando um processo ou conjunto de processos em caso de falha. E Erlang também oferece carregamento de código a quente: você pode substituir o código em um sistema em execução sem interromper esse sistema. E o sistema Erlang executa alguns dos códigos mais confiáveis do mundo, geralmente citando nove nove anos.

Mas Erlang (e é elixir de progênie) não é único - existem implementações de atores para a maioria dos idiomas. Considere usá -los para suas implementações simultâneas.





Seções relacionadas incluem


Tópico 28, dissociação

Tópico 30, transformando
Programação

Tópico 36, Blackboards





Desafios


Você atualmente possui código que usa exclusão mútua para proteger dados compartilhados. Por que não tentar um protótipo do mesmo código escrito usando atores?



O código do ator para o restaurante suporta apenas encomendar fatias de torta. Estenda -o para permitir que os clientes pedam torta para o modo, com agentes separados gerenciando as fatias de torta e as bolas de sorvete. Organize as coisas para lidar com a situação em que um ou outro acaba.





Tópico 36

Blackboards




A escrita está na parede ...



Daniel 5 (Ref)



Considere como os detetives podem usar um quadro -negro para coordenar e resolver uma investigação de assassinato. O inspetor -chefe começa montando um grande quadro -negro na sala de conferências. Nele, ela escreve uma única pergunta:

H. Dumpty (homem, ovo): Acidente? Assassinato?



Humpty realmente caiu ou foi empurrado? Cada detetive pode fazer contribuições para esse potencial mistério de assassinato, adicionando fatos, declarações de testemunhas, qualquer evidência forense que possa surgir e assim por diante. À medida que os dados se acumulam, um detetive pode notar uma conexão e publicar essa observação ou especulação também. Esse processo continua, em todos os turnos, com muitas pessoas e agentes diferentes, até que o caso seja fechado. Um amostra de quadro -negro é mostrado na figura.

Figura 2. Alguém encontrou uma conexão entre as dívidas de jogo de Humpty e os registros do telefone. Talvez ele estivesse recebendo telefonemas ameaçadores.





Algumas características importantes da abordagem do quadro -negro são:

Nenhum dos detetives precisa conhecer a existência de qualquer outro detetive - eles assistem ao conselho para novas informações e adicionar suas descobertas.



Os detetives podem ser treinados em diferentes disciplinas, podem ter diferentes níveis de educação e experiência e podem nem trabalhar na mesma delegacia. Eles compartilham um desejo de resolver o caso, mas isso é tudo.



Detetives diferentes podem vir e vir durante o curso do processo e podem trabalhar em turnos diferentes.



Não há restrições ao que pode ser colocado no quadro -negro. Pode ser fotos, sentenças, evidências físicas e assim por diante.





Esta é uma forma de concorrência do laissez Faire. Os detetives são processos independentes, agentes, atores e assim por diante. Alguns armazenam fatos no quadro -negro. Outros tiram fatos do conselho, talvez combinando ou processando -os, e adicionam mais informações ao conselho. Gradualmente, o conselho os ajuda a chegar a uma conclusão.

Os sistemas Blackboard baseados em computador foram originalmente usados em aplicações de inteligência artificial, onde os problemas a serem resolvidos eram grandes e complexos-reconhecimento de discussão, sistemas de raciocínio baseados no conhecimento e assim por diante.

Um dos primeiros sistemas de quadro -negro foi a Linda, de David Gelernnter. Ele armazenou fatos como tuplas digitadas. Os aplicativos podem escrever novas tuplas em Linda e consultar as tuplas existentes usando uma forma de correspondência de padrões.

Mais tarde, veio sistemas distribuídos do tipo Blackboard, como Javaspaces e T Spaces. Com esses sistemas, você pode armazenar objetos Java ativos - não apenas dados - no quadro -negro e recuperá -los por correspondência parcial de campos (através de modelos e curingas) ou por subtipos. Por exemplo, suponha que você tenha um autor do tipo, que é um subtipo de pessoa. Você pode pesquisar um quadro -negro que contenha objetos da pessoa usando um modelo de autor com um valor de nome mais baixo de "Shakespeare".

Esses sistemas nunca decolaram, acreditamos, em parte, porque a necessidade de o tipo de processamento cooperativo simultâneo ainda não havia se desenvolvido.





Um quadro -negro em ação


Suponha que estamos escrevendo um programa para aceitar e processar pedidos de hipoteca ou empréstimo. As leis que governam essa área são odiosamente complexas, com governos federais, estaduais e locais tendo a sua opinião. O credor deve provar que eles divulgaram certas coisas e devem solicitar certas informações - mas não devem fazer certas outras perguntas e assim por diante.

Além do miasma da lei aplicável, também temos os seguintes problemas para enfrentar:

As respostas podem chegar em qualquer ordem. Por exemplo, consultas para uma verificação de crédito ou pesquisa de título podem levar uma quantidade substancial de tempo, enquanto itens como nome e endereço podem estar disponíveis imediatamente.



A coleta de dados pode ser feita por pessoas diferentes, distribuídas em diferentes escritórios, em diferentes fusos horários.



Algumas coleta de dados podem ser feitas automaticamente por outros sistemas. Esses dados também podem chegar de forma assíncrona.



No entanto, certos dados ainda podem depender de outros dados. Por exemplo, você
Pode não ser capaz de iniciar a pesquisa de título por um carro até obter uma prova de propriedade ou seguro.



A chegada de novos dados pode levantar novas questões e políticas. Suponha que a verificação de crédito volte com um relatório menos que brilhante; Agora você precisa dessas cinco formas extras e talvez uma amostra de sangue.





Você pode tentar lidar com todas as combinações e circunstâncias possíveis usando um sistema de fluxo de trabalho. Muitos desses sistemas existem, mas podem ser complexos e intensivos em programador. À medida que os regulamentos mudam, o fluxo de trabalho deve ser reorganizado: as pessoas podem ter que alterar seus procedimentos e o código com fio pode ter que ser reescrito.

Um quadro -negro, em combinação com um mecanismo de regras que encapsula os requisitos legais, é uma solução elegante para as dificuldades encontradas aqui. A ordem da chegada dos dados é irrelevante: quando um fato é publicado, ele pode desencadear as regras apropriadas. O feedback também é facilmente tratado: a saída de qualquer conjunto de regras pode postar no quadro -negro e causar o acionamento de regras ainda mais aplicáveis.

Dica 60 Use quadros negros para coordenar o fluxo de trabalho





Os sistemas de mensagens podem ser como quadros negros


Enquanto escrevemos esta segunda edição, muitos aplicativos são construídos usando serviços pequenos e desacoplados, todos se comunicando por meio de algum tipo de sistema de mensagens. Esses sistemas de mensagens (como Kafka e Nats) fazem muito mais do que simplesmente enviam dados de A para B. em particular, oferecem persistência (na forma de um log de eventos) e a capacidade de recuperar mensagens através de uma forma de correspondência de padrões. Isso significa que você pode usá -los como um sistema de quadro -negro e/ou como uma plataforma na qual você pode executar vários atores.





Mas não é tão simples ...


O ator e/ou o quadro -negro e/ou a abordagem de microsserviço da arquitetura remove uma classe inteira de possíveis problemas de simultaneidade de seus aplicativos. Mas esse benefício tem um custo. Essas abordagens são mais difíceis de raciocinar, porque grande parte da ação é indireta. Você descobrirá que isso ajuda a manter um repositório central de formatos de mensagem e/ou APIs, principalmente se o repositório puder gerar o código e a documentação para você. Você também precisará de boas ferramentas para poder rastrear mensagens e fatos à medida que progridem no sistema. (Uma técnica útil é adicionar um ID de rastreio exclusivo quando uma função comercial específica for iniciada e depois propagá -la a todos os atores envolvidos. Você poderá reconstruir o que acontece com os arquivos de log.)

Finalmente, esses tipos de sistema podem ser mais problemáticos para implantar e gerenciar, pois há mais peças móveis. Até certo ponto, isso é compensado pelo fato de que o sistema é mais granular e pode ser atualizado substituindo atores individuais, e não todo o sistema.





Seções relacionadas incluem


Tópico 28, dissociação

Tópico 29, manipulando o mundo real

Tópico 33, quebrando o acoplamento temporal

Tópico 35, atores e processos





Exercícios


Exercício 24 (resposta possível)

Um sistema de estilo de quadro negro seria apropriado para os seguintes aplicativos? Por que, ou por que não?

Processamento de imagem. Você gostaria de ter vários processos paralelos agarrar pedaços de uma imagem, processá -los e colocar o pedaço completo de volta.

Calendário de grupo. Você tem pessoas espalhadas por todo o mundo, em diferentes fusos horários e falando idiomas diferentes, tentando agendar uma reunião.

Ferramenta de monitoramento de rede. O sistema reúne estatísticas de desempenho e coleta relatórios de problemas, que os agentes usam para procurar problemas no sistema.





Desafios


Você usa sistemas de quadro -negro no mundo real - o quadro de mensagens da geladeira ou o grande quadro branco no trabalho? O que os torna eficazes? As mensagens são publicadas com um formato consistente? Isso importa?





Notas de rodapé


[46]

Embora a UML tenha desaparecido gradualmente, muitos de seus diagramas individuais ainda existem de uma forma ou de outra, incluindo o diagrama de atividades muito útil. Para obter mais informações sobre todos os tipos de diagrama UML, consulte o UML destilado: um breve guia para a linguagem de modelagem de objetos padrão [FOW04].



[47]

Os nomes P e V vêm das cartas iniciais das palavras holandesas. No entanto, há alguma discussão sobre exatamente quais palavras. O inventor da técnica, Edsger Dĳkstra, sugeriu a passagem e a prolaag para p, e vrijgave e possivelmente verhogênio para V.



[48]

https://github.com/ncthbrt/nact



[49]

Para executar este código, você também precisará de nossas funções de wrapper, que não são mostradas aqui. Você pode baixá -los em https://media.pragprog.com/titles/tpp20/code/concurrency/actors/index.js





Copyright © 2020
Pearson Education, Inc.





Capítulo 7



Enquanto você está codificando




A sabedoria convencional diz que, uma vez que um projeto está na fase de codificação, o trabalho é principalmente mecânico, transcrevendo o design em declarações executáveis. Achamos que essa atitude é a maior razão pela qual os projetos de software falham, e muitos sistemas acabam feios, ineficientes, mal estruturados, imobiliáveis ou simplesmente errados.

A codificação não é mecânica. Se fosse, todas as ferramentas de caso que as pessoas fixaram suas esperanças no início dos anos 80, teriam substituído os programadores há muito tempo. Há decisões a serem tomadas a cada minuto - decisões que exigem pensamento e julgamento cuidadosos se o programa resultante for desfrutar de uma vida longa, precisa e produtiva.

Nem todas as decisões são até conscientes. Você pode aproveitar melhor seus instintos e pensamentos não conscientes quando você tópico 37, ouça seu cérebro de lagarto. Veremos como ouvir com mais cuidado e procurar maneiras de responder ativamente a esses pensamentos às vezes insignificantes.

Mas ouvir seus instintos não significa que você pode simplesmente voar no piloto automático. Os desenvolvedores que não pensam ativamente em seu código estão programando por coincidência - o código pode funcionar, mas não há motivo específico. No tópico 38, programação por coincidência, defendemos um envolvimento mais positivo com o processo de codificação.

Enquanto a maioria do código que escrevemos é executado rapidamente, ocasionalmente desenvolvemos algoritmos que têm o potencial de atolar até os processadores mais rápidos. No tópico 39, velocidade do algoritmo, discutimos maneiras de estimar a velocidade do código e damos algumas dicas sobre como identificar possíveis problemas antes que eles aconteçam.

Programadores pragmáticos pensam criticamente sobre todo o código, incluindo o nosso. Vemos constantemente espaço para melhorias em nossos programas e projetos. No tópico 40, refatoração, analisamos técnicas que nos ajudam a consertar o código existente continuamente à medida que avançamos.

O teste não é encontrar bugs, é obter feedback sobre seu código: aspectos do design, API, acoplamento e assim por diante. Isso significa que os principais benefícios dos testes acontecem quando você pensa e escreve os testes, não apenas quando você os executa. Exploraremos essa ideia no tópico 41, teste para codificar.

Mas é claro que quando você testar seu próprio código, você pode trazer seus próprios preconceitos para a tarefa. No tópico 42, teste baseado em propriedades, veremos como fazer com que o computador faça alguns testes abrangentes para você e como lidar com os bugs inevitáveis que surgem.

É fundamental que você escreva o código legível e fácil de raciocinar. É um mundo duro por aí, cheio de maus atores que estão tentando ativamente invadir seu sistema e causar danos. Discutiremos algumas técnicas e abordagens muito básicas para ajudá -lo a tópico 43, manter -se seguro por aí.

Finalmente, uma das coisas mais difíceis no desenvolvimento de software é o tópico 44, nomeando as coisas. Temos que citar muitas coisas e, de muitas maneiras, os nomes que escolhemos definir a realidade que criamos. Você precisa ficar ciente de qualquer desvio semântico em potencial enquanto estiver codificando.

A maioria de nós pode dirigir um carro em grande parte no piloto automático; Não comandamos explicitamente nosso pé para pressionar um pedal ou nosso braço para virar a roda - apenas pensamos "desacelerar e virar à direita". No entanto, motoristas bons e seguros estão constantemente revisando a situação, verificando possíveis problemas e se colocando em boas posições, caso o inesperado aconteça. O mesmo se aplica à codificação - pode ser amplamente rotineiro, mas manter seu juízo sobre você pode impedir um desastre.





Tópico 37

Ouça seu cérebro de lagarto




Somente os seres humanos podem olhar diretamente para algo, ter todas as informações necessárias para fazer uma previsão precisa, talvez até momentaneamente fazer a previsão precisa e depois dizer que não é assim.



Gavin de Becker, o presente do medo



O trabalho da vida de Gavin de Becker está ajudando as pessoas a se proteger. Seu livro, O dom do medo: e outros sinais de sobrevivência que nos protegem da violência [de 98], encapsula sua mensagem. Um dos principais temas que atravessam o livro é que, como seres humanos sofisticados, aprendemos a ignorar nosso lado mais animal; Nossos instintos, nosso cérebro de lagarto. Ele afirma que a maioria das pessoas que são atacadas na rua está ciente de se sentir desconfortável ou nervoso antes do ataque. Essas pessoas apenas dizem que estão sendo bobas. Então a figura emerge da porta escura….

Os instintos são simplesmente uma resposta aos padrões embalados em nosso cérebro não consciente. Alguns são inatos, outros são aprendidos através da repetição. Conforme você ganha
Experiência como programador, seu cérebro está estabelecendo camadas de conhecimento tácito: coisas que funcionam, coisas que não funcionam, as prováveis causas de um tipo de erro, todas as coisas que você percebe ao longo de seus dias. Esta é a parte do seu cérebro que atinge a tecla Salvar Arquivos quando você para para conversar com alguém, mesmo quando você não percebe que está fazendo isso.

Qualquer que seja a fonte deles, os instintos compartilham uma coisa: eles não têm palavras. Instintos fazem você se sentir, não pensar. E assim, quando um instinto é acionado, você não vê uma lâmpada piscando com um banner envolvido em torno dele. Em vez disso, você fica nervoso, ou enjoado, ou sente que isso é muito trabalho.

O truque é o primeiro a perceber que está acontecendo e depois descobrir o porquê. Vejamos primeiro algumas situações comuns nas quais seu lagarto interno está tentando lhe dizer uma coisa. Em seguida, discutiremos como você pode deixar esse cérebro instintivo sair de seu invólucro protetor.





Medo da página em branco


Todo mundo teme a tela vazia, o cursor solitário piscando cercado por um monte de nada. Iniciar um novo projeto (ou mesmo um novo módulo em um projeto existente) pode ser uma experiência irritante. Muitos de nós preferem adiar o compromisso inicial de começar.

Achamos que existem dois problemas que causam isso e que ambos têm a mesma solução.

Um problema é que seu cérebro de lagarto está tentando lhe dizer uma coisa; Há algum tipo de dúvida à espreita logo abaixo da superfície da percepção. E isso é importante.

Como desenvolvedor, você está tentando as coisas e vendo o que funcionou e o que não funcionou. Você está acumulando experiência e sabedoria. Quando você sente uma dúvida incômoda ou experimenta alguma relutância quando se depara com uma tarefa, pode ser essa experiência tentando falar com você. Prestar atenção. Você pode não conseguir colocar o dedo exatamente o que está errado, mas dedique tempo e suas dúvidas provavelmente se cristalizarão em algo mais sólido, algo que você pode abordar. Deixe seus instintos contribuir para o seu desempenho.

O outro problema é um pouco mais prosaico: você pode simplesmente ter medo de cometer um erro.

E isso é um medo razoável. Nós, desenvolvedores, colocamos muito de nós mesmos em nosso código; Podemos levar erros nesse código como reflexões sobre nossa competência. Talvez haja um elemento de síndrome de impostor também; Podemos pensar que este projeto está além de nós. Não podemos ver o nosso caminho até o fim; Vamos chegar tão longe e depois seremos forçados a admitir que estamos perdidos.





Lutando a si mesmo


Às vezes, o código voa do seu cérebro para o editor: as idéias se tornam pedaços sem nenhum esforço.

Outros dias, a codificação parece subir em lama. Dar cada passo requer um esforço tremendo, e a cada três passos você desliza para trás dois.

Mas, sendo um profissional, você está do soldado, dando um passo após o passo de Muddy: você tem um emprego a fazer. Infelizmente, esse é provavelmente o oposto do que você deve fazer.

Seu código está tentando lhe dizer uma coisa. Está dizendo que isso é mais difícil do que deveria. Talvez a estrutura ou o design esteja errado, talvez você esteja resolvendo o problema errado, ou talvez esteja apenas criando bugs de uma fazenda de formigas. Seja qual for o motivo, seu cérebro de lagarto está sentindo o feedback do código e está tentando desesperadamente fazer com que você ouça.





Como falar de lagarto


Falamos muito sobre ouvir seus instintos, com seu cérebro não consciente e de lagarto. As técnicas são sempre as mesmas.

Dica 61 Ouça seu lagarto interno



Primeiro, pare o que você está fazendo. Dê a si mesmo um pouco de tempo e espaço para deixar seu cérebro se organizar. Pare de pensar no código e faça algo que seja bastante irracional por um tempo, longe de um teclado. Dê um passeio, almoça, converse com alguém. Talvez durma nele. Deixe as idéias percorrerem as camadas do seu cérebro por conta própria: você não pode forçá -lo. Eventualmente, eles podem borbulhar o nível consciente, e você tem um daqueles A Ha! momentos.

Se isso não estiver funcionando, tente externalizar o problema. Faça rabiscos sobre o código que você está escrevendo ou explique -o a um colega de trabalho (de preferência um que não seja um programador) ou ao seu pato de borracha. Exponha diferentes partes do seu cérebro ao problema e veja se algum deles tem uma melhor manuseio sobre o que está incomodando você. Perdemos o controle do número de conversas que tivemos onde um de nós estava explicando um problema para o outro e de repente foi "Oh! Claro!" e parou para consertar.

Mas talvez você tenha tentado essas coisas e ainda está preso. É hora de ação. Precisamos dizer ao seu cérebro que
O que você está prestes a fazer não importa. E fazemos isso por prototipagem.





É tempo de brincadeira!


Andy e Dave passaram horas olhando para os buffers de editor vazios. Vamos digitar algum código, depois olhar para o teto, depois obter mais uma bebida, depois digitar mais um código, depois ler uma história engraçada sobre um gato com duas caudas, depois digite mais um código, depois selecione-tudo/excluir e iniciar novamente. E novamente. E novamente.

E, ao longo dos anos, encontramos um hack do cérebro que parece funcionar. Diga a si mesmo que você precisa prototipar algo. Se você está enfrentando uma tela em branco, procure algum aspecto do projeto que deseja explorar. Talvez você esteja usando uma nova estrutura e queira ver como ela faz ligação de dados. Ou talvez seja um novo algoritmo, e você deseja explorar como ele funciona no limite. Ou talvez você queira experimentar alguns estilos diferentes de interação do usuário.

Se você está trabalhando no código existente e está recuando, esconda -o em algum lugar e prototipou algo semelhante.

Faça o seguinte.

Escreva "Estou prototipando" em uma nota pegajosa e coloque -a na lateral da tela.



Lembre -se de que os protótipos devem falhar. E lembre -se de que os protótipos são jogados fora, mesmo que não falhem. Não há desvantagem em fazer isso.



No seu buffer de editor vazio, crie um comentário descrevendo em uma frase o que você deseja aprender ou fazer.



Comece a codificar.





Se você começar a ter dúvidas, olhe para a nota adesiva.

Se, no meio da codificação, essa dúvida incômoda repentinamente se cristaliza em uma preocupação sólida, abordará.

Se você chegar ao final do experimento e ainda se sentir desconfortável, comece novamente com a caminhada e a conversa e o tempo de folga.

Mas, em nossa experiência, em algum momento durante o primeiro protótipo, você ficará surpreso ao se encontrar cantarolando junto com sua música, aproveitando a sensação de criar código. O nervosismo terá evaporado, substituído por uma sensação de urgência: vamos fazer isso!

Nesta fase, você sabe o que fazer. Exclua todo o código do protótipo, jogue fora a nota adesiva e preencha esse buffer de editor vazio com um novo código brilhante e brilhante.





Não apenas o seu código


Uma grande parte do nosso trabalho é lidar com o código existente, geralmente escrito por outras pessoas. Essas pessoas terão instintos diferentes para você e, portanto, as decisões que tomaram serão diferentes. Não necessariamente pior; apenas diferente.

Você pode ler o código deles mecanicamente, passando por ele fazendo anotações sobre coisas que parecem importantes. É uma tarefa árdua, mas funciona.

Ou você pode experimentar um experimento. Quando você identificar as coisas feitas de uma maneira que parece estranha, anote -as. Continue fazendo isso e procure padrões. Se você puder ver o que os levou a escrever código dessa maneira, pode achar que o trabalho de entender se torna muito mais fácil. Você poderá conscientemente aplicar os padrões que eles aplicaram tacitamente.

E você pode apenas aprender algo novo ao longo do caminho.





Não apenas código


Aprender a ouvir seu intestino quando a codificação é uma habilidade importante para promover. Mas isso se aplica ao quadro geral está bem. Às vezes, um design parece errado, ou algum requisito faz você se sentir desconfortável. Pare e analise esses sentimentos. Se você estiver em um ambiente de apoio, expresse -os em voz alta. Explore -os. As chances são de que há algo à espreita naquela porta escura. Ouça seus instintos e evite o problema antes que ele salte para você.





Seções relacionadas incluem


Tópico 13, protótipos e notas post-it

Tópico 22, Daybooks de engenharia

Tópico 46, resolvendo quebra -cabeças impossíveis





Desafios


Há algo que você sabe que deve fazer, mas adiou porque parece um pouco assustador ou difícil? Aplique as técnicas nesta seção. O horário o caixa a uma hora, talvez dois, e prometa a si mesmo que, quando a campainha tocar, você excluirá o que fez. O que você aprendeu?





Tópico 38

Programação por coincidência




Você já assistiu a antigos filmes de guerra em preto e branco? O soldado cansado avança cautelosamente do pincel. Há uma clareira à frente: há alguma minas terrestres ou é seguro atravessar? Não há indicações de que é um campo minado - nenhuma placa, arame farpado ou crateras. O soldado cutuca o chão à sua frente com sua baioneta e estreia, esperando uma explosão. Não há um. Então, ele prossegue minuciosamente pelo campo por um tempo, cutucando e cutucando enquanto avança. Eventualmente, convencido de que o campo está seguro, ele se endireita e marcha orgulhosamente para a frente, apenas para ser soprado em pedaços.

As sondas iniciais do soldado para minas reveladas
Nada, mas isso teve apenas sorte. Ele foi levado a uma conclusão falsa - com resultados desastrosos.

Como desenvolvedores, também trabalhamos em campos minados. Existem centenas de armadilhas esperando para nos pegar todos os dias. Lembrando a história do soldado, devemos ter cuidado ao tirar conclusões falsas. Devemos evitar a programação por coincidência - apenas com sorte e sucessos acidentais - em favor da programação deliberadamente.





Como programar por coincidência


Suponha que Fred receba uma atribuição de programação. Fred tipos em algum código, tenta e parece funcionar. Fred Tipe em um pouco mais de código, tenta e ainda parece funcionar. Após várias semanas de codificação dessa maneira, o programa para repentinamente para funcionar e, depois de horas tentando consertá -lo, ele ainda não sabe o porquê. Fred pode muito bem gastar um tempo significativo perseguindo esse código sem nunca conseguir corrigi -lo. Não importa o que ele faça, simplesmente não parece funcionar certo.

Fred não sabe por que o código está falhando porque ele não sabia por que funcionou em primeiro lugar. Parecia funcionar, dado o "teste" limitado que Fred fez, mas isso foi apenas uma coincidência. Impulsionada por falsa confiança, Fred atacou o esquecimento. Agora, a maioria das pessoas inteligentes pode conhecer alguém como Fred, mas sabemos melhor. Não dependemos de coincidências - nós?

Às vezes podemos. Às vezes, pode ser muito fácil confundir uma feliz coincidência com um plano intencional. Vejamos alguns exemplos.





Acidentes de implementação


Acidentes de implementação são coisas que acontecem simplesmente porque é assim que o código está atualmente gravado. Você acaba dependendo de erros não documentados ou condições de contorno.

Suponha que você chame uma rotina com dados ruins. A rotina responde de uma maneira específica e você codifica com base nessa resposta. Mas o autor não pretendia que a rotina funcionasse dessa maneira - nunca foi considerada. Quando a rotina é "corrigida", seu código pode quebrar. No caso mais extremo, a rotina que você chamou pode nem ser projetada para fazer o que você deseja, mas parece funcionar bem. Chamar as coisas na ordem errada ou no contexto errado é um problema relacionado.

Aqui parece que Fred está tentando desesperadamente colocar algo na tela usando alguma estrutura de renderização de GUI específica:

Pintura ();

Invalidate ();

Validate ();

Revalidate ();

Repintar ();

TaintImImedImed ();



Mas essas rotinas nunca foram projetadas para serem chamadas dessa maneira; Embora eles pareçam funcionar, isso é realmente apenas uma coincidência.

Para adicionar insulto à lesão, quando a cena finalmente é atraída, Fred não tenta voltar e fazer as ligações espúrias. "Funciona agora, é melhor sair bem o suficiente em paz ..." "

É fácil ser enganado por essa linha de pensamento. Por que você deve correr o risco de mexer com algo que está funcionando? Bem, podemos pensar em vários motivos:

Pode não estar realmente funcionando - pode parecer que é.



A condição de contorno em que você confia pode ser apenas um acidente. Em circunstâncias diferentes (uma resolução de tela diferente, mais núcleos da CPU), pode se comportar de maneira diferente.



O comportamento indocumentado pode mudar com a próxima versão da biblioteca.



Chamadas adicionais e desnecessárias tornam seu código mais lento.



Chamadas adicionais aumentam o risco de introduzir novos insetos próprios.





Para o código, você escreve que outras pessoas ligarão, os princípios básicos de boa modularização e ocultar a implementação por trás de pequenas interfaces bem documentadas podem ajudar. Um contrato bem especificado (ver tópico 23, projeto por contrato) pode ajudar a eliminar os mal-entendidos.

Para rotinas que você chama, confie apenas no comportamento documentado. Se você não puder, por qualquer motivo, documente bem sua suposição.





Perto o suficiente não está


Certa vez, trabalhamos em um grande projeto que relatou dados alimentados de um número muito grande de unidades de coleta de dados de hardware no campo. Essas unidades abrangem estados e fusos horários e, por várias razões logísticas e históricas, cada unidade foi definida para a hora local. [50] Como resultado de interpretações de fuso horário conflitantes e inconsistências nas políticas do horário de verão, os resultados quase sempre estavam errados, mas apenas fora de um. Os desenvolvedores do projeto tiveram o hábito de apenas adicionar um ou subtrair um para obter a resposta correta, raciocinando que ele só estava desligado por uma nesta situação. E então a próxima função veria o valor tão desligado pelo outro lado e alteraria -o de volta.

Mas o fato de ter sido "apenas" em um em algumas vezes foi uma coincidência, mascarando um mais profundo e mais
falha fundamental. Sem um modelo adequado de manuseio de tempo, toda a base de código grande se devolveu ao longo do tempo para uma massa insustentável de declarações +1 e -1. Por fim, nada disso estava correto e o projeto foi descartado.





Padrões fantasmas


Os seres humanos são projetados para ver padrões e causas, mesmo quando é apenas uma coincidência. Por exemplo, os líderes russos sempre se alternam entre ser careca e peluda: um líder estatal careca (ou obviamente careca) da Rússia sucedeu um não-BALD (“peludo”) e vice-versa por quase 200 anos. [51]

Mas, embora você não escrevesse código que dependia do próximo líder russo ser careca ou peludo, em alguns domínios, pensamos assim o tempo todo. Os jogadores imaginam padrões em números de loteria, jogos de dados ou roleta, quando na verdade esses são eventos estatisticamente independentes. Nas finanças, as negociações de ações e títulos são igualmente repletas de coincidência em vez de padrões reais e discerníveis.

Um arquivo de log que mostra um erro intermitente a cada 1.000 solicitações pode ser uma condição de corrida difícil de diagnosticar ou pode ser um bug antigo. Testes que parecem passar sua máquina, mas não no servidor, podem indicar uma diferença entre os dois ambientes, ou talvez seja apenas uma coincidência.

Não assuma, prove.





Acidentes de contexto


Você também pode ter "acidentes de contexto". Suponha que você esteja escrevendo um módulo de utilitário. Só porque você está codificando um ambiente da GUI, o módulo precisa confiar em uma GUI estar presente? Você está confiando em usuários de língua inglesa? Usuários alfabetizados? O que mais você está confiando que não é garantido?

Você está confiando no diretório atual sendo gravável? Em determinadas variáveis de ambiente ou arquivos de configuração estão presentes? No tempo, o servidor é preciso - em que tolerância? Você está confiando na disponibilidade e velocidade da rede?

Quando você copiou o código da primeira resposta que encontrou na rede, tem certeza de que seu contexto é o mesmo? Ou você está construindo código de “culto de carga”, apenas imitando a forma sem conteúdo? [52]

Encontrar uma resposta que se encaixe não é a mesma que a resposta certa.

Dica 62 Não programe por coincidência





Suposições implícitas


As coincidências podem enganar em todos os níveis - desde a geração de requisitos até os testes. Os testes estão particularmente repletos de causalidades falsas e resultados coincidentes. É fácil assumir que X causa Y, mas como dissemos no tópico 20, depuração: não assuma, prove.

Em todos os níveis, as pessoas operam com muitas suposições em mente - mas essas suposições raramente são documentadas e geralmente estão em conflito entre diferentes desenvolvedores. As suposições que não se baseiam em fatos bem estabelecidos são a desgraça de todos os projetos.





Como programar deliberadamente


Queremos gastar menos tempo produzindo código, capturar e corrigir erros o mais cedo possível no ciclo de desenvolvimento e criar menos erros para começar. Ajuda se pudermos programar deliberadamente:

Sempre esteja ciente do que você está fazendo. Fred deixou as coisas ficarem lentamente fora de controle, até que ele acabou fervido, como o sapo aqui.



Você pode explicar o código, em detalhes, para um programador mais júnior? Caso contrário, talvez você esteja confiando em coincidências.



Não codifique no escuro. Crie um aplicativo que você não compreenda totalmente ou usa uma tecnologia que não entende e provavelmente será mordido por coincidências. Se você não sabe por que funciona, não saberá por que falha.



Prossiga de um plano, se esse plano está em sua cabeça, na parte de trás de um guardanapo de coquetel ou em um quadro branco.



Confie apenas em coisas confiáveis. Não depende de suposições. Se você não sabe dizer se algo é confiável, assuma o pior.



Documentar suas suposições. Tópico 23, design por contrato, pode ajudar a esclarecer suas suposições em sua própria mente, além de ajudar a comunicá -las a outras pessoas.



Não apenas teste seu código, mas teste suas suposições também. Não adivinhe; realmente tente. Escreva uma afirmação para testar suas suposições (consulte o tópico 25, programação assertiva). Se sua afirmação estiver correta, você melhorou a documentação em seu código. Se você descobrir que sua suposição está errada, conte -se com sorte.



Priorize seu esforço. Gastar tempo nos aspectos importantes; Mais do que provável, essas são as partes difíceis. Se você não tiver fundamentos ou infraestrutura correta, sinos e assobios brilhantes serão irrelevantes.



Não seja escravo da história. Não deixe que o código existente dite o código futuro. Todo o código pode ser substituído se não for mais apropriado. Mesmo dentro de um programa, não deixe o que você tem
Já é feito restringir o que você faz a seguir - esteja pronto para refatorar (consulte o tópico 40, refatoração). Esta decisão pode afetar o cronograma do projeto. A suposição é que o impacto será menor que o custo de não fazer a mudança. [53]





Então, da próxima vez que algo parecer funcionar, mas você não sabe por que, verifique se não é apenas uma coincidência.





Seções relacionadas incluem


Tópico 4, sopa de pedra e sapos cozidos

Tópico 9, seco - os males de duplicação

Tópico 23, projeto por contrato

Tópico 34, Estado compartilhado é um estado incorreto

Tópico 43, fique seguro lá fora





Exercícios


Exercício 25 (resposta possível)

Um feed de dados de um fornecedor fornece uma variedade de tuplas representando pares de valor-chave. A chave do depositAccount manterá uma sequência do número da conta no valor correspondente:

[[

...

{: DepositAccount, "564-904-143-00"}

...

]



Funcionou perfeitamente no teste nos laptops de desenvolvedor de 4 núcleos e na máquina de construção de 12 núcleos, mas nos servidores de produção em execução em contêineres, você continua recebendo os números de conta errados. O que está acontecendo?

Exercício 26 (resposta possível)

Você está codificando um autodialista para alertas de voz e precisa gerenciar um banco de dados de informações de contato. A ITU especifica que os números de telefone não devem ter mais de 15 dígitos; portanto, você armazena o número de telefone do contato em um campo numérico garantido para manter pelo menos 15 dígitos. Você testou minuciosamente em toda a América do Norte e tudo parece bem, mas de repente está recebendo uma série de reclamações de outras partes do mundo. Por que?

Exercício 27 (resposta possível)

Você escreveu um aplicativo que amplia receitas comuns para uma sala de jantar de navio de cruzeiro com 5.000 anos. Mas você está recebendo queixas de que as conversões não são precisas. Você verifica e o código usa a fórmula de conversão de 16 xícaras em um galão. É isso mesmo, não é?





Tópico 39

Velocidade do algoritmo




No tópico 15, estimando, conversamos sobre estimar coisas como o tempo que leva para atravessar a cidade ou quanto tempo um projeto levará para terminar. No entanto, há outro tipo de estimativa de que os programadores pragmáticos usam quase diariamente: estimando os recursos que os algoritmos usam - tempo, processador, memória e assim por diante.

Esse tipo de estimativa geralmente é crucial. Dada a escolha entre duas maneiras de fazer algo, o que você escolhe? Você sabe quanto tempo seu programa vai com 1.000 registros, mas como ele será escalado para 1.000.000? Quais partes do código precisam otimizar?

Acontece que essas perguntas geralmente podem ser respondidas usando o senso comum, algumas análises e uma maneira de escrever aproximações chamadas notação Big-O.





O que queremos dizer com estimativa de algoritmos?


A maioria dos algoritmos não triviais lida com algum tipo de entrada variável -strings de resistência, invertendo uma matriz ou descriptografando uma mensagem com uma chave -bit. Normalmente, o tamanho dessa entrada afeta o algoritmo: quanto maior a entrada, maior o tempo de execução ou mais a memória usada.

Se o relacionamento sempre fosse linear (para que o tempo aumentasse em proporção direta ao valor de), esta seção não seria importante. No entanto, a maioria dos algoritmos significativos não é linear. A boa notícia é que muitos são sublineares. Uma pesquisa binária, por exemplo, não precisa olhar para todos os candidatos ao encontrar uma partida. A má notícia é que outros algoritmos são consideravelmente piores que lineares; Os tempo de execução ou os requisitos de memória aumentam muito mais rápido que. Um algoritmo que leva um minuto para processar dez itens pode levar uma vida inteira para processar 100.

Descobrimos que sempre que escrevemos qualquer coisa que contenha loops ou chamadas recursivas, subconscientemente verificamos os requisitos de tempo de execução e memória. Este raramente é um processo formal, mas uma confirmação rápida de que o que estamos fazendo é sensato nas circunstâncias. No entanto, às vezes nos encontramos realizando uma análise mais detalhada. É quando a notação Big-O é útil.





Notação Big-O


A notação Big-O, escrita, é uma maneira matemática de lidar com aproximações. Quando escrevemos que uma rotina de classificação específica classifica os registros a tempo, estamos simplesmente dizendo que o pior tempo necessário variará como o quadrado de. O dobro do número de registros e o tempo aumentará aproximadamente quatro vezes. Pense no significado como na ordem de.

A notação coloca um limite superior no valor da coisa que estamos medindo (tempo, memória e assim por diante). Se dissermos que uma função leva tempo, sabemos que o limite superior do tempo que leva não crescerá mais rápido do que. Às vezes, criamos funções bastante complexas, mas
Como o termo de ordem mais alta dominará o valor como aumenta, a convenção é remover todos os termos de ordem baixa e não se preocupar em mostrar nenhum fator de multiplicação constante:



Na verdade, esse é um recurso da notação - um algoritmo pode ser 1.000 vezes mais rápido que outro algoritmo, mas você não saberá da notação. O Big-O nunca fornecerá números reais para tempo ou memória ou o que for: simplesmente informa como esses valores mudarão à medida que a entrada muda.

Figura 3, os tempos de execução de vários algoritmos mostram várias notações comuns que você encontrará, juntamente com um gráfico comparando tempos de execução de algoritmos em cada categoria. Claramente, as coisas rapidamente começam a ficar fora de mão assim que acabarmos.

Por exemplo, suponha que você tenha uma rotina que leva um segundo para processar 100 registros. Quanto tempo levará para processar 1.000? Se o seu código for, ainda levará um segundo. Se for, você provavelmente estará esperando cerca de três segundos. mostrará um aumento linear para dez segundos, enquanto um levará cerca de 33 segundos. Se você é de azar o suficiente para ter uma rotina, sente -se por 100 segundos enquanto faz o seu material. E se você estiver usando um algoritmo exponencial, convém fazer uma xícara de café - sua rotina deve terminar em cerca de anos. Deixe -nos saber como o universo termina.

A notação não se aplica apenas ao tempo; Você pode usá -lo para representar quaisquer outros recursos usados por um algoritmo. Por exemplo, geralmente é útil poder modelar o consumo de memória (consulte os exercícios para um exemplo).



Constante (elemento de acesso na matriz, declarações simples)



Logarítmico (pesquisa binária). A base do logaritmo não importa, então isso é equivalente.





Linear (pesquisa seqüencial)



Pior que linear, mas não muito pior. (Tempo de execução média do Quicksort, Heapsort)



Lei quadrada (tipo de seleção e inserção)



Cúbico (multiplicação de duas matrizes)





Exponencial (Problema de Vendas Viajantes, Partição de Definir)



Figura 3. Tempos de execução de vários algoritmos





Estimativa do senso comum


Você pode estimar a ordem de muitos algoritmos básicos usando o senso comum.

Loops simples

Se um loop simples for de para, então o algoritmo provavelmente será - o tempo aumenta linearmente. Os exemplos incluem pesquisas exaustivas, encontrar o valor máximo em uma matriz e gerar somas de verificação.



Loops aninhados

Se você aninhar um loop dentro de outro, seu algoritmo se tornará, onde e são os limites dos dois loops. Isso geralmente ocorre em algoritmos simples de classificação, como o tipo de bolha, onde o loop externo digitaliza cada elemento na matriz por sua vez, e o loop interno trabalha onde colocar esse elemento no resultado classificado. Tais algoritmos de classificação tendem a ser.



Costeleta binária

Se o seu algoritmo metve o conjunto de coisas que considera sempre ao redor do loop, é provável que seja logarítmico. Uma busca binária de uma lista classificada, atravessando uma árvore binária e encontrando o primeiro bit em uma palavra da máquina pode ser.



Dividir e conquistar

Algoritmos que particionam seu trabalho de entrada nas duas metades de forma independente e, em seguida, combinam o resultado. O exemplo clássico é o QuickSort, que funciona particionando os dados em duas metades e classificando recursivamente cada um. Embora tecnicamente, como seu comportamento se degrada quando é alimentado com entrada classificada, o tempo médio de execução do QuickSort é.



Combinatório

Sempre que os algoritmos começam a olhar para as permutações das coisas, seus tempos de corrida podem ficar fora de controle. Isso ocorre porque as permutações envolvem fatoriais (existem permutações dos dígitos de 1 a 5). Tempo um algoritmo combinatório para cinco elementos: levará seis vezes mais para executá -lo por seis e 42 vezes mais por sete. Os exemplos incluem algoritmos para muitos dos problemas difíceis reconhecidos - o problema do vendedor ambulante, colocando as coisas de maneira ideal em um contêiner, particionando um conjunto de números para que cada conjunto tenha o mesmo total e assim por diante. Freqüentemente, as heurísticas são usadas para reduzir os tempos de execução desses tipos de algoritmos em domínios de problemas específicos.





Velocidade de algoritmo na prática


É improvável que você passe muito tempo durante sua carreira escrevendo rotinas de classificação. Os das bibliotecas disponíveis para você provavelmente superarão qualquer coisa que possa escrever sem esforço substancial. No entanto, os tipos básicos de algoritmos que descrevemos anteriores aparecem várias vezes. Sempre que você se encontra escrevendo um loop simples, sabe que tem um algoritmo. Se esse loop contiver um loop interno, você estará olhando. Você deveria ser
perguntando a si mesmo o tamanho desses valores. Se os números forem delimitados, você saberá quanto tempo o código levará para ser executado. Se os números dependem de fatores externos (como o número de registros em uma execução do lote noturno ou o número de nomes em uma lista de pessoas), convém parar e considerar o efeito que grandes valores podem ter no seu tempo de execução ou no consumo de memória.

Dica 63 Estime a ordem de seus algoritmos



Existem algumas abordagens que você pode adotar para resolver possíveis problemas. Se você possui um algoritmo, tente encontrar uma abordagem de divisão e conquista que o levará.

Se você não tiver certeza de quanto tempo seu código levará ou quanta memória ele usará, tente executá -lo, variando a contagem de registros de entrada ou o que provavelmente afetará o tempo de execução. Em seguida, plote os resultados. Em breve, você deve ter uma boa idéia da forma da curva. Está curvando -se para cima, uma linha reta ou achatando à medida que o tamanho da entrada aumenta? Três ou quatro pontos devem lhe dar uma ideia.

Considere também exatamente o que você está fazendo no próprio código. Um loop simples pode ter um desempenho melhor que um complexo, um para valores menores de, principalmente se o algoritmo tiver um loop interno caro.

No meio de toda essa teoria, não se esqueça que também existem considerações práticas. O tempo de execução pode parecer que aumenta linearmente para pequenos conjuntos de entrada. Mas alimente o código milhões de registros e, de repente, o tempo se degrada quando o sistema começa a bater. Se você testar uma rotina de classificação com teclas de entrada aleatória, poderá se surpreender na primeira vez que encontrar a entrada encomendada. Tente cobrir as bases teóricas e práticas. Depois de toda essa estimativa, o único momento que conta é a velocidade do seu código, em execução no ambiente de produção, com dados reais. Isso leva à nossa próxima dica.

Dica 64 Teste suas estimativas



Se for complicado obter horários precisos, use os Profilers de código para contar o número de vezes que as diferentes etapas do seu algoritmo são executadas e plote esses números em relação ao tamanho da entrada.





O melhor nem sempre é o melhor


Você também precisa ser pragmático em escolher algoritmos apropriados - a mais rápida nem sempre é a melhor para o trabalho. Dado um pequeno conjunto de entrada, um tipo de inserção direto terá um desempenho tão bom quanto um Quicksort e levará menos tempo para escrever e depurar. Você também precisa ter cuidado se o algoritmo escolhido tiver um alto custo de configuração. Para pequenos conjuntos de entrada, essa configuração pode diminuir o tempo de execução e tornar o algoritmo inadequado.

Também tenha cuidado com a otimização prematura. É sempre uma boa ideia garantir que um algoritmo seja realmente um gargalo antes de investir seu precioso tempo tentando melhorá -lo.





Seções relacionadas incluem


Tópico 15, estimativa





Desafios


Todo desenvolvedor deve ter uma idéia de como os algoritmos são projetados e analisados. Robert Sedgewick escreveu uma série de livros acessíveis sobre o assunto (algoritmos [SW11] uma introdução à análise de algoritmos [SF13] e outros). Recomendamos adicionar um de seus livros à sua coleção e fazer questão de ler.



Para quem gosta de mais detalhes do que Sedgewick, leia a arte definitiva de Donald Knuth dos livros de programação de computadores, que analisam uma ampla gama de algoritmos.

The Art of Computer Programming, Volume 1: Algoritmos Fundamentais [KNU98]

The Art of Computer Programming, Volume 2: Algoritmos Seminuméricos [KNU98A]

The Art of Computer Programming, Volume 3: Classificação e pesquisa [KNU98B]

A arte da programação de computadores, volume 4A: algoritmos combinatórios, Parte 1 [KNU11].





No primeiro exercício a seguir, olhamos para classificar matrizes de números inteiros longos. Qual é o impacto se as chaves são mais complexas e a sobrecarga da comparação chave é alta? A estrutura -chave afeta a eficiência dos algoritmos de classificação, ou o tipo mais rápido é sempre mais rápido?





Exercícios


Exercício 28 (possível resposta)

Codificamos um conjunto de rotinas simples de classificação [54] em ferrugem. Execute -os em várias máquinas disponíveis para você. Seus números seguem as curvas esperadas? O que você pode deduzir sobre as velocidades relativas de suas máquinas? Quais são os efeitos de várias configurações de otimização do compilador?

Exercício 29 (resposta possível)

Na estimativa do senso comum, afirmamos que uma costeleta binária é. Você pode provar isso?

Exercício 30 (resposta possível)

Na Figura 3, os tempos de execução de vários algoritmos, afirmamos que é o mesmo que (ou mesmo logaritmos para qualquer base). Você pode explicar por quê?





Tópico 40

Refatorando




Mudança e
decadência em todo o redor, eu vejo ...



H. F. Lyte, permaneça comigo



À medida que um programa evolui, será necessário repensar as decisões anteriores e refazer partes do código. Esse processo é perfeitamente natural. O código precisa evoluir; Não é uma coisa estática.

Infelizmente, a metáfora mais comum para o desenvolvimento de software é a construção de edifícios. A construção clássica de software orientada a objetos de trabalho de Bertrand Meyer [Mey97] usa o termo "construção de software" e até seus humildes autores editaram a coluna de construção de software para o software IEEE no início dos anos 2000. [55]

Mas o uso da construção como a metáfora orientadora implica as seguintes etapas:

Um arquiteto elabora plantas.



Os contratados cavam a fundação, criam a superestrutura, o arame e a prumo e aplique os toques finais.



Os inquilinos se mudam e vivem felizes para sempre, chamando a manutenção da construção para resolver qualquer problema.





Bem, o software não funciona dessa maneira. Em vez de construção, o software é mais como jardinagem - é mais orgânico do que concreto. Você planta muitas coisas em um jardim de acordo com um plano e condições iniciais. Alguns prosperam, outros estão destinados a acabar como composto. Você pode mover plantações em relação um ao outro para aproveitar a interação de luz e sombra, vento e chuva. As plantas cobertas de vegetação são divididas ou podadas, e as cores que o Clash podem ser movidas para locais mais esteticamente agradáveis. Você puxa ervas daninhas e fertiliza plantações que precisam de ajuda extra. Você constantemente monitorou a saúde do jardim e faz ajustes (para o solo, as plantas, o layout), conforme necessário.

Os empresários se sentem confortáveis com a metáfora da construção de edifícios: é mais científico que a jardinagem, é repetível, há uma rígida hierarquia de relatórios para a gerência e assim por diante. Mas não estamos construindo arranha -céus - não somos tão limitados pelos limites da física e pelo mundo real.

A metáfora da jardinagem está muito mais próxima das realidades do desenvolvimento de software. Talvez uma certa rotina tenha crescido demais ou esteja tentando realizar demais - precisa ser dividido em dois. Coisas que não funcionam como planejadas precisam ser eliminadas ou podadas.

Reescrever, retrabalhar e re-arquitetar o código é conhecido coletivamente como reestruturação. Mas há um subconjunto dessa atividade que se tornou praticada como refatoração.

A refatoração [Fow19] é definida por Martin Fowler como A:

Técnica disciplinada para reestruturar um corpo de código existente, alterando sua estrutura interna sem alterar seu comportamento externo.



As partes críticas desta definição são que:

A atividade é disciplinada, não um livre para todos



O comportamento externo não muda; Este não é hora de adicionar recursos





A refatoração não se destina a ser uma atividade especial e de alta cerimônia, uma vez no que, como arar em todo o jardim, a fim de replantar. Em vez disso, a refatoração é uma atividade do dia-a-dia, dando pequenos passos de baixo risco, mais como ervas daninhas e raking. Em vez de uma reescrita gratuita e atacadista da base de código, é uma abordagem de precisão direcionada para ajudar a manter o código fácil de alterar.

Para garantir que o comportamento externo não mudou, você precisa de testes de unidade bons e automatizados que validam o comportamento do código.





Quando você deve refatorar?


Você refatora quando aprendeu algo; Quando você entende algo melhor do que no ano passado, ontem, ou apenas dez minutos atrás.

Talvez você tenha encontrado um obstáculo porque o código não se encaixa mais, ou você percebe duas coisas que realmente deveriam ser mescladas, ou qualquer outra coisa atinge você como "errada", não hesite em mudá -lo. Não há tempo como o presente. Qualquer número de coisas pode fazer com que o código se qualifique para a refatoração:

Duplicação

Você descobriu uma violação do princípio seco.



Design não ortogonal

Você descobriu algo que poderia ser mais ortogonal.



Conhecimento desatualizado

As coisas mudam, a deriva dos requisitos e seu conhecimento do problema aumenta. O código precisa acompanhar.



Uso

À medida que o sistema é usado por pessoas reais em circunstâncias reais, você percebe que alguns recursos agora são mais importantes do que se pensava anteriormente, e os recursos "devem ter" talvez não fossem.



Desempenho

Você precisa mover a funcionalidade de uma área do sistema para outra para melhorar o desempenho.



Os testes passam

Sim. Seriamente. Dizemos que a refatoração deveria ser uma atividade em pequena escala, apoiada por bons testes. Então, quando você adicionou uma pequena quantidade de código, e isso
Um teste extra passa, agora você tem uma ótima oportunidade de mergulhar e arrumar o que você acabou de escrever.





Refatorar seu código - movendo funcionalidade e atualização de decisões anteriores - é realmente um exercício no gerenciamento da dor. Vamos ser sinceros, mudar o código -fonte pode ser bastante doloroso: estava funcionando, talvez seja melhor sair bem o suficiente. Muitos desenvolvedores relutam em entrar e reabrir um código de código apenas porque não está certo.





Complicações do mundo real


Então você vai aos seus companheiros de equipe ou cliente e diz: "Esse código funciona, mas preciso de mais uma semana para refatorá -lo completamente".

Não podemos imprimir a resposta deles.

A pressão do tempo é frequentemente usada como desculpa para não refatorar. Mas essa desculpa simplesmente não se sustenta: não é de refatorar agora, e haverá um investimento muito maior para resolver o problema - quando há mais dependências a serem consideradas. Haverá mais tempo disponível então? Não.

Você pode explicar esse princípio a outras pessoas usando uma analogia médica: pense no código que precisa ser refatorado como "um crescimento". Remover requer cirurgia invasiva. Você pode entrar agora e retirá -lo enquanto ainda é pequeno. Ou você pode esperar enquanto cresce e se espalha - mas removê -lo será mais caro e mais perigoso. Espere ainda mais e você pode perder o paciente completamente.

Dica 65 Refactor cedo, refactor frequentemente



Os danos colaterais no código podem ser igualmente mortais com o tempo (consulte o tópico 3, entropia de software). A refatoração, como na maioria das coisas, é mais fácil de fazer, enquanto os problemas são pequenos, como uma atividade contínua durante a codificação. Você não deve precisar de "uma semana para refatorar" um código de código-isso é uma reescrita completa. Se esse nível de interrupção for necessário, você não poderá fazê -lo imediatamente. Em vez disso, verifique se ele é colocado no cronograma. Certifique -se de que os usuários do código afetado saibam que ele está programado para ser reescrito e como isso pode afetá -los.





Como você refatora?


A refatoração começou na comunidade Smalltalk e acabara de começar a ganhar um público mais amplo quando escrevemos a primeira edição deste livro, provavelmente graças ao primeiro livro importante sobre refatoração (refatoração: melhorando o design do código existente [Fow19], agora em sua segunda edição).

No seu coração, a refatoração é redesenho. Qualquer coisa que você ou outras pessoas em sua equipe projetadas possam ser redesenhadas à luz de novos fatos, entendimentos mais profundos, requisitos de mudança e assim por diante. Mas se você continuar a rasgar grandes quantidades de código com abandono selvagem, poderá se encontrar em uma posição pior do que quando começou.

Claramente, a refatoração é uma atividade que precisa ser realizada lenta, deliberadamente e cuidadosamente. Martin Fowler oferece as seguintes dicas simples sobre como refatorar sem fazer mais mal do que bem: [56]

Não tente refatorar e adicionar funcionalidade ao mesmo tempo.



Certifique -se de ter bons testes antes de começar a refatorar. Execute os testes o mais rápido possível. Dessa forma, você saberá rapidamente se suas alterações quebraram alguma coisa.



Tome etapas curtas e deliberadas: mova um campo de uma classe para outra, divida um método, renomeie uma variável. A refatoração geralmente envolve fazer muitas alterações localizadas que resultam em uma mudança em maior escala. Se você mantiver seus passos pequenos e testar após cada etapa, evitará depuração prolongada. [57]





Refatoração automática

De volta à primeira edição, observamos que "essa tecnologia ainda não apareceu fora do mundo de Smalltalk, mas isso provavelmente mudará ...". E, de fato, foi, como a refatoração automática está disponível em muitos IDEs e para a maioria dos idiomas convencionais.

Esses IDEs podem renomear variáveis e métodos, dividir uma rotina longa em menores, propagando automaticamente as alterações necessárias, arrastar e soltar para ajudá -lo a mover o código e assim por diante.





Falaremos mais sobre os testes nesse nível no tópico 41, teste para código e testes em larga escala em testes cruéis e contínuos, mas o ponto de Fowler de manter bons testes de regressão é a chave para refatorar com segurança.

Se você precisar ir além da refatoração e acabar mudando de comportamento ou interfaces externas, ele pode ajudar a quebrar deliberadamente a construção: os clientes antigos desse código devem falhar na compilação. Dessa forma, você saberá o que precisa ser atualizado. Da próxima vez que você vir um pedaço de código que não é exatamente como deveria, conserte -o. Gerencie a dor: se dói agora, mas vai doer ainda mais mais tarde, você também pode acabar com isso. Lembre -se das lições do tópico 3, Entropy de software: não viva
com janelas quebradas.





Seções relacionadas incluem


Tópico 3, entropia de software

Tópico 9, seco - os males de duplicação

Tópico 12, balas de traçador

Tópico 27, não supere seus faróis

Tópico 44, nomeando coisas

Tópico 48, a essência da agilidade





Tópico 41

Teste para codificar




A primeira edição deste livro foi escrita em tempos mais primitivos, quando a maioria dos desenvolvedores não escreveu testes - por que se preocupar, eles pensaram, o mundo iria terminar no ano de 2000 de qualquer maneira.

Nesse livro, tivemos uma seção sobre como criar código fácil de testar. Era uma maneira furtiva de convencer os desenvolvedores a realmente escrever testes.

Estes são tempos mais esclarecidos. Se houver algum desenvolvedor ainda não escrevendo testes, eles pelo menos sabem que deveriam ser.

Mas ainda há um problema. Quando perguntamos aos desenvolvedores por que eles escrevem testes, eles nos olham como se tivéssemos acabado de perguntar se eles ainda codificaram usando cartões perfurados e diriam "para garantir que o código funcione", com um "You Dummy" não dito no final. E achamos que isso está errado.

Então, o que achamos importante nos testes? E como achamos que você deveria fazer isso?

Vamos começar com a declaração ousada:

Dica 66 O teste não é encontrar bugs



Acreditamos que os principais benefícios dos testes acontecem quando você pensa e escreve os testes, não quando você os executa.





Pensando em testes


É uma manhã de segunda -feira e você se instala para começar a trabalhar em algum novo código. Você precisa escrever algo que consulte o banco de dados para retornar uma lista de pessoas que assistem a mais de 10 vídeos por semana no site "Vídeos de lavar louça mais engraçados do mundo".

Você inicia seu editor e começa escrevendo a função que executa a consulta:

Def return_avid_viewers

# ... hmmm ...

Fim



Parar! Como você sabe que o que está prestes a fazer é uma coisa boa?

A resposta é que você não pode saber disso. Ninguém pode. Mas pensar em testes pode torná -lo mais provável. Veja como isso funciona.

Comece imaginando que você terminou de escrever a função e agora teve que testá -la. Como você faria isso? Bem, você deseja usar alguns dados de teste, o que provavelmente significa que você deseja trabalhar em um banco de dados que controla. Agora, algumas estruturas podem lidar com isso para você, executando testes em um banco de dados de teste, mas no nosso caso, isso significa que devemos passar na instância do banco de dados em nossa função, em vez de usar um global, pois isso nos permite alterá -lo durante o teste:

Def return_avid_users (db) do



Então temos que pensar em como preencheríamos esses dados de teste. O requisito pede uma "lista de pessoas que assistem a mais de 10 vídeos por semana". Então, analisamos o esquema de banco de dados para campos que podem ajudar. Encontramos dois campos prováveis em uma tabela de quem assistiu o quê: aberto_video e complete_video. Para escrever nossos dados de teste, precisamos saber qual campo usar. Mas não sabemos o que significa o requisito e nosso contato comercial está fora. Vamos trapacear e passar o nome do campo (que nos permitirá testar o que temos e potencialmente alterá -lo mais tarde):

Def return_avid_users (db, qualify_field_name)



Começamos pensando em nossos testes e, sem escrever uma linha de código, já fizemos duas descobertas e as usamos para alterar a API do nosso método.





Testes acionam a codificação


No exemplo anterior, pensar em testes nos fez reduzir o acoplamento em nosso código (passando em uma conexão de banco de dados em vez de usar um global) e aumentar a flexibilidade (fazendo o nome do campo, testamos um parâmetro). Pensar em escrever um teste para o nosso método nos fez olhar de fora, como se fôssemos um cliente do Código, e não seu autor.

Dica 67 Um teste é o primeiro usuário do seu código



Achamos que este é provavelmente o maior benefício oferecido pelos testes: o teste é um feedback vital que orienta sua codificação.

É difícil testar uma função ou método que é fortemente acoplado a outro código, porque você precisa configurar todo esse ambiente antes mesmo de executar seu método. Portanto, tornar suas coisas testáveis também reduzem seu acoplamento.

E antes que você possa testar algo, você precisa entender. Isso parece bobo, mas, na realidade, todos nós lançamos um código de código com base em um entendimento nebuloso do que tínhamos que fazer. Garantimos a nós mesmos que vamos resolver à medida que avançamos. Ah, e adicionaremos todo o código para suportar as condições de contorno posteriormente também. Ah, e o manuseio de erros. E o código acaba cinco vezes mais do que deveria, porque está cheio de lógica condicional e casos especiais. Mas brilha a luz de um teste sobre isso
código e coisas ficam mais claras. Se você pensar em testar as condições de contorno e como isso funcionará antes de começar a codificar, poderá encontrar os padrões na lógica que simplificarão a função. Se você pensar nas condições de erro que precisará testar, estruturará sua função de acordo.





Desenvolvimento orientado a testes


Há uma escola de programação que diz que, dados todos os benefícios de pensar em testes antecipadamente, por que não ir em frente e escrevê -los também? Eles praticam algo chamado desenvolvimento orientado a testes ou TDD. Você também verá esse desenvolvimento chamado de teste. [58]

O ciclo básico do TDD é:

Decida sobre uma pequena peça de funcionalidade que você deseja adicionar.



Escreva um teste que passe assim que essa funcionalidade for implementada.



Execute todos os testes. Verifique se o único fracasso é o que você acabou de escrever.



Escreva a menor quantidade de código necessária para que o teste passe e verifique se os testes agora são executados de maneira limpa.



Refator seu código: veja se existe uma maneira de melhorar o que você acabou de escrever (o teste ou a função). Verifique se os testes ainda passam quando terminar.





A idéia é que esse ciclo seja muito curto: uma questão de minutos, para que você esteja constantemente escrevendo testes e depois que eles funcionem.

Vemos um grande benefício no TDD para as pessoas que estão começando com os testes. Se você seguir o fluxo de trabalho do TDD, garantirá que sempre tenha testes para o seu código. E isso significa que você sempre estará pensando em seus testes.

No entanto, também vimos pessoas se tornarem escravos do TDD. Isso se manifesta de várias maneiras:

Eles gastam quantidades excessivas de tempo, garantindo que sempre tenham 100% de cobertura de teste.



Eles têm muitos testes redundantes. Por exemplo, antes de escrever uma aula pela primeira vez, muitos adeptos do TDD escreverão primeiro um teste de falha que simplesmente faz referência ao nome da classe. Falha, então eles escrevem uma definição de classe vazia e passa. Mas agora você tem um teste que não faz absolutamente nada; O próximo teste que você escreve também fará referência à classe e, portanto, torna o primeiro desnecessário. Há mais coisas para mudar se o nome da classe mudar mais tarde. E este é apenas um exemplo trivial.



Seus projetos tendem a começar no fundo e subir. (Veja de baixo para cima vs. de cima para baixo vs. da maneira que você deve fazê-lo.)





De baixo para cima vs. de cima para baixo vs. da maneira como você deve fazer isso

Quando a computação era jovem e despreocupada, havia duas escolas de design: de cima para baixo e de baixo para cima. As pessoas de cima para baixo disseram que você deve começar com o problema geral que está tentando resolver e dividi-lo em um pequeno número de peças. Em seguida, quebre cada um deles em pedaços menores e assim por diante, até acabar com os pedaços pequenos o suficiente para expressar em código.

As pessoas de baixo para cima criam código como você construiria uma casa. Eles começam na parte inferior, produzindo uma camada de código que lhes dá algumas abstrações mais próximas do problema que estão tentando resolver. Em seguida, eles adicionam outra camada, com abstrações de nível superior. Eles continuam até a camada final ser uma abstração que resolve o problema. "Faça assim ..."

Nenhuma da escola realmente funciona, porque ambos ignoram um dos aspectos mais importantes do desenvolvimento de software: não sabemos o que estamos fazendo quando começamos. As pessoas de cima para baixo assumem que podem expressar todo o requisito antecipadamente: não podem. As pessoas de baixo para cima assumem que podem construir uma lista de abstrações que os levarão a uma única solução de nível superior, mas como eles podem decidir sobre a funcionalidade das camadas quando não sabem para onde estão indo?

Dica 68 Construa ponta a ponta, não de cima para baixo ou de baixo para cima



Acreditamos fortemente que a única maneira de criar software é incrementalmente. Crie pequenos pedaços de funcionalidade de ponta a ponta, aprendendo sobre o problema à medida que avança. Aplique esse aprendizado à medida que continua a desenvolver o código, envolver o cliente em cada etapa e peça que eles orçem o processo.





Por todos os meios, pratique TDD. Mas, se o fizer, não se esqueça de parar de vez em quando e olhar para o quadro geral. É fácil ser seduzido pela mensagem verde "testes passados", escrevendo muito código que na verdade não o aproxima de uma solução.





TDD: Você precisa saber para onde está indo


A velha piada pergunta "Como você come um elefante?" A linha de soco: "Uma mordida de cada vez". E essa idéia é frequentemente apontada como um benefício do TDD. Quando você não conseguir compreender todo o problema, dê pequenos passos, um teste de cada vez. No entanto, essa abordagem pode enganá -lo, incentivando -o a se concentrar e polir infinitamente o fácil
Problemas enquanto ignoram a verdadeira razão pela qual você está codificando. Um exemplo interessante disso aconteceu em 2006, quando Ron Jeffries, uma figura de destaque no movimento de agilidade, iniciou uma série de postagens de blog que documentavam sua codificação de um solucionador de Sudoko. [59] Após cinco postagens, ele refinou a representação do conselho subjacente, refatorando várias vezes até ficar feliz com o modelo de objeto. Mas então ele abandonou o projeto. É interessante ler as postagens do blog em ordem e observar como uma pessoa inteligente pode ser desviada pelas minúcias, reforçada pelo brilho dos testes de passagem.

Como contraste, Peter Norvig descreve uma abordagem alternativa [60] que parece muito diferente de caráter: em vez de ser conduzido por testes, ele começa com uma compreensão básica de como esses tipos de problemas são tradicionalmente resolvidos (usando a propagação de restrições) e depois se concentra em refinar seu algoritmo. Ele aborda a representação do conselho em uma dúzia de linhas de código que fluem diretamente de sua discussão sobre notação.

Os testes podem definitivamente ajudar a impulsionar o desenvolvimento. Mas, como em cada unidade, a menos que você tenha um destino em mente, você pode acabar em círculos.





De volta ao código


O desenvolvimento baseado em componentes tem sido um objetivo elevado do desenvolvimento de software. [61] A idéia é que os componentes genéricos de software devem estar disponíveis e combinados com a mesma facilidade que os circuitos integrados comuns (ICS) sejam combinados. Mas isso funciona apenas se os componentes que você estiver usando forem confiáveis e se você tiver tensões comuns, padrões de interconexão, tempo e assim por diante.

Os chips foram projetados para serem testados - não apenas na fábrica, não apenas quando são instalados, mas também em campo quando são implantados. Chips e sistemas mais complexos podem ter um recurso completo de auto-teste (BIST) que executa alguns diagnósticos no nível da base internamente ou um mecanismo de acesso a testes (TAM) que fornece um chicote de teste que permite ao ambiente externo fornecer estímulos e coletar respostas do chip.

Podemos fazer a mesma coisa no software. Como nossos colegas de hardware, precisamos criar testabilidade no software desde o início e testar cada peça completamente antes de tentar conectá -los.





Teste de unidade


Os testes no nível do chip para hardware são aproximadamente equivalentes aos testes de unidade em software-testando em cada módulo, isoladamente, para verificar seu comportamento. Podemos ter uma sensação melhor de como um módulo reagirá no mundo grande, uma vez que o testarmos por meio de condições controladas (até artificiais).

Um teste de unidade de software é um código que exerce um módulo. Normalmente, o teste de unidade estabelecerá algum tipo de ambiente artificial e invoca rotinas no módulo que está sendo testado. Em seguida, ele verifica os resultados retornados, contra valores conhecidos ou contra os resultados das execuções anteriores do mesmo teste (teste de regressão).

Mais tarde, quando montamos nossos "ICs de software" em um sistema completo, teremos confiança de que as peças individuais funcionam conforme o esperado e, em seguida, podemos usar as mesmas instalações de teste de unidade para testar o sistema como um todo. Falamos sobre essa verificação em larga escala do sistema em testes cruéis e contínuos.

Antes de chegarmos tão longe, no entanto, precisamos decidir o que testar no nível da unidade. Historicamente, os programadores lançaram alguns bits aleatórios de dados no código, analisaram as declarações de impressão e chamaram -as de testes. Podemos fazer muito melhor.





Testes contra contrato


Gostamos de pensar nos testes de unidade como teste contra contrato (ver tópico 23, projeto por contrato). Queremos escrever casos de teste que garantem que uma determinada unidade honre seu contrato. Isso nos dirá duas coisas: se o código atende ao contrato e se o contrato significa o que achamos que isso significa. Queremos testar que o módulo entrega a funcionalidade que promete, em uma ampla gama de casos de teste e condições de contorno.

O que isso significa na prática? Vamos começar com um exemplo numérico e simples: uma rotina de raiz quadrada. Seu contrato documentado é simples:

Pré-Condições:

Argumento> = 0;

​

Pós-condicionas:

((Resultado * resultado) - argumento) .abs <= epsilon * argumento;



Isso nos diz o que testar:

Passe em um argumento negativo e garanta que ele seja rejeitado.



Passe em um argumento de zero para garantir que seja aceito (este é o valor limite).



Passe os valores entre zero e o argumento máximo expressável e verifique se a diferença entre o quadrado do resultado e o argumento original é menor do que uma pequena fração de
O argumento (epsilon).





Armado com este contrato e, assumindo que nossa rotina faz sua própria verificação pré e pós-condição, podemos escrever um script de teste básico para exercer a função raiz quadrada.

Em seguida, podemos chamar essa rotina para testar nossa função raiz quadrada:

Assertwithinepsilon (my_sqrt (0), 0)

Assertwithinepsilon (my_sqrt (2.0), 1.4142135624)

Assertwithinepsilon (my_sqrt (64.0), 8.0)

Assertwithinepsilon (my_sqrt (1.0e7), 3162.2776602)

AssertraiseSexception fn => my_sqrt (-4.0) final



Este é um teste bastante simples; No mundo real, é provável que qualquer módulo não trivial dependa de vários outros módulos, então como fazemos testar a combinação?

Suponha que tenhamos um módulo A que use um feed de dados e uma regressão linear. Para testarmos:

Contrato da DataFeed, na íntegra

Contrato da LinearRegression, na íntegra

O contrato de A, que depende dos outros contratos, mas não os expõe diretamente



Esse estilo de teste exige que você teste os subcomponentes de um módulo primeiro. Uma vez verificada os subcomponentes, o próprio módulo poderá ser testado.

Se os testes de feed de dados e regressão linear passados, mas o teste de A falhou, podemos ter certeza de que o problema está em A, ou no uso de A de um desses subcomponentes. Essa técnica é uma ótima maneira de reduzir o esforço de depuração: podemos nos concentrar rapidamente na provável fonte do problema no módulo A, e não perder tempo reexaminando seus subcomponentes.

Por que vamos a todo esse problema? Acima de tudo, queremos evitar criar uma "bomba -relógio" - algo que fica despercebido e explode em um momento estranho mais tarde no projeto. Ao enfatizar os testes contra o contrato, podemos tentar evitar o maior número possível de desastres a jusante.

Dica 69 Design para testar





Teste ad hoc


Não deve ser confundido com "Odd Hack", os testes ad-hoc são quando corremos para o nosso código manualmente. Isso pode ser tão simples quanto um console.log () ou um pedaço de código inserido interativamente em um depurador, IDE ambiente ou repl.

No final da sessão de depuração, você precisa formalizar este teste ad hoc. Se o código quebrou uma vez, é provável que seja quebrado novamente. Não jogue fora o teste que você criou; Adicione -o ao arsenal de teste de unidade existente.





Construa uma janela de teste


Até os melhores conjuntos de testes provavelmente encontrarão todos os bugs; Há algo sobre as condições úmidas e quentes de um ambiente de produção que parece tirá -las da madeira.

Isso significa que você geralmente precisará testar um software assim que ele for implantado-com dados do mundo real que fluem por suas veias. Ao contrário de uma placa de circuito ou chip, não temos pinos de teste no software, mas podemos fornecer várias visualizações sobre o estado interno de um módulo, sem usar o depurador (que pode ser inconveniente ou impossível em um aplicativo de produção).

Arquivos de log contendo mensagens de rastreamento são um desses mecanismos. As mensagens de log devem estar em um formato regular e consistente; Você pode analisá -los automaticamente para deduzir o tempo de processamento ou os caminhos lógicos que o programa seguiu. Os diagnósticos formatados mal ou inconsistentemente são muito "vomitam" - são difíceis de ler e impraticáveis para analisar.

Outro mecanismo para entrar no código de execução é a sequência da "tecla quente" ou URL mágico. Quando essa combinação específica de teclas é pressionada ou o URL é acessado, uma janela de controle de diagnóstico aparece com mensagens de status e assim por diante. Isso não é algo que você normalmente revelaria aos usuários finais, mas pode ser muito útil para o suporte técnico.

De maneira mais geral, você pode usar uma chave de recurso para permitir diagnósticos extras para um usuário ou classe de usuários específicos.


Uma confissão

Eu (Dave) sou conhecido por dizer às pessoas que não escrevo mais testes. Em parte, faço isso para abalar a fé daqueles que transformaram os testes em uma religião. E em parte eu digo isso porque é (um pouco) verdadeiro.

Estou codificando há 45 anos e escrevo testes automatizados há mais de 30 deles. Pensar em testes é incorporado à maneira como aborto a codificação. Parecia confortável. E minha personalidade insiste que, quando algo começa a se sentir confortável, devo passar para outra coisa.

Nesse caso, decidi parar de escrever testes por alguns meses e ver o que ele fez no meu código. Para minha surpresa, a resposta foi "não muito". Então, passei algum tempo trabalhando por quê.

Acredito que a resposta é que (para mim) a maior parte do benefício dos testes vem do pensamento sobre os testes e seu impacto no código. E, depois de fazer isso por tanto tempo, eu poderia fazer esse pensamento sem realmente
Testes de escrita. Meu código ainda estava testável; Simplesmente não foi testado.

Mas isso ignora o fato de que os testes também são uma maneira de se comunicar com outros desenvolvedores, então agora escrevo testes sobre código compartilhado com outras pessoas ou que se baseia nas peculiaridades das dependências externas.

Andy diz que eu não deveria incluir esta barra lateral. Ele se preocupa, tentará que os desenvolvedores inexperientes não testem. Aqui está o meu compromisso:

Você deve escrever testes? Sim. Mas depois de fazer isso há 30 anos, fique à vontade para experimentar um pouco para ver onde está o benefício para você.





Uma cultura de teste


Todo o software que você escreve será testado - se não por você e sua equipe, pelos usuários eventuais - para que você possa planejar testá -lo minuciosamente. Um pouco de premeditação pode ajudar bastante a minimizar os custos de manutenção e as chamadas de ajuda.

Você realmente só tem algumas opções:

Teste primeiro

Teste durante

Teste nunca



O teste primeiro, incluindo o design orientado a testes, é provavelmente a sua melhor escolha na maioria das circunstâncias, pois garante que os testes aconteçam. Mas, às vezes, isso não é tão conveniente ou útil; portanto, o teste durante a codificação pode ser um bom fallback, onde você escreve algum código, mexe com ele, escreva os testes para ele e depois passa para o próximo bit. A pior escolha é frequentemente chamada de "teste mais tarde", mas quem você está brincando? "Teste mais tarde" significa "teste nunca".

Uma cultura de teste significa que todos os testes passam o tempo todo. Ignore uma variação de testes que "sempre falham" facilitam a ignição de todos os testes, e a espiral viciosa começa (ver tópico 3, entropia de software).

Trate o código de teste com o mesmo cuidado que qualquer código de produção. Mantenha -o dissociado, limpo e robusto. Não confie em coisas não confiáveis (consulte o tópico 38, programação por coincidência) como a posição absoluta dos widgets em um sistema de GUI ou o registro de data e hora exatos em um log de servidor ou na redação exata das mensagens de erro. O teste para esse tipo de coisa resultará em testes frágeis.

Dica 70 Teste seu software ou seus usuários irão



Não se engane, o teste faz parte da programação. Não é algo que resta a outros departamentos ou funcionários.

Teste, design, codificação - está tudo programando.





Seções relacionadas incluem


Tópico 27, não supere seus faróis

Tópico 51, kit iniciante pragmático





Tópico 42

Teste baseado em propriedades




До ей, но провйй (confie, mas verifique)



Provérbio russo



Recomendamos escrever testes de unidade para suas funções. Você faz isso pensando em coisas típicas que podem ser um problema, com base no seu conhecimento do que você está testando.

No entanto, há um pequeno, mas potencialmente significativo, à espreita nesse parágrafo. Se você escrever o código original e escrever os testes, é possível que uma suposição incorreta possa ser expressa em ambos? O código passa nos testes, porque faz o que deve basear -se em seu entendimento.

Uma maneira de contornar isso é fazer com que pessoas diferentes escrevessem testes e o código em teste, mas não gostamos disso: como dissemos no tópico 41, teste para codificar, um dos maiores benefícios de pensar sobre os testes é a maneira como informa o código que você escreve. Você perde isso quando o trabalho de teste é dividido da codificação.

Em vez disso, favorecemos uma alternativa, onde o computador, que não compartilha seus preconceitos, faz alguns testes para você.





Contratos, invariantes e propriedades


No tópico 23, design por contrato, conversamos sobre a idéia de que o código tem contratos que ele atende: você atende às condições ao alimentar a entrada e garantirá certas garantias sobre as saídas que produz.

Existem também invariantes de código, coisas que permanecem verdadeiras em algum estado de estado quando passou por uma função. Por exemplo, se você classificar uma lista, o resultado terá o mesmo número de elementos que o original - o comprimento será invariável.

Depois de elaborarmos nossos contratos e invariantes (que vamos agrupar e chamar propriedades), podemos usá -los para automatizar nossos testes. O que acabamos fazendo é chamado de teste baseado em propriedades.

Dica 71 Use testes baseados em propriedades para validar suas suposições



Como exemplo artificial, podemos criar alguns testes para a nossa lista classificada. Já estabelecemos uma propriedade: a lista classificada é do mesmo tamanho que o original. Também podemos afirmar que nenhum elemento no resultado pode ser maior que o que o segue.

Agora podemos expressar isso no código. A maioria dos idiomas possui algum tipo de estrutura de teste baseada em propriedades. Este exemplo está em Python e usa a ferramenta de hipótese e o pytest, mas os princípios são bastante universais.

Aqui está a fonte completa
dos testes:

propTest/sort.py

Da importação de hipóteses dada

Importação de hipótese.

​

@Given (alguns.lists (alguns.integers ()))

Def test_list_size_is_invariant_across_sorting (a_list):

Original_length = len (a_list)

A_list.sort ()

Assert len (a_list) == original_length

​

@Given (alguns.lists (some.Text ()))

DEF TEST_SORTED_RESULT_IS_ORDERED (A_LIST):

A_list.sort ()

Para i no range (len (a_list) - 1):

Assert a_list [i] <= a_list [i + 1]



Aqui está o que acontece quando o executamos:

$ Pytest Sort.py

======================== Sessão de teste começa ==========================

...

Plugins: Hipótese-4.14.0

​

Sort.py .. [100%]

​

====================== 2 Passado em 0,95 segundos ======================



Não há muito drama lá. Mas, nos bastidores, a hipótese executou ambos os nossos testes cem vezes, passando em uma lista diferente a cada vez. As listas terão comprimentos variados e terão conteúdos diferentes. É como se tivéssemos preparado 200 testes individuais com 200 listas aleatórias.





Geração de dados de teste


Como a maioria das bibliotecas de testes baseadas em propriedades, a hipótese oferece uma minilanguage para descrever os dados que deve gerar. O idioma é baseado em chamadas para funções no módulo Hipótese.

Se escrevemos:

@Given (alguns.integers ())



Nossa função de teste seria executada várias vezes. Cada vez, seria passado um número inteiro diferente. Se, em vez disso, escrevemos o seguinte:

@Given (alguns.integers (min_value = 5, max_value = 10) .map (lambda x: x * 2))



Em seguida, obtivemos os números pares entre 10 e 20.

Você também pode compor tipos, para que

@Given (alguns.lists (alguns.integers (min_value = 1), max_size = 100))



serão listas de números naturais que têm no máximo 100 elementos de comprimento.

Este não deve ser um tutorial sobre nenhuma estrutura específica, por isso ignoraremos um monte de detalhes legais e, em vez disso, examinaremos um exemplo do mundo real.





Encontrando más suposições


Estamos escrevendo um sistema simples de processamento de pedidos e controle de estoque (porque sempre há espaço para mais um). Ele modela os níveis de estoque com um objeto de armazém. Podemos consultar um armazém para ver se algo está em estoque, remover coisas do estoque e obter os níveis atuais de estoque.

Aqui está o código:

propTest/stock.py

Armazém de classe:

Def __init __ (self, estoque):

Self.stock = Stock

​

Def in_stock (self, item_name):

Return (item_name em self.stock) e (self.stock [item_name]> 0)

​

Def Take_from_stock (self, item_name, quantidade):

Se quantidade <= self.stock [item_name]:

Self.stock [item_name] -= Quantidade

Outra pessoa:

Levante a exceção ("OversOd {}" .Format (item_name))

​

Def Stock_Count (self, item_name):

Return self.stock [item_name]



Escrevemos um teste básico de unidade, que passa:

propTest/stock.py

Def test_warehouse ():

Wh = armazém ({"sapatos": 10, "chapéus": 2, "guarda -chuvas": 0})

Afirme wh.in_stock ("sapatos")

Afirme wh.in_stock ("chapéus")

Afirme não wh.in_stock ("guarda -chuvas")

​

Wh.take_from_stock ("sapatos", 2)

Afirme wh.in_stock ("sapatos")

​

Wh.take_from_stock ("chapéus", 2)

Afirme não wh.in_stock ("chapéus")



Em seguida, escrevemos uma função que processa uma solicitação para solicitar itens do armazém. Ele retorna uma tupla em que o primeiro elemento é "ok" ou "não disponível", seguido pelo item e solicitou quantidade. Também escrevemos alguns testes e eles passam:

propTest/stock.py

Def Order (armazém, item, quantidade):

Se warehouse.in_stock (item):

Warehouse.take_from_stock (item, quantidade)

Retornar ("ok", item, quantidade)

Outra pessoa:

Retornar ("não disponível", item, quantidade)



propTest/stock.py

Def test_order_in_stock ():

Wh = armazém ({"sapatos": 10, "chapéus": 2, "guarda -chuvas": 0})

Status, item, quantidade = ordem (wh, "chapéus", 1)

Afirmar status == "ok"

ASSERT ITEM == "HATS"

Afirmar quantidade == 1

Assert wh.stock_count ("chapéus") == 1

​

Def test_order_not_in_stock ():

Wh = armazém ({"sapatos": 10, "chapéus": 2, "guarda -chuvas": 0})

Status, item, quantidade = ordem (wh, "guarda -chuvas", 1)

Afirmar status == "não disponível"

ASSERT ITEM == "guarda -chuvas"

Afirmar quantidade == 1

ASSERT WH.STOCK_COUNT ("Umbrellas") == 0

​

Def test_order_unknown_item ():

Wh = armazém ({"sapatos": 10, "chapéus": 2, "guarda -chuvas": 0})

Status, item, quantidade = ordem (wh, "bagel", 1)

Afirmar status == "não
disponível "

ASSERT ITEM == "bagel"

Afirmar quantidade == 1



Na superfície, tudo parece bem. Mas antes de enviarmos o código, vamos adicionar alguns testes de propriedade.

Uma coisa que sabemos é que as ações não podem aparecer e desaparecer em nossa transação. Isso significa que, se pegarmos alguns itens do armazém, o número que levamos mais o número atualmente no armazém deve ser o mesmo que o número originalmente no armazém. No teste a seguir, executamos nosso teste com o parâmetro de item escolhido aleatoriamente de "hat" ou "sapato" e a quantidade escolhida de 1 a 4:

propTest/stock.py

@Given (item = some.sampled_from (["sapatos", "chapéus"]),

Quantidade = alguns.integers (min_value = 1, max_value = 4))

​

Def test_stock_level_plus_quantity_equals_original_stock_level (item, quantidade):

Wh = armazém ({"sapatos": 10, "chapéus": 2, "guarda -chuvas": 0})

Inicial_stock_level = wh.stock_count (item)

(Status, Item, Quantidade) = Ordem (WH, Item, Quantidade)

Se status == "ok":

Assert wh.stock_count (item) + quantidade == Initial_stock_level



Vamos executá -lo:

$ Pytest stock.py

. . .

Stock.py:72:

_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

Stock.py:76: em test_stock_level_plus_quantity_equals_original_stock_level

(Status, Item, Quantidade) = Ordem (WH, Item, Quantidade)

Stock.py:40: em ordem

Warehouse.take_from_stock (item, quantidade)

_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

​

Self = <Stock.WareHouse Object em 0x10cf97cf8>, item_name = 'Hats'

Quantidade = 3

​

Def Take_from_stock (self, item_name, quantidade):

Se quantidade <= self.stock [item_name]:

Self.stock [item_name] -= Quantidade

Outra pessoa:

> Levantamento de exceção ("OversOd {}" .Format (item_name))

E exceção: chapéus de vedimento

​

Stock.py:16: Exceção

------------------------------ Hipótese ------------------------------

Exemplo de falsificação:

Test_stock_level_plus_quantity_equals_original_stock_level (

Item = 'Hats', Quantidade = 3)



Ele explodiu no armazém.take_from_stock: tentamos remover três chapéus do armazém, mas ele tem apenas dois em estoque.

Nosso teste de propriedades encontrou uma suposição defeituosa: nossa função in_stock verifica apenas se há pelo menos um dos itens especificados em estoque. Em vez disso, precisamos ter certeza de que temos o suficiente para preencher o pedido:

propTest/stock1.py

Def in_stock (self, item_name, quantidade):

»Return (item_name em self.stock) e (self.stock [item_name]> = quantidade)



E também mudamos a função de ordem:

propTest/stock1.py

Def Order (armazém, item, quantidade):

»Se warehouse.in_stock (item, quantidade):

Warehouse.take_from_stock (item, quantidade)

Retornar ("ok", item, quantidade)

Outra pessoa:

Retornar ("não disponível", item, quantidade)



E agora nosso teste de propriedade passa.





Testes baseados em propriedades frequentemente o surpreendem


No exemplo anterior, usamos um teste baseado em propriedades para verificar se os níveis de estoque foram ajustados corretamente. O teste encontrou um bug, mas não tinha a ver com o ajuste do nível do estoque. Em vez disso, encontrou um bug em nossa função in_stock.

Esse é o poder e a frustração dos testes baseados em propriedades. É poderoso porque você configura algumas regras para gerar entradas, configurar algumas afirmações para validar a saída e, em seguida, deixá -lo rasgar. Você nunca sabe o que vai acontecer. O teste pode passar. Uma afirmação pode falhar. Ou o código pode falhar totalmente porque não conseguiu lidar com as entradas que recebeu.

A frustração é que pode ser complicado definir o que falhou.

Nossa sugestão é que, quando um teste baseado em propriedades falhar, descubra quais parâmetros estava passando para a função de teste e use esses valores para criar um teste de unidade regular separado. Esse teste de unidade faz duas coisas para você. Primeiro, permite que você se concentre no problema sem que todas as chamadas adicionais sejam feitas em seu código pela estrutura de teste baseada em propriedades. Segundo, esse teste de unidade atua como um teste de regressão. Como os testes baseados em propriedades geram valores aleatórios que são passados para o seu teste, não há garantia de que os mesmos valores serão usados na próxima vez que você executar testes. Ter um teste de unidade que força esses valores a serem usados garante que esse bug não escorregue.





Testes baseados em propriedades também ajudam seu design


Quando conversamos sobre testes de unidade, dissemos que um dos principais benefícios foi a maneira como fez você pensar no seu código: um teste de unidade é o primeiro cliente da sua API.

O mesmo se aplica aos testes baseados em propriedades, mas em um ligeiramente
maneira diferente. Eles fazem você pensar no seu código em termos de invariantes e contratos; Você pensa no que não deve mudar e o que deve ser verdadeiro. Esse insight extra tem um efeito mágico no seu código, removendo casos de borda e destacando funções que deixam dados em um estado inconsistente.

Acreditamos que os testes baseados em propriedades são complementares aos testes de unidade: eles abordam diferentes preocupações e cada um traz seus próprios benefícios. Se você não estiver usando -os atualmente, experimente.





Seções relacionadas incluem


Tópico 23, projeto por contrato

Tópico 25, programação assertiva

Tópico 45, o poço de requisitos





Exercícios


Exercício 31 (resposta possível)

Olhe para o exemplo do armazém. Existem outras propriedades que você pode testar?

Exercício 32 (resposta possível)

Sua empresa envia máquinas. Cada máquina vem em uma caixa e cada caixa é retangular. As caixas variam em tamanho. Seu trabalho é escrever algum código para embalar o maior número possível de caixas em uma única camada que se encaixa no caminhão de entrega. A saída do seu código é uma lista de todas as caixas. Para cada caixa, a lista fornece a localização no caminhão, juntamente com a largura e a altura. Quais propriedades da saída poderiam ser testadas?





Desafios


Pense no código em que você está trabalhando no momento. Quais são as propriedades: os contratos e invariantes? Você pode usar a estrutura de teste baseada em propriedades para verificá-las automaticamente?





Tópico 43

Fique seguro lá fora




	Boas cercas são bons vizinhos.



Robert Frost, parede de conserto



Na discussão da primeira edição sobre o acoplamento de código, fizemos uma declaração ousada e ingênua: "Não precisamos ser tão paranóicos quanto espiões ou dissidentes". Estávamos errados. Na verdade, você precisa ser tão paranóico, todos os dias.

Enquanto escrevemos isso, o Daily News está repleto de histórias de violações de dados devastadoras, sistemas sequestrados e cyberfraud. Centenas de milhões de registros roubados ao mesmo tempo, bilhões e bilhões de dólares em perdas e remediação - e esses números estão crescendo rapidamente a cada ano. Na grande maioria dos casos, não é porque os atacantes eram terrivelmente inteligentes, ou até vagamente competentes.

É porque os desenvolvedores foram descuidados.





Os outros 90%


Ao codificar, você pode passar por vários ciclos de "Funciona!" E "Por que isso não está funcionando?" Com o ocasional "não há como ter acontecido ..." [62] Depois de várias colinas e solavancos nessa subida em cima, é fácil dizer a si mesmo: "Ufa, tudo funciona!" e proclamar o código feito. Claro, ainda não foi feito. Você está em 90%, mas agora tem os outros 90% a serem considerados.

A próxima coisa que você precisa fazer é analisar o código de maneiras pelas quais ele pode dar errado e adicioná -los ao seu conjunto de testes. Você considerará coisas como passar parâmetros ruins, vazamentos ou recursos indisponíveis; esse tipo de coisa.

Nos bons velhos tempos, essa avaliação de erros internos pode ter sido suficiente. Hoje, porém, é apenas o começo, porque, além de erros de causas internas, você precisa considerar como um ator externo pode estragar deliberadamente o sistema. Mas talvez você proteja: "Oh, ninguém se importará com esse código, não é importante, ninguém sabe sobre esse servidor ..." É um grande mundo por aí, e a maior parte está conectada. Seja um garoto entediado do outro lado do planeta, terrorismo patrocinado pelo Estado, gangues criminosas, espionagem corporativa ou mesmo um ex vingativo, eles estão lá fora e apontando para você. O tempo de sobrevivência de um sistema desatualizado e desatualizado na rede aberta é medida em minutos - ou ainda menos.

A segurança através da obscuridade simplesmente não funciona.





Princípios básicos de segurança


Os programadores pragmáticos têm uma quantidade saudável de paranóia. Sabemos que temos falhas e limitações, e que os atacantes externos aproveitarão em qualquer abertura que saímos para comprometer nossos sistemas. Seus ambientes específicos de desenvolvimento e implantação terão suas próprias necessidades centradas em segurança, mas há alguns princípios básicos que você sempre deve ter em mente:

Minimizar a área de superfície de ataque

Princípio de menor privilégio

Padrões seguros

Criptografar dados sensíveis

Manter atualizações de segurança



Vamos dar uma olhada em cada um deles.





Minimizar a área de superfície de ataque


A área de superfície de ataque de um sistema é a soma de todos os pontos de acesso em que um invasor pode inserir dados, extrair dados ou invocar a execução de um serviço. Aqui estão alguns exemplos:

A complexidade do código leva a vetores de ataque

A complexidade do código aumenta a superfície de ataque, com mais oportunidades para efeitos colaterais imprevistos. Pense em complexo
Código como tornar a área da superfície mais porosa e aberta à infecção. Mais uma vez, o código simples e menor é melhor. Menos código significa menos bugs, menos oportunidades para um buraco de segurança incapacitante. Código mais simples, mais apertado e menos complexo é mais fácil de raciocinar, mais fácil identificar possíveis fraquezas.





Dados de entrada é um vetor de ataque

Nunca confie nos dados de uma entidade externa, sempre o higienize antes de transmiti -los para um banco de dados, visualizar a renderização ou outro processamento. [63] Alguns idiomas podem ajudar com isso. No Ruby, por exemplo, variáveis que mantêm a entrada externa são contaminadas, o que limita quais operações podem ser executadas nelas. Por exemplo, esse código aparentemente usa o utilitário da WC para relatar o número de caracteres em um arquivo cujo nome é fornecido em tempo de execução:



segurança/taint.rb

Coloca "Digite um nome de arquivo para contar:"

Nome = Gets

System ("WC -C#{Name}")





Um usuário nefasto pode causar danos assim:



Digite um nome de arquivo para contar:

Test.dat; rm -rf /





No entanto, definir o nível de segurança para 1 manchará dados externos, o que significa que não podem ser usados em contextos perigosos:



segurança/taint.rb

»$ Seguro = 1

​

Coloca "Digite um nome de arquivo para contar:"

Nome = Gets

System ("WC -C#{Name}")





~~~ Sessão $ ruby taint.rb Digite um nome de arquivo para contar: test.dat; rm -rf /





Código/Segurança/Taint.RB: 5: No System ': Operação insegura - Sistema (SecurityError) de Code/Safety/Taint.rb: 5: em Main' ~~~

Serviços não autenticados são um vetor de ataque

Por sua própria natureza, qualquer usuário em qualquer lugar do mundo pode chamar serviços não autenticados, portanto, exceto qualquer outro manuseio ou limitação, você criou imediatamente uma oportunidade para um ataque de negação de serviço no mínimo. Recentemente, algumas violações de dados altamente públicos foram causados por desenvolvedores acidentalmente colocando dados em lojas de dados não autenticadas e legíveis publicamente na nuvem.



Serviços autenticados são um vetor de ataque

Mantenha o número de usuários autorizados no mínimo absoluto. Abate usuários e serviços não utilizados, antigos ou desatualizados. Verificou-se que muitos dispositivos habilitados para rede contêm senhas padrão simples ou contas administrativas desprotegidas e não utilizadas. Se uma conta com credenciais de implantação estiver comprometida, todo o seu produto será comprometido.



Os dados de saída são um vetor de ataque

Há uma história (possivelmente apócrifa) sobre um sistema que relatou obedientemente que a senha da mensagem de erro é usada por outro usuário. Não entregue informações. Verifique se os dados que você relatar são apropriados para a autorização desse usuário. Truncar ou ofuscar informações potencialmente arriscadas, como Seguro Social ou outros números de identificação do governo.





Informações de depuração é um vetor de ataque

Não há nada tão emocionante quanto ver um rastreamento completo de pilha com dados em sua máquina ATM local, um quiosque do aeroporto ou uma página da web travando. As informações projetadas para facilitar a depuração podem facilitar a quebra. Verifique se qualquer “janela de teste” (discutida aqui) e o relatório de exceção de tempo de execução está protegido dos olhos espionando. [64]





DICA 72 Mantenha simples e minimize as superfícies de ataque





Princípio de menor privilégio


Outro princípio -chave é usar a menor quantidade de privilégio pelo menor tempo que você pode se safar. Em outras palavras, não obtenha automaticamente o maior nível de permissão, como raiz ou administrador. Se esse nível alto for necessário, aceite, faça a quantidade mínima de trabalho e abandone sua permissão rapidamente para reduzir o risco. Este princípio remonta ao início dos anos 1970:

Todo programa e todo usuário privilegiado do sistema devem operar usando a menor quantidade de privilégio necessário para concluir o trabalho. - Jerome Saltzer, Comunicações do ACM, 1974.



Pegue o programa de login em sistemas derivados da UNIX. Inicialmente, ele é executado com privilégios de raiz. Assim que termina a autenticação do usuário correto, ele diminui o privilégio de alto nível para o do usuário.

Isso não se aplica apenas aos níveis de privilégio operacional do sistema. O seu aplicativo implementa diferentes níveis de acesso? É uma ferramenta brusca, como "Administrador" vs. "Usuário?" Nesse caso, considere algo mais finamente granulado, onde seus recursos confidenciais são particionados em diferentes categorias, e usuários individuais têm permissões apenas para algumas dessas categorias.

Essa técnica segue o mesmo tipo de idéia que minimizar a área de superfície - reduzindo o escopo dos vetores de ataque, tanto pelo tempo quanto pelo nível de privilégio. Nesse caso, menos é realmente mais.





Padrões seguros


As configurações padrão em seu
O aplicativo, ou para seus usuários no seu site, deve ser os valores mais seguros. Esses podem não ser os valores mais amigáveis ou convenientes, mas é melhor permitir que cada indivíduo decida por si mesmos as trocas entre segurança e conveniência.

Por exemplo, o padrão para entrada de senha pode ser ocultar a senha conforme inserido, substituindo cada caractere por um asterisco. Se você estiver inserindo uma senha em um local público lotado ou projetado antes de um grande público, isso é um padrão sensato. Mas alguns usuários podem querer ver a senha explicitada, talvez por acessibilidade. Se há pouco risco que alguém está olhando por cima do ombro, essa é uma escolha razoável para eles.





Criptografar dados sensíveis


Não deixe informações pessoalmente identificáveis, dados financeiros, senhas ou outras credenciais em texto simples, seja em um banco de dados ou em algum outro arquivo externo. Se os dados forem expostos, a criptografia oferece um nível adicional de segurança.

No tópico 19, controle de versão, recomendamos fortemente colocar tudo o que é necessário para o projeto em controle de versão. Bem, quase tudo. Aqui está uma grande exceção a essa regra:

Não verifique segredos, chaves da API, teclas SSH, senhas de criptografia ou outras credenciais juntamente com seu código -fonte no controle da versão.

As chaves e os segredos precisam ser gerenciados separadamente, geralmente através de arquivos de configuração ou variáveis de ambiente como parte da compilação e implantação.


Senha antipatherns

	 	 	 	 		Um dos problemas fundamentais da segurança é que, muitas vezes, a boa segurança é contrária ao senso comum ou prática comum. Por exemplo, você pode pensar que os requisitos rígidos de senha aumentariam a segurança do seu aplicativo ou site. Você estaria errado.

	 		Políticas rigorosas de senha reduzirão sua segurança. Aqui está uma pequena lista de idéias muito ruins, juntamente com algumas recomendações do NIST: [65]

			Não restrinja o comprimento da senha a menos de 64 caracteres. O NIST recomenda 256 como um bom comprimento máximo.



			Não truque a senha escolhida pelo usuário.



			Não restrinja caracteres especiais como [] (); &%$# ou /. Veja a nota sobre as tabelas Bobby no início desta seção. Se caracteres especiais em sua senha comprometerão seu sistema, você terá problemas maiores. O NIST diz para aceitar todos os caracteres ASCII de impressão, espaço e unicode.



			Não forneça dicas de senha a usuários não autenticados ou solicitar tipos específicos de informações (por exemplo, "Qual foi o nome do seu primeiro animal de estimação?").



			Não desative a função de pasta no navegador. Incluir a funcionalidade do navegador e dos gerentes de senha não torna seu sistema mais seguro; na verdade, ele leva os usuários a criar senhas mais simples e mais curtas que são muito mais fáceis de comprometer. Tanto o NIST nos EUA quanto o Centro Nacional de Segurança Cibernética no Reino Unido exigem especificamente verificadores para permitir a funcionalidade de pasta por esse motivo.



			Não impor outras regras de composição. Por exemplo, não exige nenhuma mistura específica de superior e inferior, numéricos ou caracteres especiais ou proíba caracteres repetidos e assim por diante.



			Não exija arbitrariamente que os usuários alterem suas senhas após algum tempo. Faça isso apenas por um motivo válido (por exemplo, se houver uma violação).





		Você deseja incentivar senhas longas e aleatórias com um alto grau de entropia. Colocar restrições artificiais limita a entropia e incentiva os maus hábitos de senha, deixando as contas do seu usuário vulneráveis à aquisição.





Manter atualizações de segurança


Atualizar sistemas de computador pode ser uma dor enorme. Você precisa desse patch de segurança, mas como um efeito colateral, ele quebra parte do seu aplicativo. Você pode decidir esperar e adiar a atualização até mais tarde. Essa é uma ideia terrível, porque agora seu sistema é vulnerável a uma exploração conhecida.

Dica 73 Aplique patches de segurança rapidamente



Esta dica afeta todos os dispositivos conectados à rede, incluindo telefones, carros, eletrodomésticos, laptops pessoais, máquinas de desenvolvedor, máquinas de construção, servidores de produção e imagens em nuvem. Tudo. E se você acha que isso realmente não importa, lembre -se de que as maiores violações de dados da história (até agora) foram causadas por sistemas que estavam atrasados em suas atualizações.

Não deixe isso acontecer com você.





Senso comum vs. criptografia


É importante ter em mente que o bom senso pode falhar quando se trata de questões de criptografia. A primeira e mais importante regra quando se trata de criptografia nunca é fazer isso você mesmo. [66] Mesmo para algo tão simples quanto senhas, práticas comuns são criadas (veja a barra lateral
Senha antipatherns). Depois de entrar no mundo das criptografia, mesmo o menor e mais insignificante erro de aparência insignificante pode comprometer tudo: seu novo algoritmo de criptografia novo e criado em casa provavelmente pode ser quebrado por um especialista em minutos. Você não quer fazer a criptografia.

Como dissemos em outros lugares, depende apenas de coisas confiáveis: bem-vindos, bem examinados, bem mantidos, freqüentemente atualizados, de preferência bibliotecas e estruturas de código aberto.

Além das tarefas simples de criptografia, dê uma olhada em outros recursos relacionados à segurança do seu site ou aplicativo. Pegue a autenticação, por exemplo.

Para implementar seu próprio login com senha ou autenticação biométrica, você precisa entender como os hashes e sais funcionam, como os biscoitos usam coisas como mesas de arco -íris, por que você não deve usar o MD5 ou o SHA1 e uma série de outras preocupações. E mesmo se você acertar tudo, no final do dia, você ainda é responsável por manter os dados e mantê -los seguros, sujeito a qualquer nova legislação e obrigações legais que surjam.

Ou você pode adotar a abordagem pragmática e deixar alguém se preocupar com isso e usar um provedor de autenticação de terceiros. Este pode ser um serviço pronto para uso que você executa internamente, ou pode ser um terceiro na nuvem. Os serviços de autenticação geralmente estão disponíveis nos provedores de email, telefone ou mídia social, que podem ou não ser apropriados para o seu aplicativo. De qualquer forma, essas pessoas passam todos os dias mantendo seus sistemas seguros e são melhores do que você.

Fique seguro lá fora.





Seções relacionadas incluem


Tópico 23, projeto por contrato

Tópico 24, programas mortos não contam mentiras

Tópico 25, programação assertiva

Tópico 38, Programação por coincidência

Tópico 45, o poço de requisitos





Tópico 44

Nomeando coisas




O início da sabedoria é chamar as coisas pelo seu nome correto.



Confúcio



O que há em um nome? Quando estamos programando, a resposta é "tudo!"

Criamos nomes para aplicativos, subsistemas, módulos, funções, variáveis - estamos constantemente criando coisas novas e concedendo nomes neles. E esses nomes são muito, muito importantes, porque revelam muito sobre sua intenção e crença.

Acreditamos que as coisas devem ser nomeadas de acordo com o papel que desempenham em seu código. Isso significa que, sempre que você cria algo, precisa pausar e pensar "qual é a minha motivação para criar isso?"

Esta é uma pergunta poderosa, porque o tira da mentalidade imediata de solução de problemas e faz você olhar para o quadro geral. Quando você considera o papel de uma variável ou função, está pensando no que é especial, sobre o que ela pode fazer e com o que interage. Muitas vezes, nos encontramos percebendo que o que estávamos prestes a fazer não fazia sentido, tudo porque não podíamos criar um nome apropriado.

Há alguma ciência por trás da ideia de que os nomes são profundamente significativos. Acontece que o cérebro pode ler e entender as palavras muito rápido: mais rápido do que muitas outras atividades. Isso significa que as palavras têm uma certa prioridade quando tentamos entender algo. Isso pode ser demonstrado usando o efeito Stroop. [67]

Olhe para o painel a seguir. Ele possui uma lista de nomes de cores ou tons e cada um é mostrado em uma cor ou sombra. Mas os nomes e cores não correspondem necessariamente. Aqui está a parte um dos desafios - diga em voz alta o nome de cada cor como escrito: [68]



Agora repita isso, mas diga em voz alta a cor usada para desenhar a palavra. Mais difícil, não é? É fácil ser fluente ao ler, mas muito mais difícil ao tentar reconhecer cores.

Seu cérebro trata as palavras escritas como algo a ser respeitado. Precisamos garantir que os nomes que usamos vivam de acordo com isso.

Vejamos alguns exemplos:

Estamos autenticando pessoas que acessam nosso site que vende jóias feitas de placas antigas de gráficos:

Deixe o usuário = autenticar (credenciais)



A variável é usuário porque é sempre usuário. Mas por que? Não significa nada. Que tal cliente ou comprador? Dessa forma, recebemos lembretes constantes enquanto codificamos o que essa pessoa está tentando fazer e o que isso significa para nós.



Temos um método de instância que desconta um pedido:

Public void DeductPercent (quantidade dupla)

// ...



Duas coisas aqui. Primeiro, DeductPercent é o que faz e não por que faz isso. Então, o nome da quantidade de parâmetro é, na melhor das hipóteses, enganador: é uma quantidade absoluta, uma porcentagem?

Talvez isso fosse melhor:

Public Void ApplyDiscount (Desconto percentual)

// ...



O nome do método agora faz sua intenção
claro. Também alteramos o parâmetro de uma porcentagem dupla para uma porcentagem, um tipo que definimos. Não sabemos sobre você, mas ao lidar com porcentagens, nunca sabemos se o valor deve estar entre 0 e 100 ou 0,0 e 1,0. Usando um tipo documenta o que a função espera.



Temos um módulo que faz coisas interessantes com os números de Fibonacci. Uma dessas coisas é calcular o número na sequência. Pare e pense no que você chamaria dessa função.

A maioria das pessoas que pedimos chamaria isso de fib. Parece razoável, mas lembre -se de que normalmente será chamado no contexto de seu módulo, então a chamada seria fib.fib (n). Que tal chamá -lo de ou Nth:

Fib.of (0)# => 0

Fib.nth (20)# => 4181





Ao nomear as coisas, você está constantemente procurando maneiras de esclarecer o que você quer dizer, e esse ato de esclarecimento o levará a uma melhor compreensão do seu código ao escrever.

No entanto, nem todos os nomes precisam ser candidatos a um prêmio literário.


A exceção que prova a regra

Enquanto nos esforçamos para clareza no código, a marca é uma questão diferente.

Há uma tradição bem estabelecida de que projetos e equipes de projeto devem ter nomes obscuros, "inteligentes". Nomes de Pokémon, super -heróis da Marvel, mamíferos fofos, personagens do Senhor dos Anéis, você escolhe.

	Literalmente.





Honrar a cultura


A maioria dos textos introdutórios do computador vai advertir você para nunca usar variáveis de letra única como I, J ou K. [69]

Achamos que eles estão errados. Mais ou menos.

De fato, depende da cultura dessa linguagem ou ambiente de programação específico. Na linguagem de programação C, i, j e k são tradicionalmente usadas como variáveis de incremento de loop, S é usado para uma corda de caractere e assim por diante. Se você programar nesse ambiente, é isso que você está acostumado a ver e seria chocante (e, portanto, errado) violar essa norma. Por outro lado, usar essa convenção em um ambiente diferente, onde não é esperado, é tão errado. Você nunca faria algo hediondo como este exemplo de clojure que atribui uma string à variável i:

(Let [i "Hello World"]

(Println i))



Algumas comunidades de idiomas preferem camelcase, com letras maiúsculas incorporadas, enquanto outras preferem Snake_Case com sublinhados incorporados para separar palavras. É claro que os próprios idiomas aceitarão, mas isso não o torna certo. Honrar a cultura local.

Alguns idiomas permitem um subconjunto de unicode em nomes. Ter uma noção do que a comunidade espera antes de se tornarem fofos com nomes como ɹǝsn ou εξέρχεται.





Consistência


Emerson é famosa por escrever "uma consistência tola é o hobgoblin de Little Minds ...", mas Emerson não estava em uma equipe de programadores.

Todo projeto tem seu próprio vocabulário: palavras de jargão que têm um significado especial para a equipe. “Order” significa uma coisa para uma equipe que cria uma loja on -line e algo muito diferente de uma equipe cuja aplicativo mostra a linhagem de grupos religiosos. É importante que todos da equipe saibam o que essas palavras significam e que as usam de forma consistente.

Uma maneira é incentivar muita comunicação. Se todos emparelham programas e os pares alternam com frequência, o jargão se espalhará osmoticamente.

Outra maneira é ter um glossário do projeto, listando os termos que têm significado especial para a equipe. Este é um documento informal, possivelmente mantido em um wiki, possivelmente apenas os cartões de índice em um muro em algum lugar.

Depois de um tempo, o jargão do projeto terá vida própria. À medida que todos se sentem confortáveis com o vocabulário, você poderá usar o jargão como uma abreviação, expressando muito significado com precisão e concisa. (É exatamente isso que é uma linguagem de padrão.)





Renomear é ainda mais difícil


Não importa quanto esforço você faça na frente, as coisas mudam. O código é refaturado, as mudanças de uso, o significado se torna sutilmente alterado. Se você não está vigilante em atualizar os nomes à medida que avança, pode descer rapidamente em um pesadelo muito pior do que nomes sem sentido: nomes enganosos. Você já teve alguém explicando inconsistências em código como: "A rotina chamada getdata realmente grava dados em um arquivo de arquivo"?

Como discutimos no tópico 3, a entropia de software, quando você identifica um problema, corrija -o - bem aqui e agora. Quando você vê um nome que não expressa mais a intenção ou é enganoso ou confuso, conserte -o. Você tem testes completos de regressão, para identificar qualquer instância que possa ter perdido.

Dica 74 Nome bem; Renomeie quando necessário



Se, por algum motivo
(Veja o tópico 8, a essência do bom design). Corrija isso primeiro e depois altere o nome ofensivo. Facilite a renomeação e faça isso com frequência.

Caso contrário, você precisará explicar às novas pessoas da equipe que o GetData realmente escreve dados em um arquivo, e você terá que fazê -lo com uma cara séria.





Seções relacionadas incluem


Tópico 3, entropia de software

Tópico 40, refatoração

Tópico 45, o poço de requisitos





Desafios


Quando você encontrar uma função ou método com um nome excessivamente genérico, tente renomeá -lo para expressar todas as coisas que realmente faz. Agora é um alvo mais fácil para refatorar.



Em nossos exemplos, sugerimos o uso de nomes mais específicos, como o comprador, em vez do usuário mais tradicional e genérico. Que outros nomes você habitualmente usa que pode ser melhor?



Os nomes do seu sistema são congruentes com os termos do usuário do domínio? Se não, por quê? Isso causa uma dissonância cognitiva no estilo de efeito Stroop para a equipe?



Os nomes do seu sistema são difíceis de mudar? O que você pode fazer para consertar essa janela quebrada em particular?





Notas de rodapé


[50]

NOTA DA BATALHA: UTC está lá por uma razão. Use -o.



[51]

https://en.wikipedia.org/wiki/correlation_does_not_imply_causation



[52]

Veja o tópico 50, os cocos não o cortam.



[53]

Você também pode ir longe demais aqui. Uma vez conhecemos um desenvolvedor que reescreveu toda a fonte que recebeu porque ele tinha suas próprias convenções de nomenclatura.



[54]

https://media-origin.pragprog.com/titles/tpp20/code/algorithm_speed/sort/src/main.rs



[55]

E sim, expressamos nossas preocupações com o título.



[56]

Originalmente avistado em UML destilado: um breve guia para a linguagem de modelagem de objetos padrão [FOW00].



[57]

Este é um excelente conselho em geral (ver tópico 27, não supere seus faróis).



[58]

Algumas pessoas argumentam que o desenvolvimento de teste e teste de teste são duas coisas diferentes, dizendo que as intenções dos dois são diferentes. No entanto, historicamente, o teste primeiro (que vem da programação extrema) era idêntico ao que as pessoas agora chamam de TDD.



[59]

https://ronjeffries.com/categories/sudoku. Um grande "obrigado" a Ron por nos deixar usar esta história.



[60]

http://norvig.com/sudoku.html



[61]

Tentamos desde pelo menos 1986, quando Cox e Novobilski cunharam o termo "Software IC" em sua programação orientada a objetos de objetos Objective-C, uma abordagem evolutiva [CN91].



[62]

Veja o tópico 20, Depuração.



[63]

Lembra do nosso bom amigo, Little Bobby Tables (https://xkcd.com/327)? Enquanto você relembra, dê uma olhada no https://bobby-tables.com, que lista maneiras de higienizar dados passados para consultas de banco de dados.



[64]

Essa técnica provou ser bem-sucedida no nível do chip da CPU, onde explorações conhecidas têm como alvo de depuração e instalações administrativas. 	Uma vez rachado, toda a máquina é deixada exposta.



[65]

NIST Publicação Especial 800-63B: Diretrizes de identidade digital: autenticação e gerenciamento do ciclo de vida, disponíveis gratuitamente on-line em https://doi.org/10.6028/nist.sp.800-63b



[66]

A menos que você tenha um doutorado em criptografia, e mesmo assim apenas com a grande revisão por pares, extensos ensaios de campo com uma recompensa de insetos e orçamento para manutenção a longo prazo.



[67]

Estudos de interferência em reações verbais em série [STR35]



[68]

Temos duas versões deste painel. Um usa cores diferentes e o outro usa tons de cinza. Se você está vendo isso em preto e branco e deseja a versão colorida, ou se estiver com problemas para distinguir cores e deseja experimentar a versão em escala de cinza, vá para https://pragprog.com/the-pragmatic-programmer/stroop-effect.



[69]

Você sabe por que eu é comumente usado como uma variável de loop? A resposta vem de mais de 60 anos atrás, quando variáveis começando com I a n eram inteiros no FORTRAN original. E Fortran, por sua vez, foi influenciado pela álgebra.





Copyright © 2020 Pearson Education, Inc.





Capítulo 8



Antes do projeto




No início de um projeto, você e a equipe precisam aprender os requisitos. Simplesmente dizer o que fazer ou ouvir os usuários não é suficiente: leia o tópico 45, os requisitos e aprenda a evitar as armadilhas e armadilhas comuns.

A sabedoria convencional e o gerenciamento de restrições são os tópicos do tópico 46, resolvendo quebra -cabeças impossíveis. Se você está executando requisitos, análise, codificação ou teste, problemas difíceis surgirão. Na maioria das vezes, eles não serão tão difíceis quanto parecem ser.

E quando esse projeto impossível aparece, gostamos de recorrer à nossa arma secreta:
Tópico 47, trabalhando juntos. E, ao "trabalhar juntos", não queremos compartilhar um documento de requisitos enormes, atirar e -mails fortemente CC ou duradouros para reuniões intermináveis. Queremos dizer resolver problemas juntos durante a codificação. Mostraremos quem você precisa e como começar.

Embora o manifesto ágil comece com "indivíduos e interações sobre processos e ferramentas", praticamente todos os projetos "ágeis" começam com uma discussão irônica de qual processo e quais ferramentas eles usarão. Mas não importa o quão bem pensado seja, e independentemente de quais "melhores práticas" inclui, nenhum método pode substituir o pensamento. Você não precisa de nenhum processo ou ferramenta específico, o que você precisa é o tópico 48, a essência da agilidade.

Com esses problemas críticos resolvidos antes do início do projeto, você pode estar melhor posicionado para evitar a "paralisia da análise" e realmente começar - e completar - seu projeto bem -sucedido.





Tópico 45

O poço de requisitos




A perfeição é alcançada, não quando não resta mais nada a acrescentar

Mas quando não há mais nada para tirar ...



Antoine de St. Exupery, Wind, Sand and Stars, 1939



Muitos livros e tutoriais se referem à coleta de requisitos como uma fase inicial do projeto. A palavra "coleta" parece implicar uma tribo de analistas felizes, buscando pepitas de sabedoria que estão deitadas no chão ao seu redor, enquanto a sinfonia pastoral joga suavemente no fundo. “Reunir” implica que os requisitos já estão lá - você precisa apenas encontrá -los, coloque -os na sua cesta e fique alegremente no seu caminho.

Não funciona assim. Os requisitos raramente estão na superfície. Normalmente, eles estão enterrados profundamente sob camadas de suposições, conceitos errôneos e política. Pior ainda, muitas vezes eles realmente não existem.

Dica 75 ninguém sabe exatamente o que eles querem





O mito dos requisitos


Nos primeiros dias do software, os computadores eram mais valiosos (em termos de custo amortizado por hora) do que as pessoas que trabalharam com eles. Encontramos dinheiro tentando correr as coisas da primeira vez. Parte desse processo estava tentando especificar exatamente o que íamos fazer a máquina fazer. Começamos obtendo uma especificação dos requisitos, parávamos isso em um documento de design, depois em fluxogramas e código pseudo e, finalmente, em código. Antes de alimentá -lo em um computador, porém, passávamos o tempo verificando.

Custou muito dinheiro. E esse custo significava que as pessoas só tentaram automatizar algo quando sabiam exatamente o que queriam. Como as primeiras máquinas eram bastante limitadas, o escopo dos problemas que eles resolveram foi restringido: era realmente possível entender todo o problema antes de você começar.

Mas esse não é o mundo real. O mundo real é bagunçado, conflituoso e desconhecido. Nesse mundo, as especificações exatas de qualquer coisa são raras, se não totalmente impossíveis.

É aí que entram programadores. Nosso trabalho é ajudar as pessoas a entender o que querem. De fato, esse é provavelmente o nosso atributo mais valioso. E vale a pena repetir:

DICA 76 Os programadores ajudam as pessoas a entender o que querem





Programação como terapia


Vamos chamar as pessoas que nos pedem para escrever software de nossos clientes.

O cliente típico vem até nós com uma necessidade. A necessidade pode ser estratégica, mas é a mesma probabilidade de ser uma questão tática: uma resposta a um problema atual. A necessidade pode ser para uma alteração em um sistema existente ou pode pedir algo novo. Às vezes, a necessidade será expressa em termos de negócios e às vezes em técnicos.

O erro que os novos desenvolvedores geralmente cometem é pegar essa declaração de necessidade e implementar uma solução para ela.

Em nossa experiência, essa declaração inicial de necessidade não é um requisito absoluto. O cliente pode não perceber isso, mas é realmente um convite para explorar.

Vamos dar um exemplo simples.

Você trabalha para um editor de artigos e livros eletrônicos. Você recebeu um novo requisito:

O envio deve ser gratuito em todos os pedidos que custam US $ 50 ou mais.



Pare por um segundo e imagine -se nessa posição. Qual é a primeira coisa que vem à mente?

As chances são muito boas por você ter perguntas:

Os US $ 50 incluem impostos?

Os US $ 50 incluem despesas de envio atuais?

Os US $ 50 devem ser para livros em papel ou o pedido também pode incluir e -books?

Que tipo de envio é oferecido? Prioridade? Chão?

E as ordens internacionais?

Com que frequência o limite de US $ 50 mudará no futuro?



É isso que fazemos. Quando recebeu algo que parece simples, irritamos as pessoas procurando casos de borda e perguntando sobre elas.

O
As chances são de que o cliente já tenha pensado em algumas delas e apenas assumiu que a implementação funcionaria dessa maneira. Fazer a pergunta apenas libera essas informações.

Mas outras perguntas provavelmente serão coisas que o cliente não considerou anteriormente. É aí que as coisas ficam interessantes e onde um bom desenvolvedor aprende a ser diplomático.

Você:

Estávamos nos perguntando o total de US $ 50. Isso inclui o que normalmente cobraríamos pelo envio?



Cliente:

Claro. É o total que eles nos pagariam.



Você:

Isso é bom e simples para nossos clientes entenderem: posso ver a atração. Mas posso ver alguns clientes menos escrupulosos tentando jogar esse sistema.



Cliente:

Como assim?



Você:

Bem, digamos que eles comprem um livro por US $ 25 e selecionem o envio noturno, a opção mais cara. Isso provavelmente será de US $ 30, fazendo todo o pedido de US $ 55. Em seguida, tornaríamos o frete grátis e eles receberíamos o envio noturno em um livro de US $ 25 por apenas US $ 25.

(Neste ponto, o desenvolvedor experiente para. Entregue fatos e deixe o cliente tomar as decisões,)



Cliente:

Ai. Certamente não era o que eu pretendia; Perderíamos dinheiro nesses pedidos. Quais são as opções?





E isso inicia uma exploração. Seu papel nisso é interpretar o que o cliente diz e alimentar para eles as implicações. Este é um processo intelectual e criativo: você está pensando em pé e está contribuindo para uma solução que provavelmente será melhor do que uma que você ou o cliente teriam produzido sozinho.





Os requisitos são um processo


No exemplo anterior, o desenvolvedor aceitou os requisitos e o Fed-Back uma conseqüência para o cliente. Isso iniciou a exploração. Durante essa exploração, é provável que você apresente mais feedback à medida que o cliente toca com diferentes soluções. Esta é a realidade de todos os requisitos coletando:

Dica 77 Os requisitos são aprendidos em um ciclo de feedback



Seu trabalho é ajudar o cliente a entender as consequências de seus requisitos declarados. Você faz isso gerando feedback e permitindo que eles usem esse feedback para refinar o pensamento deles.

No exemplo anterior, o feedback foi fácil de expressar em palavras. Às vezes, esse não é o caso. E às vezes você honestamente não sabe o suficiente sobre o domínio para ser tão específico quanto isso.

Nesses casos, os programadores pragmáticos confiam no “É isso que você quis dizer?” Escola de Feedback. Produzimos modelos e protótipos e deixamos o cliente brincar com eles. Idealmente, as coisas que produzimos são flexíveis o suficiente para que possamos alterá -las durante nossas discussões com o cliente, deixando -nos responder a "isso não é o que eu quis dizer" com "tão mais assim?"

Às vezes, esses modelos podem ser reunidos em uma hora ou mais. Obviamente, eles são apenas hacks para ter uma idéia.

Mas a realidade é que todo o trabalho que fazemos é na verdade alguma forma de maquete. Mesmo no final de um projeto, ainda estamos interpretando o que nosso cliente deseja. De fato, naquele momento, é provável que tenhamos mais clientes: as pessoas, operações, o marketing e talvez até testam grupos de clientes.

Portanto, o programador pragmático analisa todo o projeto como um exercício de coleta de requisitos. É por isso que preferimos iterações curtas; aqueles que terminam com feedback direto do cliente. Isso nos mantém no caminho certo e garante que, se seguirmos na direção errada, a quantidade de tempo perdida será minimizada.





Ande no lugar do seu cliente


Existe uma técnica simples para colocar as cabeças de seus clientes que não são usadas com frequência: Torne -se um cliente. Você está escrevendo um sistema para o suporte técnico? Passe alguns dias monitorando os telefones com uma pessoa de apoio experiente. Você está automatizando um sistema manual de controle de estoque? Trabalhe no armazém por uma semana. [70]

Além de fornecer uma visão de como o sistema será realmente usado, você ficará surpreso com a solicitação: "Posso ficar sentado por uma semana enquanto você faz seu trabalho?

Dica 78 Trabalhe com um usuário para pensar como um usuário



A coleta de feedback também é o momento de começar a criar um relacionamento com sua base de clientes, aprendendo suas expectativas e esperanças para o sistema que você está construindo. Consulte o Tópico 52, encanta seus usuários, para mais.





Requisitos vs. Política


Vamos imaginar que, ao discutir um sistema de recursos humanos, um cliente diz "apenas os supervisores de um funcionário e o departamento de pessoal podem ver os registros desse funcionário". Esta afirmação é realmente um requisito?
Talvez hoje, mas incorpore a política de negócios em uma declaração absoluta.

Política de Negócios? Exigência? É uma distinção relativamente sutil, mas é uma que terá implicações profundas para os desenvolvedores. Se o requisito for declarado como "apenas supervisores e pessoal poderão visualizar um registro de funcionários", o desenvolvedor poderá acabar codificando um teste explícito toda vez que o aplicativo acessa esses dados. No entanto, se a instrução for "apenas usuários autorizados poderão acessar um registro de funcionários", o desenvolvedor provavelmente projetará e implementará algum tipo de sistema de controle de acesso. Quando a política muda (e será), apenas os metadados desse sistema precisarão ser atualizados. De fato, a coleta de requisitos dessa maneira naturalmente o leva a um sistema bem fatorado para apoiar os metadados.

De fato, há uma regra geral aqui:

Dica 79 Política é metadada



Implemente o caso geral, com as informações da política como um exemplo do tipo de coisa que o sistema precisa suportar.





Requisitos vs. realidade


Em um artigo da revista Wired, em janeiro de 1999, o produtor e músico Brian Eno descreveu uma peça incrível de tecnologia - o melhor quadro de mixagem. Faz qualquer coisa para soar que possa ser feito. E, no entanto, em vez de deixar os músicos fazer música melhor ou produzir uma gravação mais rápida ou menos dispensada, ele atrapalha; Isso interrompe o processo criativo.

Para ver o porquê, você deve ver como os engenheiros de gravação funcionam. Eles equilibram sons intuitivamente. Ao longo dos anos, eles desenvolvem um ciclo de feedback inato entre os ouvidos e as pontas dos dedos - derrotando faders, botões girando e assim por diante. No entanto, a interface para o novo misturador não aproveitou essas habilidades. Em vez disso, forçou seus usuários a digitar um teclado ou clicar em um mouse. As funções fornecidas foram abrangentes, mas foram embaladas de maneiras desconhecidas e exóticas. As funções que os engenheiros precisavam às vezes estavam escondidas atrás de nomes obscuros ou foram alcançados com combinações não intuitivas de instalações básicas.

Este exemplo também ilustra nossa crença de que as ferramentas bem -sucedidas se adaptam às mãos que as usam. A coleta de requisitos bem -sucedida leva isso em consideração. E é por isso que o feedback antecipado, com protótipos ou balas do Tracer, permitirá que seus clientes digam "sim, faz o que eu quero, mas não como eu quero".





Documentando requisitos


Acreditamos que a melhor documentação de requisitos, talvez a única documentação de requisitos, é o código de trabalho.

Mas isso não significa que você pode fugir sem documentar sua compreensão do que o cliente deseja. Significa apenas que esses documentos não são entregues: eles não são algo que você dá a um cliente para assinar. Em vez disso, eles são simplesmente milespostos para ajudar a orientar o processo de implementação.





Os documentos de requisitos não são para clientes


No passado, Andy e Dave estavam em projetos que produziam requisitos incrivelmente detalhados. Esses documentos substanciais expandiram a explicação inicial de dois minutos do cliente sobre o que era desejado, produzindo obras-primas de espessura de polegadas cheias de diagramas e tabelas. As coisas foram especificadas até o ponto em que quase não havia espaço para ambiguidade na implementação. Dadas ferramentas suficientemente poderosas, o documento pode ser o programa final.

Criar esses documentos foi um erro por dois motivos. Primeiro, como discutimos, o cliente realmente não sabe o que deseja antecipadamente. Então, quando pegamos o que eles dizem e o expandimos para o que é quase um documento legal, estamos construindo um castelo incrivelmente complexo na areia movediça.

Você pode dizer "mas depois levamos o documento ao cliente e eles assinam isso. Estamos recebendo feedback". E isso nos leva ao segundo problema com essas especificações de requisitos: o cliente nunca as lê.

O cliente usa programadores porque, enquanto o cliente é motivado resolvendo um problema de alto e um tanto nebuloso, os programadores estão interessados em todos os detalhes e nuances. O documento de requisitos é escrito para desenvolvedores e contém informações e sutilezas que às vezes são incompreensíveis e frequentemente chatas para o cliente.

Envie um documento de requisitos de 200 páginas e o cliente provavelmente ele decidirá que ele pesa o suficiente para ser importante, eles podem ler os primeiros parágrafos (e é por isso que os dois primeiros parágrafos sempre são intitulados resumo da gerência) e eles podem passar pelo resto, às vezes parando quando há um diagrama.

Isso não está abaixando o cliente. Mas dando a eles um grande técnico
O documento é como dar ao desenvolvedor médio uma cópia da Ilíada em Homeric Greek e pedir que eles codificam o videogame.





Os documentos de requisitos são para planejar


Portanto, não acreditamos no documento de requisitos monolítico, o suficiente para ficar-a-estrondo. No entanto, sabemos que os requisitos precisam ser escritos, simplesmente porque os desenvolvedores de uma equipe precisam saber o que farão.

Que forma isso leva? Apreciamos algo que possa se encaixar em um cartão de índice real (ou virtual). Essas descrições curtas são frequentemente chamadas de histórias de usuários. Eles descrevem o que uma pequena parte do aplicativo deve fazer da perspectiva de um usuário dessa funcionalidade.

Quando escritos dessa maneira, os requisitos podem ser colocados em uma placa e movidos para mostrar status e prioridade.

Você pode pensar que um único cartão de índice não pode conter as informações necessárias para implementar um componente do aplicativo. Você estaria certo. E isso faz parte do ponto. Ao manter essa declaração de requisitos curtos, você está incentivando os desenvolvedores a fazer perguntas esclarecedoras. Você está aprimorando o processo de feedback entre clientes e codificadores antes e durante a criação de cada peça de código.





Especificação excessiva


Outro grande perigo na produção de um documento de requisitos está sendo muito específico. Bons requisitos são abstratos. No que diz respeito aos requisitos, a afirmação mais simples que reflete com precisão a necessidade dos negócios é a melhor. Isso não significa que você pode ser vago - você deve capturar os invariantes semânticos subjacentes como requisitos e documentar as práticas de trabalho específicas ou atuais como política.

Os requisitos não são arquitetura. Os requisitos não são design, nem são a interface do usuário. Os requisitos são necessários.





Apenas mais um hortelã fino de wafer…


Muitas falhas no projeto são responsabilizadas por um aumento no escopo - também conhecido como inchaço de recursos, featurismo rastejante ou fluência de requisitos. Este é um aspecto da síndrome de Frog cozida do tópico 4, sopa de pedra e sapos cozidos. O que podemos fazer para impedir que os requisitos se tornem em nós?

A resposta (novamente) é feedback. Se você estiver trabalhando com o cliente em iterações com feedback constante, o cliente experimentará em primeira mão o impacto de "apenas mais um recurso". Eles verão outro cartão de história subir no quadro e ajudarão a escolher outro cartão para se mudar para a próxima iteração para dar espaço. O feedback funciona nos dois sentidos.





Mantenha um glossário


Assim que você começar a discutir os requisitos, os usuários e os especialistas em domínio usarão certos termos que têm significado específico para eles. Eles podem diferenciar entre um "cliente" e um "cliente", por exemplo. Seria inapropriado usar qualquer palavra casualmente no sistema.

Crie e mantenha um glossário do projeto - um local que define todos os termos e vocabulário específicos usados em um projeto. Todos os participantes do projeto, dos usuários finais para apoiar a equipe, devem usar o glossário para garantir a consistência. Isso implica que o glossário precisa ser amplamente acessível - um bom argumento para a documentação on -line.

Dica 80 Use um glossário do projeto



É difícil ter sucesso em um projeto se os usuários e desenvolvedores chamarem a mesma coisa por nomes diferentes ou, pior ainda, se referem a coisas diferentes com o mesmo nome.





Seções relacionadas incluem


Tópico 5, software bom o suficiente

Tópico 7, comunique!

Tópico 11, reversibilidade

Tópico 13, protótipos e notas post-it

Tópico 23, projeto por contrato

Tópico 43, fique seguro lá fora

Tópico 44, nomeando coisas

Tópico 46, resolvendo quebra -cabeças impossíveis

Tópico 52, encanta seus usuários





Exercícios


Exercício 33 (resposta possível)

Quais das seguintes opções são provavelmente requisitos genuínos? Reafirmar aqueles que não os não devem torná -los mais úteis (se possível).

O tempo de resposta deve ser inferior a ~ 500ms.

As janelas modais terão um fundo cinza.

O aplicativo será organizado como vários processos front-end e um servidor de back-end.

Se um usuário inserir caracteres não numéricos em um campo numérico, o sistema exibirá o fundo do campo e não os aceitará.

O código e os dados para este aplicativo incorporado devem se encaixar em 32 MB.





Desafios


Você pode usar o software que está escrevendo? É possível ter uma boa sensação de requisitos sem poder usar o software?



Escolha um problema não relacionado ao computador que você precisa resolver atualmente. Gere requisitos para uma solução não computadora.





Tópico 46

Resolvendo quebra -cabeças impossíveis




Gordius, o rei da Frígia, uma vez deu um nó que ninguém poderia desamarrar. Era
disse que quem resolveu o enigma do nó Gordiano governaria toda a Ásia. Então vem Alexandre, o Grande, que corta o nó para pedaços com a espada. Apenas uma interpretação pouco diferente dos requisitos, tudo isso ... E ele acabou governando a maior parte da Ásia.





De vez em quando, você se encontrará envolvido no meio de um projeto quando surgir um quebra -cabeça muito difícil: uma peça de engenharia que você simplesmente não consegue controlar, ou talvez um pouco de código que esteja se tornando muito mais difícil de escrever do que você pensava. Talvez pareça impossível. Mas é realmente tão difícil quanto parece?

Considere quebra-cabeças do mundo real-aqueles pequenos pedaços de madeira, ferro forjado ou plástico que parecem aparecer como presentes de Natal ou nas vendas de garagem. Tudo o que você precisa fazer é remover o anel ou ajustar as peças em forma de T na caixa, ou o que seja.

Então você puxa o ringue ou tenta colocar o TS na caixa e descobrir rapidamente que as soluções óbvias simplesmente não funcionam. O quebra -cabeça não pode ser resolvido dessa maneira. Mas, embora seja óbvio, isso não impede as pessoas de tentarem a mesma coisa - por mais ou menos - pensar que deve haver uma maneira.

Claro, não há. A solução está em outro lugar. O segredo para resolver o quebra -cabeça é identificar as restrições reais (não imaginadas) e encontrar uma solução nela. Algumas restrições são absolutas; Outros são apenas noções preconcebidas. Restrições absolutas devem ser honradas, por mais desagradáveis ou estúpidas que pareçam ser.

Por outro lado, como Alexander provou, algumas restrições aparentes podem não ser restrições reais. Muitos problemas de software podem ser tão sorrateiros.





Graus de liberdade


A popular frase do zumbido “Pensar fora da caixa” nos incentiva a reconhecer restrições que podem não ser aplicáveis e a ignorá-las. Mas essa frase não é totalmente precisa. Se a "caixa" for o limite de restrições e condições, o truque é encontrar a caixa, o que pode ser consideravelmente maior do que você pensa.

A chave para resolver quebra -cabeças é reconhecer as restrições colocadas em você e reconhecer os graus de liberdade que você possui, pois naqueles que encontrará sua solução. É por isso que alguns quebra -cabeças são tão eficazes; Você pode descartar as soluções em potencial com muita facilidade.

Por exemplo, você pode conectar todos os pontos no seguinte quebra -cabeça e retornar ao ponto de partida com apenas três linhas retas - sem levantar a caneta do papel ou refazer suas etapas (quebra -cabeças e jogos matemáticos [Hol92])?



Você deve desafiar quaisquer noções preconcebidas e avaliar se elas são ou não restrições reais e rápidas.

Não é se você pensa dentro da caixa ou fora da caixa. O problema está em encontrar a caixa - identificando as restrições reais.

Dica 81 Não pense fora da caixa - encontre a caixa



Quando confrontado com um problema intratável, enumere todas as avenidas possíveis que você tem antes de você. Não descarte nada, por mais inutilizável ou estúpido. Agora passe pela lista e explique por que um determinado caminho não pode ser seguido. Tem certeza? Você pode provar isso?

Considere o cavalo de Trojan - uma nova solução para um problema intratável. Como você coloca tropas em uma cidade murada sem ser descoberta? Você pode apostar que "pela porta da frente" foi inicialmente demitida como suicídio.

Categorize e priorize suas restrições. Quando os marceneiros começam um projeto, eles cortam as peças mais longas primeiro e depois cortam os pedaços menores da madeira restante. Da mesma maneira, queremos identificar as restrições mais restritivas primeiro e ajustar as restrições restantes dentro delas.

A propósito, uma solução para o quebra -cabeça dos quatro posts é mostrada no final do livro.





Saia do seu próprio caminho!


Às vezes, você se encontra trabalhando em um problema que parece muito mais difícil do que você pensava que deveria ser. Talvez pareça que você está seguindo o caminho errado - que deve haver uma maneira mais fácil do que isso! Talvez você esteja atrasado no cronograma agora, ou mesmo desespero de fazer com que o sistema funcione, porque esse problema em particular é "impossível".

Este é o momento ideal para fazer outra coisa por um tempo. Trabalhe em algo diferente. Vá andar pelo cachorro. Durma nele.

Seu cérebro consciente está ciente do problema, mas seu cérebro consciente é realmente muito burro (sem ofensa). Portanto, é hora de dar ao seu cérebro real, aquela incrível rede neural associativa que se esconde abaixo da sua consciência, algum espaço. Você ficará surpreso com a frequência com que a resposta aparecerá na sua cabeça quando você se distrair deliberadamente.

Se isso soa também
místico para você, não é. Psicologia hoje [72] relatórios:

Para dizer claramente-as pessoas que estavam distraídas se saíram melhor em uma complexa tarefa de solução de problemas do que as pessoas que fizeram um esforço consciente.



Se você ainda não está disposto a abandonar o problema por um tempo, a próxima melhor coisa é encontrar alguém para explicar. Muitas vezes, a distração de simplesmente falar sobre isso o leva à iluminação.

Peça que eles façam perguntas como:

Por que você está resolvendo esse problema?



Qual é o benefício de resolvê -lo?



Os problemas que você está tendo relacionados a casos de borda? Você pode eliminá -los?



Existe um problema mais simples e relacionado que você pode resolver?





Este é outro exemplo de borracha se esquivando na prática.





Fortuna favorece a mente preparada


Louis Pasteur é relatado como disse:

Dans Les Champs de L'Estimation Le Hasard ne Favorise Que Les Esprits Préparés.

(Quando se trata de observação, a fortuna favorece a mente preparada.)



Isso também é verdade para a solução de problemas. Para ter esses Eureka! Momentos, seu cérebro não consciente precisa ter muita matéria -prima; Experiências anteriores que podem contribuir para uma resposta.

Uma ótima maneira de alimentar seu cérebro é dar feedback sobre o que funciona e o que não funciona ao fazer seu trabalho diário. E descrevemos uma ótima maneira de fazer isso usando um diário de engenharia (tópico 22, Daybooks de engenharia).

E lembre -se sempre dos conselhos sobre a capa do Guia do MacHHiker para a Galáxia: não entre em pânico.





Seções relacionadas incluem


Tópico 5, software bom o suficiente

Tópico 37, ouça seu cérebro de lagarto

Tópico 45, o poço de requisitos

Andy escreveu um livro inteiro sobre esse tipo de coisa: Pensamento Pragmático e Aprendizagem: Refactor seu Wetware [HUN08].





Desafios


Dê uma olhada em qualquer problema difícil em que você esteja envolvido hoje. Você pode cortar o nó Gordiano? Você tem que fazer dessa maneira? Você tem que fazer isso?



Você recebeu um conjunto de restrições quando assinou seu projeto atual? Eles ainda são aplicáveis e a interpretação deles ainda é válida?





Tópico 47

Trabalhando juntos




	Eu nunca conheci um ser humano que gostaria de ler 17.000 páginas de documentação e, se houvesse, o mataria para tirá -lo do pool de genes.



Joseph Costello, Presidente da Cadence



Foi um daqueles projetos "impossíveis", do tipo que você ouve sobre isso, parece emocionante e aterrorizante ao mesmo tempo. Um sistema antigo estava se aproximando do fim da vida, o hardware estava desaparecendo fisicamente e um sistema novinho em folha precisava ser criado que correspondesse exatamente ao comportamento (geralmente sem documentos). Muitas centenas de milhões de dólares de dinheiro de outras pessoas passariam por esse sistema, e o prazo desde o início à implantação era da ordem dos meses.

E é aí que Andy e Dave se conheceram. Um projeto impossível com um prazo ridículo. Houve apenas uma coisa que fez do projeto um sucesso estrondoso. A especialista que administrava esse sistema há anos estava sentada ali em seu escritório, do outro lado do corredor da sala de desenvolvimento de tamanho de armário. Disponível continuamente para perguntas, esclarecimentos, decisões e demos.

Ao longo deste livro, recomendamos trabalhar em estreita colaboração com os usuários; Eles fazem parte da sua equipe. Nesse primeiro projeto juntos, praticamos o que agora pode ser chamado de programação de pares ou programação da multidão: uma pessoa digitando código enquanto um ou mais outros membros da equipe comentam, ponderam e resolvem problemas juntos. É uma maneira poderosa de trabalhar em conjunto que transcende inúmeras reuniões, memorandos e documentação legalista exagerada apreciada por peso sobre a utilidade.

E é isso que realmente queremos dizer com "trabalho": não apenas fazendo perguntas, discussões e anotações, mas fazendo perguntas e tendo discussões enquanto você realmente codifica.


Lei de Conway

	 	 	 	 	 	 		Em 1967, Melvin Conway apresentou uma idéia em como os comitês inventam? [CON68] que se tornaria conhecido como lei de Conway:

Organizações que os sistemas de design são restringidos a produzir projetos que são cópias das estruturas de comunicação dessas organizações.



		Ou seja, as estruturas sociais e os caminhos de comunicação da equipe e da organização serão espelhados no aplicativo, site ou produto que está sendo desenvolvido. Vários estudos mostraram forte apoio a essa idéia. Nós testemunhamos isso em primeira mão inúmeras vezes-por exemplo, em equipes em que ninguém fala um com o outro, resultando em sistemas Siled "Stove-Tipe". Ou equipes isso
foram divididos em dois, resultando em um cliente/servidor ou divisão de front -end/back -end.

		Os estudos também oferecem suporte para o princípio reverso: você pode estruturar deliberadamente sua equipe da maneira que deseja que seu código pareça. Por exemplo, equipes geograficamente distribuídas são mostradas para tender a um software mais modular e distribuído.

		Mas o mais importante é que as equipes de desenvolvimento que incluem usuários produzirão software que reflete claramente esse envolvimento, e as equipes que não se incomodam refletirão isso também.





Param de programação


A programação de pares é uma das práticas de programação extrema que se tornou popular fora do próprio XP. Na programação de pares, um desenvolvedor opera o teclado e o outro não. Ambos trabalham juntos no problema e podem alternar as tarefas de digitação, conforme necessário.

Existem muitos benefícios para emparelhar a programação. Pessoas diferentes trazem diferentes origens e experiência, diferentes técnicas e abordagens de solução de problemas e diferentes níveis de foco e atenção a qualquer problema. O desenvolvedor que atua como datilógrafo deve se concentrar nos detalhes de baixo nível do estilo de sintaxe e codificação, enquanto o outro desenvolvedor é livre para considerar problemas e escopo de nível superior. Embora isso possa parecer uma pequena distinção, lembre -se de que nós, humanos, temos apenas muita largura de banda cerebral. Brincadeiro com as palavras e símbolos esotéricos que o compilador aceitará de má vontade exige um pouco de nosso próprio poder de processamento. Ter um segundo cérebro completo de um desenvolvedor disponível durante a tarefa traz muito mais poder mental para suportar.

A pressão dos pares inerente a uma segunda pessoa ajuda contra momentos de fraqueza e maus hábitos de nomear variáveis foo e tal. Você está menos inclinado a tomar um atalho potencialmente embaraçoso quando alguém está assistindo ativamente, o que também resulta em software de alta qualidade.





Programação da máfia


E se duas cabeças são melhores que uma, que tal ter uma dúzia de pessoas diversas, todas trabalhando no mesmo problema ao mesmo tempo, com um datilógrafo?

A programação da máfia, apesar do nome, não envolve tochas ou forças. É uma extensão da programação de pares que envolve mais do que apenas dois desenvolvedores. Os proponentes relatam ótimos resultados usando mobs para resolver problemas difíceis. As multidões podem incluir facilmente pessoas geralmente não consideradas parte da equipe de desenvolvimento, incluindo usuários, patrocinadores de projetos e testadores. De fato, em nosso primeiro projeto "impossível" juntos, era uma visão comum para um de nós estar digitando enquanto o outro discutia o problema com nosso especialista em negócios. Era uma pequena multidão de três.

Você pode pensar na programação da máfia como uma colaboração apertada com a codificação ao vivo.





O que devo fazer?


Se você está atualmente apenas programando solo, talvez tente programar em pares. Dê um mínimo de duas semanas, apenas algumas horas de cada vez, pois parecerá estranho a princípio. Para debater novas idéias ou diagnosticar problemas espinhosos, talvez tente uma sessão de programação da máfia.

Se você já está emparelhando ou se mobbing, quem está incluído? É apenas desenvolvedores, ou você permite que membros da sua equipe estendida participem: usuários, testadores, patrocinadores ...?

E, como em toda a colaboração, você precisa gerenciar os aspectos humanos e o técnico. Aqui estão apenas algumas dicas para começar:

Crie o código, não o seu ego. Não é sobre quem é mais brilhante; Todos nós temos nossos momentos, bons e ruins.

Comece pequeno. Mob com apenas 4-5 pessoas, ou comece com apenas alguns pares, em sessões curtas.

Critique o código, não a pessoa. "Vamos olhar para esse bloco" parece muito melhor do que "você está errado".

Ouça e tente entender os pontos de vista dos outros. Diferente não está errado.

Realize retrospectivas frequentes para tentar melhorar para a próxima vez.



A codificação no mesmo escritório ou controle remoto, sozinho, em pares ou em mobs, são maneiras eficazes de trabalhar juntos para resolver problemas. Se você e sua equipe apenas fizeram isso de uma maneira, pode querer experimentar um estilo diferente. Mas não entre em uma abordagem ingênua: existem regras, sugestões e diretrizes para cada um desses estilos de desenvolvimento. Por exemplo, com a programação da máfia, você troca o datilógrafo a cada 5 a 10 minutos.

Faça algumas leituras e pesquisas, de livros didáticos e de experiência, e tenha uma idéia das vantagens e armadilhas que você pode encontrar. Você pode começar codificando um exercício simples, e não apenas pular direto para o seu código de produção mais difícil.

Mas, no entanto, você faz isso, sugerimos um conselho final:

Dica 82 Não entre no código sozinho





Tópico 48

A essência da agilidade




Você
Continue usando essa palavra, não acho que isso significa

O que você acha que significa.



Inigo Montoya, a Princesa Noiva



Agile é um adjetivo: é como você faz alguma coisa. Você pode ser um desenvolvedor ágil. Você pode estar em uma equipe que adota práticas ágeis, uma equipe que responde a mudanças e contratempos com agilidade. Agilidade é o seu estilo, não você.

Dica 83 Agile não é um substantivo; Ágil é como você faz coisas



Enquanto escrevemos isso, quase 20 anos após o início do Manifesto para o Desenvolvimento de Software Agile, [73] vemos muitos, muitos desenvolvedores aplicando seus valores com sucesso. Vemos muitas equipes fantásticas que encontram maneiras de pegar esses valores e usá -los para orientar o que fazem e como eles mudam o que fazem.

Mas também vemos outro lado da agilidade. Vemos equipes e empresas ansiosas por soluções prontas para uso: ágil em uma caixa. E vemos muitos consultores e empresas muito felizes em vender o que querem. Vemos empresas que adotam mais camadas de gerenciamento, relatórios mais formais, desenvolvedores mais especializados e mais cargos sofisticados que apenas significam "alguém com uma prancheta e um cronômetro". [74]

Sentimos que muitas pessoas perderam de vista o verdadeiro significado da agilidade e gostaríamos de ver as pessoas retornarem ao básico.

Lembre -se dos valores do manifesto:

Estamos descobrindo melhores maneiras de desenvolver software, fazendo isso e ajudando os outros a fazer isso. Através deste trabalho, chegamos a valorizar:



Indivíduos e interações sobre processos e ferramentas



Software de trabalho sobre documentação abrangente



Colaboração de clientes sobre negociação do contrato



Respondendo à mudança após um plano





Ou seja, embora haja valor nos itens à direita, valorizamos mais os itens à esquerda.



Qualquer pessoa que te vende algo que aumenta a importância das coisas à direita sobre as coisas à esquerda claramente não valoriza as mesmas coisas que nós e os outros escritores de manifesto fizeram.

E qualquer pessoa que venda uma solução em uma caixa não leu a declaração introdutória. Os valores são motivados e informados pelo ato contínuo de descobrir melhores maneiras de produzir software. Este não é um documento estático. São sugestões para um processo generativo.





Nunca pode haver um processo ágil


De fato, sempre que alguém disser "faça isso e você ficará ágil", eles estão errados. Por definição.

Porque a agilidade, tanto no mundo físico quanto no desenvolvimento de software, tem tudo a ver com mudar, respondendo às incógnitas que você encontra depois de estabelecer. Uma gazela em execução não entra em linha reta. Uma ginasta faz centenas de correções um segundo, enquanto respondem a mudanças em seu ambiente e pequenos erros na colocação dos pés.

Assim é com equipes e desenvolvedores individuais. Não existe um plano único que você possa seguir ao desenvolver software. Três dos quatro valores dizem isso. Eles são tudo sobre reunir e responder ao feedback.

Os valores não dizem o que fazer. Eles dizem o que procurar quando você decidir por si mesmo o que fazer.

Essas decisões são sempre contextuais: elas dependem de quem você é, a natureza de sua equipe, seu aplicativo, sua ferramenta, sua empresa, seu cliente, o mundo exterior; Um número incrivelmente grande de fatores, alguns maiores e outros triviais. Nenhum plano estático fixo pode sobreviver a essa incerteza.





Então, o que fazemos?


Ninguém pode dizer o que fazer. Mas achamos que podemos lhe dizer algo sobre o espírito com o qual você faz isso. Tudo se resume a como você lida com a incerteza. O manifesto sugere que você faça isso reunindo e agindo sobre feedback. Então, aqui está a nossa receita para trabalhar de maneira ágil:





1. Trabalhe onde você está.





2. Faça o menor passo significativo em direção aonde você quer estar.





3. Avalie onde você acaba e corrija tudo o que quebrou.





Repita essas etapas até que você termine. E use -os recursivamente, em todos os níveis de tudo que você faz.

Às vezes, mesmo a decisão mais trivial se torna importante quando você recebe feedback.



“Agora meu código precisa obter o proprietário da conta.

Deixe o usuário = conta de conta (conta);



Hmmm ... o usuário é um nome inútil. Vou fazer do proprietário.

Deixe o proprietário = conta de conta (conta);



Mas agora isso parece um pouco redundante. O que estou realmente tentando fazer aqui? A história diz que estou enviando um e -mail a essa pessoa, então preciso encontrar o endereço de e -mail deles. Talvez eu não precise de todo o proprietário da conta.

Deixe email = emailofaccoundowner (AccountId);





Aplicando o loop de feedback em um nível muito baixo (a nomeação de uma variável), temos
Na verdade, melhorou o design do sistema geral, reduzindo o acoplamento entre esse código e o código que lida com contas.

O loop de feedback também se aplica ao nível mais alto de um projeto. Alguns de nossos trabalhos mais bem -sucedidos aconteceram quando começamos a trabalhar nos requisitos de um cliente, deram um único passo e percebemos que o que estávamos prestes a fazer não era necessário, que a melhor solução nem envolveu software.

Esse loop se aplica fora do escopo de um único projeto. As equipes devem aplicá -lo para revisar seu processo e quão bem funcionou. Uma equipe que não experimenta continuamente seu processo não é uma equipe ágil.





E isso impulsiona o design


No tópico 8, a essência do bom design, afirmamos que a medida do design é como o resultado desse design é alterar: um bom design produz algo mais fácil de mudar do que um design ruim.

E essa discussão sobre agilidade explica por que esse é o caso.

Você faz uma mudança e descobre que não gosta. A etapa 3 da nossa lista diz que precisamos ser capazes de consertar o que quebramos. Para tornar nosso loop de feedback eficiente, essa correção deve ser o mais indolor possível. Caso contrário, ficaremos tentados a dar de ombros e deixá -lo não fixado. Falamos sobre esse efeito no tópico 3, entropia de software. Para fazer com que toda essa coisa ágil funcione, precisamos praticar um bom design, porque um bom design facilita a mudança das coisas. E se for fácil mudar, podemos ajustar, em todos os níveis, sem qualquer hesitação.

Isso é agilidade.





Seções relacionadas incluem


Tópico 27, não supere seus faróis

Tópico 40, refatoração

Tópico 50, cocos não o cortam





Desafios


O loop de feedback simples não é apenas para software. Pense em outras decisões que você tomou recentemente. Algum deles poderia ter sido melhorado pensando em como você poderá desfazê -los se as coisas não o levaram na direção que você estava indo? Você pode pensar em maneiras de melhorar o que faz reunindo e agindo sobre feedback?





Notas de rodapé


[70]

Uma semana parece muito tempo? Realmente não é, principalmente quando você procura processos em que a gerência e os trabalhadores ocupam mundos diferentes. A gerência dará a você uma visão de como as coisas operam, mas quando você descer no chão, encontrará uma realidade muito diferente - que levará tempo para assimilar.



[71]

https://www.wired.com/1999/01/eno/



[72]

https://www.psychologytoday.com/us/blog/your-brain-work/201209/stop-trying-solve-problems



[73]

https://agilemanifesto.org



[74]

Para saber mais sobre o quão ruim essa abordagem pode ser, consulte a tirania das métricas [MUL18].





Copyright © 2020 Pearson Education, Inc.





Capítulo 9



Projetos pragmáticos




À medida que seu projeto começa, precisamos nos afastar de questões de filosofia e codificação individuais para falar sobre questões maiores e do tamanho de um projeto. Não vamos entrar em detalhes de gerenciamento de projetos, mas falaremos sobre um punhado de áreas críticas que podem fazer ou quebrar qualquer projeto.

Assim que você tiver mais de uma pessoa trabalhando em um projeto, você precisa estabelecer algumas regras básicas e delegar partes do projeto de acordo. No tópico 49, equipes pragmáticas, mostraremos como fazer isso ao honrar a filosofia pragmática.

O objetivo de um método de desenvolvimento de software é ajudar as pessoas a trabalharem juntas. Você e sua equipe estão fazendo o que funciona bem para você, ou está investindo apenas nos artefatos triviais da superfície e não obtendo os benefícios reais que merece? Vamos ver por que o tópico 50, os cocos não o cortam e oferecem o verdadeiro segredo ao sucesso.

E é claro que nada disso importa se você não conseguir fornecer software de forma consistente e confiável. Essa é a base do trio mágico de controle de versão, teste e automação: o tópico 51, Pragmatic Starter Kit.

Em última análise, porém, o sucesso está nos olhos de quem vê - o patrocinador do projeto. A percepção do sucesso é o que conta e, no tópico 52, encanta seus usuários, mostraremos como encantar o patrocinador de todos os projetos.

A última dica do livro é uma conseqüência direta de todo o resto. No Tópico 53, Orgulho e Preconceito, pedimos que você assine seu trabalho e se orgulhe do que você faz.





Tópico 49

Equipes pragmáticas




No Grupo L, Stoffel supervisiona seis programadores de primeira classe, um desafio gerencial aproximadamente comparável aos gatos pastoreio.



The Washington Post Magazine, 9 de junho de 1985



Mesmo em 1985, a piada sobre pastorear gatos estava envelhecendo. Na época da primeira edição na virada do século, era positivamente antiga. Ainda assim
persiste, porque tem um anel de verdade. Os programadores são um pouco como gatos: inteligentes, fortes, opinativos, independentes e muitas vezes adorados pela rede.

Até agora, neste livro, analisamos técnicas pragmáticas que ajudam um indivíduo a ser um melhor programador. Esses métodos também podem funcionar para as equipes, mesmo para equipes de pessoas com força de vontade? A resposta é um retumbante "Sim!", Há vantagens em ser um indivíduo pragmático, mas essas vantagens são multiplicadas muitas vezes se o indivíduo estiver trabalhando em uma equipe pragmática.

Uma equipe, em nossa opinião, é uma entidade pequena e principalmente estável. Cinqüenta pessoas não são um time, elas são uma horda. [75] Equipes onde os membros estão sendo constantemente puxados para outras tarefas e ninguém se conhece também uma equipe, eles são apenas estranhos compartilhando temporariamente uma parada de ônibus na chuva.

Uma equipe pragmática é pequena, com menos de 10 a 12 membros. Os membros vêm e raram raramente. Todo mundo conhece todos bem, confia um no outro e depende um do outro.

Dica 84 Mantenha equipes pequenas e estáveis



Nesta seção, analisaremos brevemente como as técnicas pragmáticas podem ser aplicadas às equipes como um todo. Essas notas são apenas um começo. Depois de obter um grupo de desenvolvedores pragmáticos trabalhando em um ambiente de capacidade, eles desenvolverão e refinam rapidamente sua própria dinâmica de equipe que funcionam para eles.

Vamos reformular algumas das seções anteriores em termos de equipes.





Sem janelas quebradas


Qualidade é um problema de equipe. O desenvolvedor mais diligente colocado em uma equipe que simplesmente não se importa achará difícil manter o entusiasmo necessário para corrigir problemas. O problema é ainda mais exacerbado se a equipe desencorajar ativamente o desenvolvedor a gastar tempo nessas correções.

As equipes como um todo não devem tolerar janelas quebradas - essas pequenas imperfeições que ninguém conserta. A equipe deve assumir a responsabilidade pela qualidade do produto, apoiando os desenvolvedores que entendem a filosofia sem janelas sem quebra que descrevemos no tópico 3, entropia de software e incentivando aqueles que ainda não a descobriram.

Algumas metodologias de equipe têm um "oficial de qualidade" - alguém a quem a equipe delega a responsabilidade pela qualidade da entrega. Isso é claramente ridículo: a qualidade pode vir apenas das contribuições individuais de todos os membros da equipe. A qualidade é incorporada, não aparafusada.





Sapos cozidos


Lembra -se do sapo apócrifo na panela da água, de volta ao tópico 4, sopa de pedra e sapos cozidos? Ele não percebe a mudança gradual em seu ambiente e acaba cozida. O mesmo pode acontecer com indivíduos que não estão vigilantes. Pode ser difícil ficar de olho no seu ambiente geral no calor do desenvolvimento do projeto.

É ainda mais fácil para as equipes como um todo ficarem fervidas. As pessoas assumem que alguém está lidando com um problema ou que o líder da equipe deve ter uma mudança que seu usuário está solicitando. Até as equipes mais bem-intencionadas podem estar alheios a mudanças significativas em seus projetos.

Lute com isso. Incentive todos a monitorar ativamente o ambiente para alterações. Fique acordado e ciente do aumento do escopo, diminuição das escalas de tempo, recursos adicionais, novos ambientes - qualquer coisa que não estava no entendimento original. Mantenha as métricas em novos requisitos. [76] A equipe não precisa rejeitar as alterações fora de controle - você simplesmente precisa estar ciente de que elas estão acontecendo. Caso contrário, estará você na água quente.





Programe seu portfólio de conhecimento


No tópico 6, seu portfólio de conhecimento, analisamos maneiras de investir em seu portfólio de conhecimento pessoal em seu próprio tempo. As equipes que desejam ter sucesso precisam considerar seus conhecimentos e investimentos em habilidades também.

Se sua equipe levar a sério a melhoria e a inovação, você precisa agendá -la. Tentar fazer as coisas "sempre que houver um momento livre" significa que elas nunca vão acontecer. Qualquer que seja o tipo de backlog ou a lista de tarefas ou o fluxo com quem você está trabalhando, não o reserve para desenvolvimento apenas de recursos. A equipe trabalha em mais do que apenas novos recursos. Alguns exemplos possíveis incluem:

Manutenção de sistemas antigos

Enquanto adoramos trabalhar no novo sistema brilhante, provavelmente há trabalhos de manutenção que precisam ser feitos no sistema antigo. Conhecemos equipes que tentam empurrar esse trabalho no canto. Se a equipe for acusada de realizar essas tarefas, faça -as - para reais.



Reflexão e refinamento do processo

A melhoria contínua só pode acontecer quando você reserva um tempo para olhar em volta, descobrir o que está funcionando e não e depois faz alterações (consulte o tópico 48, a essência da agilidade).
Muitas equipes estão tão ocupadas resgatando a água que não têm tempo para consertar o vazamento. Agende -o. Conserte.



Novos experimentos de tecnologia

Não adote nova tecnologia, estruturas ou bibliotecas apenas porque "todo mundo está fazendo isso" ou com base em algo que você viu em uma conferência ou leu online. Explique deliberadamente tecnologias candidatas com protótipos. Coloque as tarefas no cronograma para experimentar as coisas novas e analisar os resultados.



Aprendizagem e melhorias de habilidade

O aprendizado e as melhorias pessoais são um ótimo começo, mas muitas habilidades são mais eficazes quando espalhadas em toda a equipe. Planeje fazê-lo, seja o almoço informal de Brown-Bag ou sessões de treinamento mais formais.





Dica 85 agende -o para que isso aconteça





Comunicar presença de equipe


É óbvio que os desenvolvedores de uma equipe devem conversar um com o outro. Demos algumas sugestões para facilitar isso no tópico 7, comunicar! No entanto, é fácil esquecer que a própria equipe tem presença na organização. A equipe como entidade precisa se comunicar claramente com o resto do mundo.

Para forasteiros, as piores equipes de projeto são aquelas que parecem mal -humoradas e reticentes. Eles realizam reuniões sem estrutura, onde ninguém quer conversar. Seus e -mails e documentos do projeto estão uma bagunça: dois dois parecem iguais e cada um usa terminologia diferente.

Grandes equipes de projeto têm uma personalidade distinta. As pessoas esperam reuniões com elas, porque sabem que verão um desempenho bem preparado que faz com que todos se sintam bem. A documentação que eles produzem é nítida, precisa e consistente. A equipe fala com uma voz. [77] Eles podem até ter um senso de humor.

Existe um truque de marketing simples que ajuda as equipes a se comunicarem como um: gerar uma marca. Quando você inicia um projeto, invente um nome para ele, idealmente algo fora da parede. (No passado, nomeamos projetos em homenagem a coisas como papagaios assassinos que atacam ovelhas, ilusões de ótica, gerbils, personagens de desenhos animados e cidades míticas.) Passe 30 minutos com um logotipo do Zany e o usa. Use o nome da sua equipe liberalmente ao conversar com as pessoas. Parece bobo, mas dá à sua equipe uma identidade para construir, e o mundo algo memorável para se associar ao seu trabalho.





Não se repita


No tópico 9, seco - os males de duplicação, conversamos sobre as dificuldades de eliminar o trabalho duplicado entre membros de uma equipe. Essa duplicação leva a um esforço desperdiçado e pode resultar em um pesadelo de manutenção. Os sistemas "Stovepipe" ou "Siled" são comuns nessas equipes, com pouco compartilhamento e muita funcionalidade duplicada.

Uma boa comunicação é essencial para evitar esses problemas. E por "bom", queremos dizer instantâneo e sem atrito.

Você deve poder fazer uma pergunta aos membros da equipe e obter uma resposta instantânea mais ou menos. Se a equipe estiver co-localizada, isso pode ser tão simples quanto cutucar a cabeça pela parede do cubo ou pelo corredor. Para equipes remotas, você pode ter que confiar em um aplicativo de mensagens ou em outros meios eletrônicos.

Se você precisar esperar uma semana pela reunião da equipe para fazer sua pergunta ou compartilhar seu status, isso é um monte de atrito. [78] Sem fricção significa que é fácil e de baixa cerimônia fazer perguntas, compartilhar seu progresso, seus problemas, suas idéias e aprendizados e permanecer ciente do que seus colegas de equipe estão fazendo.

Mantenha a consciência para permanecer seca.





Balas de equipe de equipe


Uma equipe de projeto precisa realizar muitas tarefas diferentes em diferentes áreas do projeto, tocando em muitas tecnologias diferentes. Compreendendo os requisitos, projetando arquitetura, codificação para front -end e servidor, testes, todos precisam acontecer. Mas é um equívoco comum que essas atividades e tarefas possam acontecer separadamente, isoladamente. Eles não podem.

Algumas metodologias defendem todos os tipos de funções e títulos diferentes da equipe ou criam totalmente equipes especializadas separadas. Mas o problema com essa abordagem é que ela apresenta portões e transferências. Agora, em vez de um fluxo suave da equipe para a implantação, você tem portões artificiais onde o trabalho para. Transferências que precisam esperar para serem aceitas. Aprovações. Papelada. As pessoas magras chamam isso de lixo e se esforçam para eliminá -lo ativamente.

Todos esses papéis e atividades diferentes são realmente visões diferentes do mesmo problema, e separá -las artificialmente pode causar um monte de problemas. Por exemplo, é improvável que os programadores que sejam dois ou três níveis removidos dos usuários reais de seu código estejam cientes do contexto em que seu trabalho é usado. Eles não serão capazes de tomar decisões informadas.

Com
Tópico 12, Bullets Tracer, recomendamos o desenvolvimento de recursos individuais, ainda que pequenos e limitados inicialmente, que passam de ponta a ponta em todo o sistema. Isso significa que você precisa de todas as habilidades para fazer isso dentro da equipe: front -end, UI/UX, servidor, DBA, controle de qualidade, etc., todos confortáveis e acostumados a trabalhar uns com os outros. Com uma abordagem de bala do Tracer, você pode implementar bits muito pequenos de funcionalidade muito rapidamente e obter feedback imediato sobre o quão bem sua equipe se comunica e entrega. Isso cria um ambiente em que você pode fazer alterações e ajustar sua equipe e processar de maneira rápida e fácil.

Dica 86 Organize equipes totalmente funcionais



Crie equipes para que você possa criar código de ponta a ponta, de forma incremental e iterativa.





Automação


Uma ótima maneira de garantir consistência e precisão é automatizar tudo o que a equipe faz. Por que lutar com os padrões de formatação de código quando seu editor ou IDE pode fazer isso por você automaticamente? Por que os testes manuais quando a construção contínua pode executar testes automaticamente? Por que implantar à mão quando a automação pode fazer da mesma maneira todas as vezes, repetidamente e confiável?

A automação é um componente essencial de todas as equipes de projeto. Verifique se a equipe possui habilidades na construção de ferramentas para construir e implantar as ferramentas que automatizam o desenvolvimento do projeto e a implantação da produção.





Saiba quando parar de adicionar tinta


Lembre -se de que as equipes são compostas por indivíduos. Dê a cada membro a capacidade de brilhar à sua maneira. Dê a eles estrutura suficiente para apoiá -los e garantir que o projeto agregue valor. Então, como o pintor no tópico 5, o software bom o suficiente, resista à tentação de adicionar mais tinta.





Seções relacionadas incluem


Tópico 2, o gato comeu meu código fonte

Tópico 7, comunique!

Tópico 12, balas de traçador

Tópico 19, controle de versão

Tópico 50, cocos não o cortam

Tópico 51, kit iniciante pragmático





Desafios


Procure equipes de sucesso fora da área de desenvolvimento de software. O que os torna bem -sucedidos? Eles usam algum dos processos discutidos nesta seção?



Da próxima vez que você iniciar um projeto, tente convencer as pessoas a marcá -lo. Dê tempo à sua organização para se acostumar com a ideia e faça uma auditoria rápida para ver a diferença que ela fez, tanto dentro da equipe quanto externamente.



Você provavelmente já recebeu problemas como “Se levar 4 trabalhadores 6 horas para cavar uma vala, quanto tempo levaria 8 trabalhadores?” Na vida real, no entanto, quais fatores afetam a resposta se os trabalhadores estavam escrevendo código? Em quantos cenários o tempo é realmente reduzido?



Leia o Mês Mítico Mês [Bro96] de Frederick Brooks. Para crédito extra, compre duas cópias para que você possa lê -lo duas vezes mais rápido.





Tópico 50

Cocos não cortam




Os ilhéus nativos nunca haviam visto um avião antes, ou conheceu pessoas como esses estranhos. Em troca do uso de suas terras, os estranhos forneceram pássaros mecânicos que entraram e saíram o dia inteiro em uma "pista", trazendo uma riqueza material incrível para a casa da ilha. Os estranhos mencionaram algo sobre guerra e luta. Um dia, acabou e todos saíram, levando suas estranhas riquezas com eles.

Os ilhéus estavam desesperados para restaurar suas boas fortunas e reconstruíram um fac-símile do aeroporto, torre de controle e equipamentos usando materiais locais: trepadeiras, conchas de coco, folhas de palmeiras e tal. Mas, por algum motivo, mesmo que eles tivessem tudo no lugar, os aviões não chegaram. Eles haviam imitada o formulário, mas não o conteúdo. Os antropólogos chamam isso de culto de carga.

Com muita frequência, somos os ilhéus.

É fácil e tentador cair na armadilha do culto a carga: investindo e construindo os artefatos facilmente visíveis, você espera atrair a magia subjacente e funcional. Mas, como nos cultos originais de carga da Melanésia, [79] Um aeroporto falso feito de conchas de coco não substitui a coisa real.

Por exemplo, vimos pessoalmente equipes que afirmam estar usando o Scrum. Mas, após um exame mais detalhado, eles estavam fazendo uma reunião diária uma vez por semana, com iterações de quatro semanas que muitas vezes se transformavam em iterações de seis ou oito semanas. Eles sentiram que tudo bem porque estavam usando uma popular ferramenta de agendamento "ágil". Eles estavam apenas investindo nos artefatos superficiais - e mesmo assim, muitas vezes apenas em nome, como se "se levantar" ou "iteração" fossem algum tipo de encantamento para os supersticiosos. Sem surpresa, eles também falharam em atrair a verdadeira magia.





O contexto é importante


Você ou sua equipe caíram nesta armadilha? Perguntar
você mesmo, por que você está usando esse método de desenvolvimento específico? Ou essa estrutura? Ou essa técnica de teste? Na verdade, é adequado para o trabalho em questão? Funciona bem para você? Ou foi adotado apenas porque estava sendo usado pela mais recente história de sucesso alimentada pela Internet?

Há uma tendência atual de adotar as políticas e processos de empresas de sucesso, como Spotify, Netflix, Stripe, Gitlab e outras. Cada um tem sua própria abordagem única sobre o desenvolvimento e o gerenciamento de software. Mas considere o contexto: você está no mesmo mercado, com as mesmas restrições e oportunidades, experiência semelhante e tamanho da organização, gerenciamento semelhante e cultura semelhante? Base de usuário e requisitos semelhantes?

Não caia nisso. Artefatos específicos, estruturas superficiais, políticas, processos e métodos não são suficientes.

Dica 87 Faça o que funciona, não o que está na moda



Como você sabe "o que funciona"? Você confia nisso mais fundamental das técnicas pragmáticas:

Experimente.

Piloto a ideia com uma pequena equipe ou conjunto de equipes. Mantenha os bons pedaços que parecem funcionar bem e descarte qualquer outra coisa como desperdício ou sobrecarga. Ninguém rebaixará sua organização porque opera de maneira diferente do Spotify ou da Netflix, porque nem eles seguiram seus processos atuais enquanto estavam crescendo. E daqui a anos, à medida que essas empresas amadurecem e giram e continuam a prosperar, elas farão algo diferente mais uma vez.

Esse é o segredo real para o sucesso deles.





Um tamanho não se encaixa bem


O objetivo de uma metodologia de desenvolvimento de software é ajudar as pessoas a trabalharem juntas. Como discutimos no tópico 48, a essência da agilidade, não há um plano único que você possa seguir quando desenvolver software, especialmente um plano que alguém criou em outra empresa.

Muitos programas de certificação são realmente piores do que isso: eles são baseados no aluno poder memorizar e seguir as regras. Mas não é isso que você quer. Você precisa da capacidade de ver além das regras existentes e explorar as possibilidades de vantagem. Essa é uma mentalidade muito diferente de "Mas Scrum/Lean/Kanban/XP/Agile faz dessa maneira ..." e assim por diante.

Em vez disso, você deseja pegar as melhores peças de qualquer metodologia específica e adaptá -las para uso. Nenhum tamanho único se encaixa em todos, e os métodos atuais estão longe de serem completos; portanto, você precisará analisar mais do que apenas um método popular.

Por exemplo, o Scrum define algumas práticas de gerenciamento de projetos, mas o Scrum por si só não fornece orientação suficiente no nível técnico para as equipes ou no nível de portfólio/governança para a liderança. Então, por onde você começa?


Seja como eles!

		Freqüentemente ouvimos líderes de desenvolvimento de software dizerem à sua equipe: "Deveríamos operar como a Netflix" (ou uma dessas outras empresas líderes). Claro que você poderia fazer isso.

		Primeiro, pegue algumas centenas de milhares de servidores e dezenas de milhões de usuários ...





O objetivo real


O objetivo, é claro, não é "fazer scrum", "fazer ágil", "fazer magro" ou o que você tem. O objetivo é estar em posição de fornecer software de trabalho que ofereça aos usuários algum novo recurso a qualquer momento. Não semanas, meses ou anos daqui a anos, mas agora. Para muitas equipes e organizações, a entrega contínua parece uma meta elevada e inatingível, especialmente se você estiver com um processo que restringe a entrega a meses ou até semanas. Mas, como em qualquer objetivo, a chave é continuar buscando na direção certa.



Se você está entregando em anos, tente reduzir o ciclo para meses. A partir dos meses, reduza -o para semanas. De um sprint de quatro semanas, tente dois. De um sprint de duas semanas, tente um. Então diariamente. Então, finalmente, sob demanda. Observe que ser capaz de entregar sob demanda não significa que você seja forçado a entregar cada minuto de cada dia. Você entrega quando os usuários precisam, quando faz sentido nos negócios fazê -lo.

Dica 88 entrega quando os usuários precisam



Para mudar para esse estilo de desenvolvimento contínuo, você precisa de uma infraestrutura sólida, que discutimos no próximo tópico, tópico 51, Pragmatic Starter Kit. Você faz o desenvolvimento no tronco principal do seu sistema de controle de versão, não em ramificações, e usa técnicas como interruptores de recursos para lançar os recursos de teste para os usuários seletivamente.

Depois que sua infraestrutura estiver em ordem, você precisa decidir como organizar o trabalho. Os iniciantes podem querer começar com o Scrum para gerenciamento de projetos, além das práticas técnicas da Extreme Programming (XP). Equipes mais disciplinadas e experientes podem procurar técnicas de Kanban e Lean, tanto para a equipe quanto talvez
para questões maiores de governança.

Mas não aceite nossa palavra, investigue e tente essas abordagens para si mesmo. Tenha cuidado, porém, ao exagerar. Investir excessivamente em qualquer metodologia específica pode deixá -lo cego para alternativas. Você se acostuma. Logo fica difícil ver de outra maneira. Você ficou calcificado e agora não pode mais se adaptar rapidamente.

Pode muito bem estar usando cocos.





Seções relacionadas incluem


Tópico 12, balas de traçador

Tópico 27, não supere seus faróis

Tópico 48, a essência da agilidade

Tópico 49, equipes pragmáticas

Tópico 51, kit iniciante pragmático





Tópico 51

Kit iniciante pragmático




A civilização avança ao estender o número de importantes

Operações que podemos executar sem pensar.



Alfred North Whitehead



Quando os carros eram uma novidade, as instruções para iniciar um Ford Model-T tinham mais de duas páginas de comprimento. Com os carros modernos, você apenas pressiona um botão - o procedimento inicial é automático e infalível. Uma pessoa que segue uma lista de instruções pode inundar o motor, mas o iniciador automático não.

Embora o desenvolvimento de software ainda seja um setor no estágio do Modelo T, não podemos nos dar ao luxo de passar por duas páginas de instruções repetidamente para alguma operação comum. Seja o procedimento de construção e liberação, teste, papelada do projeto ou qualquer outra tarefa recorrente no projeto, ele deve ser automático e repetível em qualquer máquina capaz.

Além disso, queremos garantir consistência e repetibilidade no projeto. Os procedimentos manuais deixam a consistência à acaso; A repetibilidade não é garantida, especialmente se aspectos do procedimento estiverem abertos à interpretação de pessoas diferentes.

Depois de escrevermos a primeira edição do programador pragmático, queríamos criar mais livros para ajudar as equipes a desenvolver software. Nós achamos que deveríamos começar do início: quais são os elementos mais básicos e mais importantes que toda equipe precisa, independentemente da metodologia, idioma ou pilha de tecnologia. E assim nasceu a idéia do kit iniciante pragmático, cobrindo esses três tópicos críticos e inter -relacionados:

Controle de versão

Teste de regressão

Automação completa



Estas são as três pernas que suportam todos os projetos. Aqui está como.





Dirija com controle de versão


Como dissemos no tópico 19, controle de versão, você deseja manter tudo o que é necessário para criar seu projeto no controle da versão. Essa idéia se torna ainda mais importante no contexto do próprio projeto.

Primeiro, permite que as máquinas de construção sejam efêmeras. Em vez de uma máquina sagrada e rangente no canto do escritório que todos têm medo de tocar, [80] máquinas de construção e/ou clusters são criados sob demanda como instâncias à vista na nuvem. A configuração de implantação também está sob controle de versão, portanto, a liberação da produção pode ser tratada automaticamente.

E essa é a parte importante: no nível do projeto, o controle de versão impulsiona o processo de construção e liberação.

Dica 89 Use o controle da versão para acionar construções, testes e lançamentos



Isto é, construir, testar e implantação são acionados por comissões ou empurrões para o controle de versão e incorporados em um contêiner na nuvem. A liberação para estadiamento ou produção é especificada usando uma tag no seu sistema de controle de versão. Os lançamentos se tornam uma parte muito mais de baixa cerimônia da vida cotidiana-entrega contínua, não vinculada a qualquer máquina de construção ou máquina do desenvolvedor.





Testes cruéis e contínuos


Muitos desenvolvedores testam suavemente, subconscientemente sabendo onde o código quebrará e evitará os pontos fracos. Programadores pragmáticos são diferentes. Somos motivados a encontrar nossos bugs agora, por isso não precisamos suportar a vergonha de os outros encontrarem nossos bugs mais tarde.

Encontrar insetos é um pouco como pescar com uma rede. Utilizamos redes finas e pequenas (testes de unidade) para pegar os peixinhos e redes grandes e grossas (testes de integração) para pegar os tubarões assassinos. Às vezes, os peixes conseguem escapar, por isso corrigimos os orifícios que encontramos, na esperança de pegar mais e mais defeitos escorregadios que estão nadando em nossa piscina de projetos.

Dica 90 Teste cedo, teste com frequência, teste automaticamente



Queremos começar a testar assim que tivermos código. Esses pequenos peixinhos têm o hábito desagradável de se tornarem tubarões gigantes e com comer muito rápido, e pegar um tubarão é um pouco mais difícil. Então, escrevemos testes de unidade. Muitos testes de unidade.

De fato, um bom projeto pode muito bem ter mais código de teste do que o código de produção. O tempo necessário para produzir esse código de teste vale o esforço. Acaba sendo muito mais barato a longo prazo, e você realmente tem uma chance de
produzindo um produto com quase zero defeitos.

Além disso, saber que você passou no teste oferece um alto grau de confiança de que um pedaço de código é "feito".

Dica 91 A codificação não acabou até que todos os testes sejam executados



A compilação automática executa todos os testes disponíveis. É importante buscar "testar de verdade", em outras palavras, o ambiente de teste deve corresponder de perto ao ambiente de produção. Quaisquer lacunas são onde os insetos se reproduzem.

A construção pode cobrir vários tipos principais de teste de software: teste de unidade; teste de integração; validação e verificação; e teste de desempenho.

Esta lista não está de forma alguma completa e alguns projetos especializados também exigirão vários outros tipos de testes. Mas isso nos dá um bom ponto de partida.





Teste de unidade


Um teste de unidade é um código que exerce um módulo. Cobrimos isso no tópico 41, teste para codificar. O teste de unidade é a base de todas as outras formas de teste que discutiremos nesta seção. Se as peças não funcionarem sozinhas, provavelmente não funcionarão bem juntas. Todos os módulos que você está usando devem passar seus próprios testes de unidade antes de poder prosseguir.

Depois que todos os módulos pertinentes passarem seus testes individuais, você estará pronto para o próximo estágio. Você precisa testar como todos os módulos usam e interagem entre si em todo o sistema.





Teste de integração


Os testes de integração mostram que os principais subsistemas que compõem o projeto funcionam e jogam bem entre si. Com bons contratos em vigor e bem testados, quaisquer problemas de integração podem ser detectados facilmente. Caso contrário, a integração se torna um terreno fértil para insetos. De fato, geralmente é a maior fonte de bugs do sistema.

O teste de integração é realmente apenas uma extensão dos testes de unidade que descrevemos - você está apenas testando como os subsistemas inteiros honram seus contratos.





Validação e verificação


Assim que você tiver uma interface ou protótipo de usuário executável, você precisa responder a uma pergunta importante: os usuários lhe disseram o que queriam, mas é o que eles precisam?

Atende aos requisitos funcionais do sistema? Isso também precisa ser testado. Um sistema sem bug que responde à pergunta errada não é muito útil. Esteja consciente dos padrões de acesso ao usuário final e como eles diferem dos dados do teste do desenvolvedor (por exemplo, consulte a história sobre pinceladas aqui).





Teste de desempenho


O desempenho ou o teste de estresse também podem ser aspectos importantes do projeto.

Pergunte a si mesmo se o software atende aos requisitos de desempenho em condições do mundo real-com o número esperado de usuários, conexões ou transações por segundo. É escalável?

Para alguns aplicativos, você pode precisar de hardware ou software de teste especializado para simular a carga realisticamente.





Testando os testes


Como não podemos escrever um software perfeito, também não podemos escrever um software de teste perfeito. Precisamos testar os testes.

Pense no nosso conjunto de suítes de teste como um sistema de segurança elaborado, projetado para soar o alarme quando um bug aparecer. Qual a melhor forma de testar um sistema de segurança do que tentar entrar?

Depois de escrever um teste para detectar um bug específico, faça com que o bug deliberadamente e verifique se o teste reclama. Isso garante que o teste pegue o bug se isso acontecer de verdade.

Dica 92 Use sabotadores para testar seus testes



Se você é realmente sério sobre o teste, faça uma filial separada da árvore de origem, introduza bugs de propósito e verifique se os testes os capturarão. Em um nível mais alto, você pode usar algo como o Chaos Monkey da Netflix [81] para interromper os serviços (ou seja, "matar") e testar a resiliência do seu aplicativo.

Ao escrever testes, verifique se os alarmes soam quando deveriam.





Testando bem


Depois de confiante de que seus testes estão corretos e estão encontrando bugs que você cria, como você sabe se você testou a base de código com rapidez suficiente?

A resposta curta é "você não", e você nunca o fará. Você pode tentar experimentar ferramentas de análise de cobertura que assistem ao seu código durante o teste e acompanham quais linhas de código foram executadas e quais não. Essas ferramentas ajudam a você uma sensação geral de quão abrangente é o seu teste, mas não esperam ver 100% de cobertura. [82]

Mesmo se você atingir todas as linhas de código, essa não é a imagem toda. O importante é o número de estados que seu programa pode ter. Os estados não são equivalentes às linhas de código. Por exemplo, suponha que você tenha uma função que leve dois números inteiros, cada um dos quais pode ser um número de 0 a
999:

Teste int (int a, int b) {

Retornar a / (a + b);

}



Em teoria, essa função de três linhas possui 1.000.000 de estados lógicos, 999.999 dos quais funcionarão corretamente e um que não (quando A + B for igual a zero). Simplesmente saber que você executou essa linha de código não lhe diz isso - você precisaria identificar todos os estados possíveis do programa. Infelizmente, em geral, esse é um problema muito difícil. Hard como em, "o sol será um nódulo frio e difícil antes que você possa resolvê -lo".

Dica 93 Cobertura de estado de teste, não cobertura de código





Teste baseado em propriedades


Uma ótima maneira de explorar como seu código lida com estados inesperados é ter um computador gerar esses estados.

Use técnicas de teste baseadas em propriedades para gerar dados de teste de acordo com os contratos e invariantes do código em teste. Cobrimos esse tópico em detalhes no tópico 42, testes baseados em propriedades.





Apertando a rede


Por fim, gostaríamos de revelar o conceito mais importante nos testes. É óbvio, e praticamente todo livro diz para fazê -lo dessa maneira. Mas, por algum motivo, a maioria dos projetos ainda não.

Se um bug deslizar pela rede dos testes existentes, você precisará adicionar um novo teste para prendê -lo na próxima vez.

Dica 94 Encontre bugs uma vez



Uma vez que um testador humano encontra um bug, deve ser a última vez que um testador humano encontra esse bug. Os testes automatizados devem ser modificados para verificar esse bug específico a partir de então, sempre, sem exceções, por mais trivial e não importa o quanto o desenvolvedor reclame e diga: "Ah, isso nunca mais acontecerá".

Porque isso vai acontecer novamente. E não temos tempo para perseguir os bugs que os testes automatizados poderiam ter encontrado para nós. Temos que gastar nosso tempo escrevendo um novo código - e novos bugs.





Automação completa


Como dissemos no início desta seção, o desenvolvimento moderno depende de procedimentos automáticos com roteiro. Se você usa algo tão simples quanto scripts de shell com RSYNC e SSH, ou soluções completas, como Ansible, Puppet, Chef ou Salt, simplesmente não confie em nenhuma intervenção manual.

Era uma vez, estávamos em um site de clientes onde todos os desenvolvedores estavam usando o mesmo IDE. O administrador do sistema deu a cada desenvolvedor um conjunto de instruções sobre a instalação de pacotes complementares no IDE. Essas instruções preencheram muitas páginas-Páginas cheias de clique aqui, rolar lá, arrastar isso, clique duas vezes e o fazem novamente.

Não é de surpreender que a máquina de todo desenvolvedor tenha sido carregada de maneira um pouco diferente. Diferenças sutis no comportamento do aplicativo ocorreram quando diferentes desenvolvedores executaram o mesmo código. Os insetos apareceriam em uma máquina, mas não em outros. Rastrear as diferenças de versão de qualquer componente geralmente revelaram uma surpresa.

Dica 95 Não use procedimentos manuais



As pessoas simplesmente não são tão repetíveis quanto os computadores. Nem devemos esperar que eles sejam. Um script ou programa de shell executará as mesmas instruções, na mesma ordem, várias vezes. Ele está sob o controle da versão em si, para que você possa examinar as alterações nos procedimentos de construção/liberação ao longo do tempo também ("mas costumava funcionar ...").

Tudo depende da automação. Você não pode criar o projeto em um servidor em nuvem anônimo, a menos que a compilação seja totalmente automática. Você não pode implantar automaticamente se houver etapas manuais envolvidas. E depois de apresentar etapas manuais ("apenas para esta parte ..."), você quebrou uma janela muito grande. [83]

Com essas três pernas de controle de versão, testes implacáveis e automação completa, seu projeto terá a base da empresa necessária para que você possa se concentrar na parte difícil: deliciando os usuários.





Seções relacionadas incluem


Tópico 11, reversibilidade

Tópico 12, balas de traçador

Tópico 17, jogos de shell

Tópico 19, controle de versão

Tópico 41, teste para codificar

Tópico 49, equipes pragmáticas

Tópico 50, cocos não o cortam





Desafios


Suas compilações noturnas ou contínuas são automáticas, mas a implantação na produção não é? Por que? O que há de especial nesse servidor?



Você pode testar automaticamente seu projeto completamente? Muitas equipes são forçadas a responder "não". Por que? É muito difícil definir os resultados aceitáveis? Isso não dificultará provar aos patrocinadores que o projeto é "feito"?



É muito difícil testar a lógica do aplicativo independente da GUI? O que isso diz sobre a GUI? Sobre acoplamento?





Tópico 52

Deleite seus usuários




	Quando você encanta pessoas, seu objetivo não é ganhar dinheiro

a partir deles ou para que eles façam o que você quiser, mas

para preenchê -los com grande prazer.



Guy Kawasaki



Nosso objetivo como desenvolvedores é
delicia os usuários. É por isso que estamos aqui. Não para explorá -los por seus dados, ou contar seus olhos ou esvaziar suas carteiras. Metas nefastas à parte, até mesmo entregar o software de trabalho em tempo hábil. Isso por si só não os encanta.

Seus usuários não são particularmente motivados pelo código. Em vez disso, eles têm um problema de negócios que precisa resolver no contexto de seus objetivos e orçamento. A crença deles é que, ao trabalhar com sua equipe, eles poderão fazer isso.

Suas expectativas não estão relacionadas ao software. Eles nem estão implícitos em nenhuma especificação que lhe dêem (porque essa especificação ficará incompleta até que sua equipe tenha itera com elas várias vezes).

Como você descobre as expectativas deles, então? Faça uma pergunta simples:

Como você saberá que todos nós obtivemos sucesso um mês (ou um ano ou qualquer outra coisa) depois que este projeto for feito?



Você pode muito bem se surpreender com a resposta. Um projeto para melhorar as recomendações do produto pode realmente ser julgado em termos de retenção de clientes; Um projeto para consolidar dois bancos de dados pode ser julgado em termos de qualidade dos dados, ou pode ser sobre economia de custos. Mas são essas expectativas de valor comercial que realmente contam - não apenas o próprio projeto de software. O software é apenas um meio para esses fins.

E agora que você apareceu algumas das expectativas subjacentes de valor por trás do projeto, você pode começar a pensar em como pode oferecer contra eles:

Verifique se todos da equipe estão totalmente claros sobre essas expectativas.



Ao tomar decisões, pense em qual caminho a frente se aproxima dessas expectativas.



Analise criticamente os requisitos do usuário à luz das expectativas. Em muitos projetos, descobrimos que o "requisito" declarado era de fato apenas um palpite no que poderia ser feito pela tecnologia: na verdade era um plano de implementação amador vestido como um documento de requisitos. Não tenha medo de fazer sugestões que alterem o requisito se você puder demonstrar que eles irão aproximar o projeto do objetivo.



Continue a pensar nessas expectativas à medida que avança no projeto.





Descobrimos que, à medida que nosso conhecimento do domínio aumenta, somos mais capazes de fazer sugestões sobre outras coisas que podem ser feitas para resolver os problemas de negócios subjacentes. Acreditamos fortemente que os desenvolvedores, que são expostos a muitos aspectos diferentes de uma organização, geralmente podem ver maneiras de tecer diferentes partes dos negócios juntos que nem sempre são óbvios para os departamentos individuais.

Dica 96 Usuários Deliciar, não entregue apenas código



Se você deseja encantar seu cliente, forje um relacionamento com eles, onde você pode ajudar a resolver seus problemas ativamente. Embora seu título possa ser uma variação do "desenvolvedor de software" ou "engenheiro de software", na verdade, deve ser "solucionador de problemas". É isso que fazemos, e essa é a essência de um programador pragmático.

Nós resolvemos problemas.





Seções relacionadas incluem


Tópico 12, balas de traçador

Tópico 13, protótipos e notas post-it

Tópico 45, o poço de requisitos





Tópico 53

Orgulho e preconceito




Você nos encantou o suficiente.



Jane Austen, Orgulho e Preconceito



Programadores pragmáticos não se esquivam da responsabilidade. Em vez disso, nos alegramos em aceitar desafios e em tornar nossa experiência bem conhecida. Se somos responsáveis por um design ou um código de código, fazemos um trabalho de que podemos nos orgulhar.

Dica 97 Assine seu trabalho



Os artesãos de uma idade anterior tinham orgulho de assinar seu trabalho. Você deveria estar também.

As equipes de projeto ainda são compostas por pessoas, no entanto, e essa regra pode causar problemas. Em alguns projetos, a idéia de propriedade do código pode causar problemas de cooperação. As pessoas podem se tornar territoriais ou não quererem trabalhar em elementos comuns da fundação. O projeto pode acabar como um monte de pequenos feudos insulares. Você se torna preconceituoso a favor do seu código e contra seus colegas de trabalho.

Não é isso que queremos. Você não deve defender com ciúmes seu código contra os intromantescos; Da mesma forma, você deve tratar o código de outras pessoas com respeito. A regra de ouro ("Faça aos outros que você os fizesse fazer com você") e uma base de respeito mútuo entre os desenvolvedores é fundamental para fazer com que essa dica funcione.

O anonimato, especialmente em grandes projetos, pode fornecer um terreno fértil para desleixo, erros, preguiça e código ruim. Torna -se muito fácil se ver como apenas uma engrenagem na roda, produzindo desculpas esfarrapadas em reportagens de status sem fim em vez de um bom código.

Embora o código deve ser de propriedade, não precisa ser
de propriedade de um indivíduo. De fato, a extrema programação de Kent Beck [84] recomenda a propriedade comunitária do código (mas isso também requer práticas adicionais, como programação de pares, para se proteger contra os perigos do anonimato).

Queremos ver o orgulho da propriedade. "Eu escrevi isso e estou atrás do meu trabalho." Sua assinatura deve ser reconhecida como um indicador de qualidade. As pessoas devem ver seu nome em um pedaço de código e esperar que seja sólido, bem escrito, testado e documentado. Um trabalho realmente profissional. Escrito por um profissional.

Um programador pragmático.



Obrigado.





Notas de rodapé


[75]

À medida que o tamanho da equipe cresce, os caminhos de comunicação crescem à taxa de, onde está o número de membros da equipe. Em equipes maiores, a comunicação começa a quebrar e se torna ineficaz.



[76]

Um gráfico de queimadura é melhor para isso do que o gráfico de queimaduras mais usuais. Com um gráfico de queimaduras, você pode ver claramente como os recursos adicionais movem os posts.



[77]

A equipe fala com uma voz - Externalmente. Internamente, incentivamos fortemente o debate animado e robusto. Bons desenvolvedores tendem a ser apaixonados por seu trabalho.



[78]

Andy conheceu equipes que conduzem seus stand -ups diários de scrum às sextas -feiras.



[79]

Veja https://en.wikipedia.org/wiki/Cargo_Cult.



[80]

Vimos isso em primeira mão mais vezes do que você imagina.



[81]

https://netflix.github.io/chaosmonkey



[82]

Para um estudo interessante da correlação entre a cobertura e os defeitos do teste, consulte a cobertura de teste de unidade mítica [ADSS18].



[83]

Lembre -se sempre do tópico 3, entropia de software. Sempre.



[84]

http://www.extremeprogramming.org





Copyright © 2020 Pearson Education, Inc.

A longo prazo, moldamos nossas vidas e nos moldamos. O processo nunca termina até morrermos. E as escolhas que fazemos são, em última análise, nossa própria responsabilidade.



Eleanor Roosevelt





Capítulo 10



PostFace




Nos vinte anos que antecederam a primeira edição, fizemos parte da evolução do computador, desde uma curiosidade periférica a um imperativo moderno para as empresas. Nos vinte anos desde então, o software cresceu além das meras máquinas de negócios e realmente assumiu o mundo. Mas o que isso realmente significa para nós?

No Mythical Man-Month: Essays on Software Engineering [BRO96], Fred Brooks disse: "O programador, como o poeta, funciona apenas ligeiramente removido da pura realização do pensamento. Ele constrói seus castelos no ar, do ar, criando por esforço da imaginação". Começamos com uma página em branco e podemos criar praticamente qualquer coisa que possamos imaginar. E as coisas que criamos podem mudar o mundo.

Desde o Twitter, ajudando as pessoas a planejar revoluções, até o processador em seu carro trabalhando para impedir que você derramie o smartphone, o que significa que não precisamos mais lembrar de detalhes diários irritantes, nossos programas estão por toda parte. Nossa imaginação está em toda parte.

Nós, desenvolvedores, somos incrivelmente privilegiados. Estamos realmente construindo o futuro. É uma quantidade extraordinária de poder. E com esse poder vem uma responsabilidade extraordinária.

Com que frequência paramos para pensar sobre isso? Com que frequência discutimos, tanto entre nós quanto com um público mais geral, o que isso significa?

Os dispositivos incorporados usam uma ordem de magnitude mais computadores do que aqueles usados em laptops, desktops e data centers. Esses computadores incorporados geralmente controlam sistemas críticos da vida, de usinas de energia a carros e equipamentos médicos. Mesmo um simples sistema central de controle de aquecimento ou eletrodomésticos pode matar alguém se for mal projetado ou implementado. Quando você se desenvolve para esses dispositivos, você assume uma responsabilidade impressionante.

Muitos sistemas não incorporados também podem causar grandes e grandes danos. A mídia social pode promover a revolução pacífica ou o ódio feio. O big data pode facilitar as compras e pode destruir qualquer vestígio de privacidade que você possa pensar que tem. Os sistemas bancários tomam decisões de empréstimos que mudam a vida das pessoas. E praticamente qualquer sistema pode ser usado para bisbilhotar seus usuários.

Vimos dicas das possibilidades de um futuro utópico e exemplos de consequências não intencionais, levando a distopias de pesadelo. A diferença entre os dois resultados pode ser mais sutil do que você pensa. E está tudo em suas mãos.





A bússola moral


O preço desse poder inesperado é a vigilância. Nossas ações afetam diretamente as pessoas. Não é mais o programa de hobby na CPU de 8 bits na garagem, o processo de negócios em lote isolado no mainframe no data center, ou mesmo apenas no PC da área de trabalho; Nosso software tece o próprio tecido da vida moderna diária.

Temos o dever de perguntar
nós mesmos duas perguntas sobre cada pedaço de código que entregamos:

Eu protegi o usuário?



Eu mesmo usaria isso?





Primeiro, você deve perguntar: “Eu fiz o meu melhor para proteger os usuários deste código contra danos?” Fiz disposições para aplicar patches de segurança em andamento a esse simples monitor de bebê? Eu assegurei que, no entanto, o termostato de aquecimento central automático falhe que o cliente ainda terá controle manual? Estou armazenando apenas os dados de que preciso e criptografando algo pessoal?

Ninguém é perfeito; Todo mundo sente falta das coisas de vez em quando. Mas se você não pode dizer com sinceridade que tentou listar todas as consequências e se certificou de proteger os usuários deles, então assume alguma responsabilidade quando as coisas dão mal.

Dica 98 primeiro, não faça mal



Segundo, há um julgamento relacionado à regra de ouro: ficaria feliz em ser um usuário deste software? Eu quero meus detalhes compartilhados? Eu quero que meus movimentos sejam dados aos pontos de venda? Ficaria feliz por ser conduzido por este veículo autônomo? Estou confortável fazendo isso?

Algumas idéias inventivas começam a contornar os limites do comportamento ético e, se você estiver envolvido nesse projeto, é tão responsável quanto os patrocinadores. Não importa quantos graus de separação você possa racionalizar, uma regra permanece verdadeira:

Dica 99 Não ative scumbags





Imagine o futuro que você deseja


Você decide. É a sua imaginação, suas esperanças, suas preocupações que fornecem a pura reprodução de pensamento que constrói os próximos vinte anos e além.

Você está construindo o futuro, para si e para seus descendentes. Seu dever é torná -lo um futuro que todos queremos habitar. Reconheça quando você está fazendo algo contra esse ideal e tem a coragem de dizer "não!" Veja o futuro que poderíamos ter e tenha a coragem de criá -lo. Construa castelos no ar todos os dias.

Todos nós temos uma vida incrível.

Dica 100 É a sua vida.

Compartilhe. Comemore. Construa.

E divirta -se!





Copyright © 2020 Pearson Education, Inc.





Apêndice 1



Bibliografia




[ADSS18]

Vard Antinyan, Jesper Derehag, Anna Sandberg e Miroslaw Staron. Cobertura de teste de unidade mítica. Software IEEE. 35: 73-79, 2018.

[E 10]

Jackie Andrade. O que Doodling faz? Psicologia cognitiva aplicada. 24 (1): 100-106, 2010, janeiro.

[ARM07]

Joe Armstrong. Programação Erlang: Software para um mundo simultâneo. The Pragmatic Bookshelf, Raleigh, NC, 2007.

[BR89]

Albert J. Bernstein e Sydney Craft Rozen. Brains de dinossauros: lidando com todas aquelas pessoas impossíveis no trabalho. John Wiley & Sons, Nova York, NY, 1989.

[Bro96]

Frederick P. Brooks, Jr. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley, Reading, MA, aniversário, 1996.

[CN91]

Brad J. Cox e Andrew J. Novobilski. Programação orientada a objetos: uma abordagem evolutiva. Addison-Wesley, Reading, MA, segundo, 1991.

[CON68]

Melvin E. Conway. Como os comitês inventam? Datamação. 14 (5): 28-31, 1968, abril.

[DE 98]

Gavin de Becker. O dom do medo: e outros sinais de sobrevivência que nos protegem da violência. Dell Publishing, Nova York, 1998.

[DL13]

Tom Demacro e Tim Lister. Peopleware: projetos e equipes produtivas. Addison-Wesley, Boston, MA, terceiro, 2013.

[Fow00]

Martin Fowler. UML destilado: um breve guia para a linguagem de modelagem de objetos padrão. Addison-Wesley, Boston, MA, segundo, 2000.

[Fow04]

Martin Fowler. UML destilado: um breve guia para a linguagem de modelagem de objetos padrão. Addison-Wesley, Boston, MA, terceiro, 2004.

[Fow19]

Martin Fowler. Refatoração: melhorando o design do código existente. Addison-Wesley, Boston, MA, segundo, 2019.

[Ghjv95]

Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides. Padrões de design: elementos do software reutilizável orientado a objetos. Addison-Wesley, Reading, MA, 1995.

[Hol92]

Michael Holt. Puzzles e jogos de matemática. Dorset House, Nova York, NY, 1992.

[HUN08]

Andy Hunt. Pensamento Pragmático e Aprendizagem: Refator seu Wetware. The Pragmatic Bookshelf, Raleigh, NC, 2008.

[JOI94]

T.E. Marceneiro. Depressão contagiosa: existência, especificidade aos sintomas deprimidos e o papel da busca por segurança. Jornal de Personalidade e Psicologia Social. 67 (2): 287--296, 1994, agosto.

[KNU11]

Donald E. Knuth. A arte da programação de computadores, volume 4A: algoritmos combinatórios, parte 1. Addison-Wesley, Boston, MA, 2011.

[KNU98]

Donald E. Knuth. A arte da programação de computadores, volume 1: algoritmos fundamentais. Addison-Wesley, Reading, MA, terceiro, 1998.

[KNU98A]

Donald E. Knuth. The Art of Computer Programming, Volume 2: Seminumérico
Algoritmos. Addison-Wesley, Reading, MA, terceiro, 1998.

[KNU98B]

Donald E. Knuth. A arte da programação de computadores, volume 3: classificação e pesquisa. Addison-Wesley, Reading, MA, Segundo, 1998.

[KP99]

Brian W. Kernighan e Rob Pike. A prática de programação. Addison-Wesley, Reading, MA, 1999.

[Mey97]

Bertrand Meyer. Construção de software orientada a objetos. Prentice Hall, Upper Saddle River, NJ, segundo, 1997.

[Mul18]

Jerry Z. Muller. A tirania das métricas. Princeton University Press, Princeton NJ, 2018.

[SF13]

Robert Sedgewick e Phillipe Flajolet. Uma introdução à análise de algoritmos. Addison-Wesley, Boston, MA, segundo, 2013.

[STR35]

James Ridley Stroop. Estudos de interferência em reações verbais em série. Jornal de Psicologia Experimental. 18: 643--662, 1935.

[SW11]

Robert Sedgewick e Kevin Wayne. Algoritmos. Addison-Wesley, Boston, MA, Quarto, 2011.

[Tal10]

Nassim Nicholas Taleb. The Black Swan: Segunda Edição: O impacto dos altamente improváveis. Random House, Nova York, NY, segundo, 2010.

[WH82]

James Q. Wilson e George Helling. A segurança da polícia e do bairro. O Atlantic Monthly. 249 [3]: 29--38, 1982, março.

[YC79]

Edward Yourdon e Larry L. Constantine. Projeto estruturado: Fundamentos de uma disciplina de programa de computador e design de sistemas. Prentice Hall, Englewood Cliffs, NJ, 1979.

[Você95]

Edward Yourdon. Quando o software o suficiente é o melhor. Software IEEE. 1995, maio.





Copyright © 2020 Pearson Education, Inc.

Prefiro ter perguntas que não possam ser respondidas do que as respostas que não podem ser questionadas.



Richard Feynman





Apêndice 2



Respostas possíveis para os exercícios




Resposta 1 (do Exercício 1)

Para nossa maneira de pensar, a classe Split2 é mais ortogonal. Ele se concentra em sua própria tarefa, dividindo linhas e ignora detalhes como de onde vêm as linhas. Isso não apenas facilita o desenvolvimento do código, mas também o torna mais flexível. O Split2 pode dividir linhas lidas em um arquivo, geradas por outra rotina ou passadas pelo ambiente.

Resposta 2 (do Exercício 2)

Vamos começar com uma afirmação: você pode escrever um bom código ortogonal em praticamente qualquer idioma. Ao mesmo tempo, todo idioma tem tentações: recursos que podem levar ao aumento do acoplamento e diminuição da ortogonalidade.

Em idiomas OO, recursos como herança múltipla, exceções, sobrecarga do operador e substituição de padão dos pais (via subclasse) oferecem ampla oportunidade de aumentar o acoplamento de maneiras não óbvias. Há também um tipo de acoplamento porque um código de casais de classe para dados. Normalmente, isso é uma coisa boa (quando o acoplamento é bom, chamamos de coesão). Mas se você não deixar suas aulas focadas o suficiente, isso pode levar a algumas interfaces bastante feias.

Em idiomas funcionais, você é incentivado a escrever muitas funções pequenas e dissocradas e combiná -las de diferentes maneiras para resolver seu problema. Em teoria, isso parece bom. Na prática, muitas vezes é. Mas há uma forma de acoplamento que também pode acontecer aqui. Essas funções normalmente transformam dados, o que significa que o resultado de uma função pode se tornar a entrada para outra. Se você não tomar cuidado, fazer uma alteração no formato de dados que uma função gera pode resultar em uma falha em algum lugar no fluxo transformacional. Idiomas com bons sistemas de tipo podem ajudar a mitigar isso.

Resposta 3 (do Exercício 3)

De baixa tecnologia para o resgate! Desenhe alguns desenhos animados com marcadores em um quadro branco - um carro, um telefone e uma casa. Não precisa ser uma ótima arte; Os contornos de figura de pau são bons. Coloque as notas post-it que descrevam o conteúdo das páginas de destino nas áreas clicáveis. À medida que a reunião avança, você pode refinar os desenhos e colocações das notas post-it.

Resposta 4 (do Exercício 4)

Como queremos tornar o idioma extensível, tornaremos a tabela de analisador acionada. Cada entrada na tabela contém a letra de comando, um sinalizador para dizer se é necessário um argumento e o nome da rotina para chamar para lidar com esse comando específico.

Lang/Turtle.C

Typedef struct {

CHAR CMD; / * A carta de comando */

Int hasarg; / * Isso leva um argumento */

Void (*func) (int, int); / * Rotina para ligar */

} Comando;

​

Comando estático cmds [] = {

{'P', arg, Doselectpen},

{'U', no_arg, dopenup},

{'D', no_arg, dopendewn},

{'N', arg, dopendir},

{'E', arg, dopendir},

{'S', arg, dopendir},

{'W', arg, dopendir}

};



O programa principal é bem simples: leia uma linha, procure o comando, obtenha o
Argumento, se necessário, chame a função Handler.

Lang/Turtle.C

While (fgets (buff, sizeof (buff), stdin)) {

​

Comando *cmd = findCommand ( *buff);

​

If (cmd) {

Int arg = 0;

​

If (cmd-> hasarg &&! Getarg (buff+1, & arg)) {

Fprintf (stderr, "'%c' precisa de um argumento \ n", *buff);

Continuar;

}

​

Cmd-> func (*buff, arg);

}

}



A função que procure um comando executa uma pesquisa linear da tabela, retornando a entrada correspondente ou nulo.

Lang/Turtle.C

Comando *findCommand (int cmd) {

Int i;

​

For (i = 0; i <array_size (cmds); i ++) {

If (cmds [i] .cmd == cmd)

Retornar cmds + i;

}

​

Fprintf (stderr, "comando desconhecido '%c' \ n", cmd);

Retornar 0;

}



Finalmente, ler o argumento numérico é bastante simples usando o SSCANF.

Lang/Turtle.C

Int getarg (const char *buff, int *resultado) {

Retornar sscanf (buff, "%d", resultado) == 1;

}



Resposta 5 (do Exercício 5)

Na verdade, você já resolveu esse problema no exercício anterior, onde escreveu um intérprete para o idioma externo, conterá o intérprete interno. No caso do nosso código de amostra, essas são as funções doxxx.

Resposta 6 (do Exercício 6)

Usando o BNF, uma especificação de tempo pode ser

tempo

:: =

AMPM de hora | Hora: Minuto AMPM | Hora: minuto





Ampm

:: =

AM | PM





hora

:: =

Digit | dígito dígito





minuto

:: =

dígito dígito





Digit

:: =

0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9





Uma melhor definição de hora e minuto levaria em consideração que uma hora pode ser de 00 a 23 e um minuto de 00 a 59:

hora

:: =

dígito H-TENS | Digit



minuto

:: =

dígito M-tens



TENS H.

:: =

0 | 1



M-tens

:: =

0 | 1 | 2 | 3 | 4 | 5



Digit

:: =

0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9





Resposta 7 (do Exercício 7)

Aqui está o analisador escrito usando a biblioteca JavaScript PEGJS:

lang/peg_parser/time_parser.pegjs

Tempo

= H: deslocamento da hora: ampm {return h + offset}

/ H: hora ":" m: minuto deslocamento: ampm {return h + m + offset}

/ H: hora ":" m: minuto {return h + m}

​

Ampm

= "Am" {return 0}

/ "Pm" {retorna 12*60}

​

Hora

= H: dois_hour_digits {return h*60}

/ H: dígito {return h*60}

​

Minuto

= D1: [0-5] d2: [0-9] {return parseint (d1+d2, 10); }

​

Digit

= Dígito: [0-9] {return parseint (dígito, 10); }

​

Dois_hour_digits

= D1: [01] d2: [0-9] {return parseint (d1+d2, 10); }

/ D1: [2] d2: [0-3] {return parseint (d1+d2, 10); }



Os testes mostram em uso:

lang/peg_parser/test_time_parser.js

Deixe teste = requer ('fita');

Let time_parser = requer ('./time_parser.js');

​

// time :: = hour ampm |

// Hora: Minuto AMPM |

// hora: minuto

//

// ampm :: = am | PM

//

// hora :: = dígito | dígito dígito

//

// minuto :: = dígito dígito

//

// Digit :: = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

​

​

Const H = (val) => val*60;

Const m = (val) => val;

Const AM = (val) => val;

Const pm = (val) => val + h (12);

​

Deixe testes = {

​

"1:00": H (1),

"13:00": pm (h (1)),

​

"2:30": h (2) + m (30),

"14:30": pm (h (2)) + m (30),

"14:30": pm (h (2)) + m (30),

​

}

​

Teste ('Parsing time', função (t) {

Para (const String em testes) {

Let Result = time_parsers.parse (string)

T.Equal (resultado, testes [string], string);

}

T.END ()

});



Resposta 8 (do Exercício 8)

Aqui está uma solução possível em Ruby:

Lang/re_parser/time_parser.rb

Time_re =%r {

(? <nGit> [0-9]) {0}

(? <H_TEN> [0-1]) {0}

(? <M_ten> [0-6]) {0}

(? <mpm> Am | pm) {0}

(? <Hour> (\ g <h_ten> \ g <git>) | \ g <git>) {0}

(? <pinpin> \ g <m_ten> \ g <dygit>) {0}

​

\ A (

(\ G <hora> \ g <mpm>)

| (\ G <hora>: \ g <pinpin> \ g <mpm>)

| (\ G <hora>: \ g <pinpin>)

) \ Z

​

} X

​

Def parse_time (string)

Resultado = time_re.match (string)

Se resultado

Resultado [: hora] .to_i * 60 +

(Resultado [: minuto] || "0") .to_i +

(Resultado [: ampm] == "pm"? 12*60: 0)

Fim

Fim



(Este código usa o truque de definir padrões nomeados no início da expressão regular e, em seguida, referenciá -los como subpadrões na partida real.)

Resposta 9 (do Exercício 9)

Nossa resposta deve ser expressa em várias suposições:

O dispositivo de armazenamento contém as informações que precisamos ser transferidas.

Sabemos a velocidade com que a pessoa anda.

Sabemos a distância entre as máquinas.

Nós
não estão contabilizando o tempo necessário para transferir informações de e para o dispositivo de armazenamento.

A sobrecarga do armazenamento de dados é aproximadamente igual à sobrecarga de enviá -los sobre uma linha de comunicação.



Resposta 10 (do Exercício 10)

Sujeito às advertências na resposta anterior: uma fita de 1 TBB contém 8 × 240, ou 243 bits, portanto, uma linha de 1 Gbps teria que bombear dados por cerca de 9.000 segundos, ou aproximadamente 2 ½ horas, para transferir a quantidade equivalente de informações. Se a pessoa estiver andando a 3 mph constante, nossas duas máquinas precisariam estar a quase 15 quilômetros de distância para a linha de comunicações superar nosso correio. Caso contrário, a pessoa vence.

Resposta 14 (do Exercício 14)

Mostraremos as assinaturas de funções em Java, com as condições pré e pós-Postas nos comentários.

Primeiro, o invariante para a classe:

/**

* @InVariant getSpeed ()> 0

* Implica isfull () // não corra vazio

*

* @InVariant getSpeed ()> = 0 &&

* GetsPeed () <10 // verificação da faixa

*/



Em seguida, as Condições Pré e Pós:

/**

* @Pre Math.abs (getsPeed () - x) <= 1 // Mudar apenas por um

* @Pre X> = 0 && x <10 // Verificação de intervalo

* @Post getSpeed () == x // Honor solicitou velocidade

*/

Public Void Setspeed (Final Int X)

​

/**

* @Pre! Isfull () // não o preencha duas vezes

* @Post isfull () // Verifique se ele foi feito

*/

Vazio preenchimento ()

​

/**

* @Presfull () // não esvazie duas vezes

* @Post! Isfull () // Certifique -se de

*/

Vazio vazio ()



Resposta 15 (do Exercício 15)

Existem 21 termos na série. Se você disse 20, acabou de experimentar um erro de post (sem saber se deve contar os posts da cerca ou os espaços entre eles).

Resposta 16 (do Exercício 16)

Setembro de 1752 teve apenas 19 dias. Isso foi feito para sincronizar calendários como parte da Reforma Gregoriana.



O diretório poderia ter sido removido por outro processo, você pode não ter permissão para lê -lo, a unidade pode não ser montada,…; você entendeu a foto.



Não especificamos sorrateiramente os tipos de A e B. A sobrecarga do operador pode ter definido +, =, ou! = Para ter um comportamento inesperado. Além disso, A e B podem ser aliases para a mesma variável; portanto, a segunda tarefa substituirá o valor armazenado no primeiro. Além disso, se o programa for simultâneo e mal escrito, um poderá ter sido atualizado no momento em que a adição ocorrer.



Na geometria não-euclidiana, a soma dos ângulos de um triângulo não somará 180 °. Pense em um triângulo mapeado na superfície de uma esfera.



Os minutos de salto podem ter 61 ou 62 segundos.



Dependendo do idioma, o transbordamento numérico pode deixar o resultado de um+1 negativo.





Resposta 17 (do Exercício 17)

Na maioria das implementações C e C ++, não há como verificar se um ponteiro aponta para a memória válida. Um erro comum é negociar um bloco de memória e fazer referência a essa memória posteriormente no programa. Até então, a memória apontada pode muito bem ter sido realocada para algum outro propósito. Ao definir o ponteiro para NULL, os programadores esperam impedir essas referências desonestas - na maioria dos casos, a desreferência de um ponteiro nulo gerará um erro de tempo de execução.

Resposta 18 (do Exercício 18)

Ao definir a referência ao NULL, você reduz o número de ponteiros para o objeto referenciado por um. Quando essa contagem atinge zero, o objeto é elegível para a coleta de lixo. Definir as referências ao NULL pode ser significativo para programas de longa duração, onde os programadores precisam garantir que a utilização da memória não aumente com o tempo.

Resposta 19 (do Exercício 19)

Uma implementação simples pode ser:

Event/strings_ex_1.rb

Classe FSM

Def Initialize (transições, Initial_state)

@Transitions = transições

@State = inicial_state

Fim

Def aceit (evento)

@State, Action = Transitions [@State] [Event] || Transições [@state] [: padrão]

Fim

Fim



(Faça o download deste arquivo para obter o código atualizado que usa esta nova classe FSM.)

Resposta 20 (do Exercício 20)

… Três eventos de interface de rede em cinco minutos

Isso pode ser implementado usando uma máquina de estado, mas seria mais complicado do que poderia aparecer primeiro: se você receber eventos nos minutos 1, 4, 7 e 8, você deve acionar o aviso no quarto evento, o que significa que a máquina de estado precisa ser capaz de lidar com a redefinição.

Por esse motivo, os fluxos de eventos parecem ser a tecnologia de escolha. Existe uma função reativa chamada buffer com parâmetros de tamanho e deslocamento que permitiriam retornar cada grupo de
três eventos de entrada. Você pode então olhar para os registros de data e hora do primeiro e último evento em um grupo para determinar se o alarme deve ser acionado.



… Depois do pôr do sol, e há movimento detectado no fundo da escada seguido de movimento detectado no topo da escada…

Provavelmente, isso poderia ser implementado usando uma combinação de máquinas PubSub e State. Você pode usar o PubSub para disseminar eventos em qualquer número de máquinas de estado e, em seguida, fazer com que as máquinas de estado determinem o que fazer.



… Notifique vários sistemas de relatórios de que um pedido foi concluído.

Provavelmente, isso é melhor manipulado usando o pubsub. Você pode querer usar fluxos, mas isso exigiria que os sistemas que estão sendo notificados também fossem baseados em fluxos.



… Três serviços de back -end e aguardam as respostas.

Isso é semelhante ao nosso exemplo que usou fluxos para buscar dados do usuário.





Resposta 21 (do Exercício 21)

O imposto sobre remessas e vendas é adicionado a um pedido:

Ordem básica → Ordem finalizada



No código convencional, é provável que você tenha uma função que calculou os custos de envio e outro que calculou o imposto. Mas estamos pensando em transformações aqui, então transformamos um pedido com apenas itens em um novo tipo de coisa: um pedido que pode ser enviado.



Seu aplicativo carrega informações de configuração de um arquivo nomeado:

Nome do arquivo → Estrutura de configuração





Alguém faz login em um aplicativo da web:

Credenciais de usuário → sessão





Resposta 22 (do Exercício 22)

A transformação de alto nível:

Conteúdo de campo como string

→ [Validar e converter]

→ {: ok, valor} | {: erro, razão}



poderia ser dividido em:

Conteúdo de campo como string

→ [Converter string em número inteiro]

→ [Valor de verificação> = 18]

→ [Valor de verificação <= 150]

→ {: ok, valor} | {: erro, razão}



Isso pressupõe que você tenha um pipeline de manipulação de erros.

Resposta 23 (do Exercício 23)

Vamos responder à segunda parte primeiro: preferimos a primeira peça de código.

Na segunda parte do código, cada etapa retorna um objeto que implementa a próxima função que chamamos: o objeto retornado por content_of deve implementar find_matching_lines e assim por diante.

Isso significa que o objeto retornado por content_of está acoplado ao nosso código. Imagine que o requisito mudou e temos que ignorar as linhas começando com um caractere #. No estilo de transformação, isso seria fácil:

Const content = file.read (file_name);

Const no_comments = remove_comments (conteúdo)

Const lines = find_matching_lines (NO_comments, padrão)

Const resultado = truncate_lines (linhas)



Poderíamos trocar a ordem dos Remone_comments e Find_Matching_Lines e ainda funcionaria.

Mas no estilo acorrentado, isso seria mais difícil. Onde o nosso método Remow_comments deve vivo: no objeto retornado por content_of ou o objeto retornado por find_matching_lines? E que outro código iremos quebrar se alterarmos esse objeto? Esse acoplamento é por que o estilo de encadeamento de método às vezes é chamado de acidente de trem.

Resposta 24 (do Exercício 24)

Processamento de imagem.

Para um simples agendamento de uma carga de trabalho entre os processos paralelos, uma fila de trabalho compartilhada pode ser mais do que adequada. Você pode considerar um sistema de quadro-negro se houver feedback envolvido-ou seja, se os resultados de um pedaço processado afetarem outros pedaços, como em aplicações de visão de máquina ou transformações complexas de warp de imagem 3D.



Calendário de grupo

Isso pode ser um bom ajuste. Você pode postar reuniões agendadas e disponibilidade no quadro -negro. Você tem entidades funcionando autonomamente, o feedback das decisões é importante e os participantes podem ir e vir.

Você pode considerar particionar esse tipo de sistema de quadro-negro, dependendo de quem está pesquisando: os funcionários juniores podem se preocupar apenas com o escritório imediato, os recursos humanos podem querer apenas escritórios de língua inglesa em todo o mundo e o CEO pode querer toda a Enchilada.

Há também alguma flexibilidade nos formatos de dados: somos livres para ignorar formatos ou idiomas que não entendemos. Temos que entender diferentes formatos apenas para os escritórios que têm reuniões entre si, e não precisamos expor todos os participantes a um fechamento transitivo completo de todos os formatos possíveis. Isso reduz o acoplamento a onde é necessário e não nos restringe artificialmente.



Ferramenta de monitoramento de rede

Isso é muito semelhante ao programa de pedido de hipoteca/empréstimo. Você tem relatórios de problemas enviados por usuários e estatísticas relatadas automaticamente, todas postando no quadro -negro. Um agente humano ou de software pode analisar o quadro -negro para diagnosticar falhas de rede: dois erros
Em uma linha, pode ser apenas raios cósmicos, mas 20.000 erros e você tem um problema de hardware. Assim como os detetives resolvem o mistério do assassinato, você pode ter várias entidades analisando e contribuindo com idéias para resolver os problemas da rede.





Resposta 25 (do Exercício 25)

A suposição com uma lista de pares de valores-chave é geralmente que a chave é única, e as bibliotecas de hash normalmente aplicam isso pelo comportamento do próprio hash ou com mensagens de erro explícitas para chaves duplicadas. No entanto, uma matriz normalmente não possui essas restrições e armazenará felizmente as teclas duplicadas, a menos que você a codificasse especificamente para não. Portanto, nesse caso, a primeira chave constatou que corresponde às vitórias depositAccount e todas as entradas correspondentes restantes são ignoradas. A ordem das entradas não é garantida, então às vezes funciona e às vezes não.

E a diferença nas máquinas do desenvolvimento e produção? É apenas uma coincidência.

Resposta 26 (do Exercício 26)

O fato de um campo puramente numérico funcionar nos EUA, Canadá e no Caribe é uma coincidência. De acordo com a especificação da ITU, o formato de chamada internacional começa com um sinal literal +. O caractere * também é usado em alguns locais e, mais comumente, os zeros principais podem fazer parte do número. Nunca armazene um número de telefone em um campo numérico.

Resposta 27 (do Exercício 27)

Depende de onde você está. Nos EUA, as medidas de volume são baseadas no galão, que é o volume de um cilindro de 6 polegadas de altura e 7 polegadas de diâmetro, arredondado até a polegada cúbica mais próxima.

No Canadá, "One Cup" em uma receita pode significar qualquer um dos

1/5 de um quart imperial, ou 227ml

1/4 de um quart dos EUA, ou 236ml

16 colheres de sopa métricas, ou 240ml

1/4 de um litro, ou 250ml



A menos que você esteja falando de uma panela de arroz, nesse caso "One Cup" é de 180 ml. Isso deriva do koku, que foi o volume estimado de arroz seco necessário para alimentar uma pessoa por um ano: aparentemente, por volta de 180L. Os copos de fogão de arroz são 1 gō, que é 1/1000 de um koku. Então, aproximadamente a quantidade de arroz que uma pessoa comeria em uma única refeição. [85]

Resposta 28 (do Exercício 28)

Claramente, não podemos dar respostas absolutas a este exercício. No entanto, podemos dar a você algumas dicas.

Se você achar que seus resultados não seguem uma curva suave, convém verificar se alguma outra atividade está usando parte do poder do seu processador. Você provavelmente não receberá bons números se os processos em segundo plano tirarem os ciclos periodicamente de seus programas. Você também pode querer verificar a memória: se o aplicativo começar a usar o espaço de troca, o desempenho será o mergulho no nariz.

Aqui está um gráfico dos resultados da execução do código em uma de nossas máquinas:



Resposta 29 (do Exercício 29)

Existem algumas maneiras de chegar lá. Uma é virar o problema de cabeça para baixo. Se a matriz tiver apenas um elemento, não iteramos ao redor do loop. Cada iteração adicional dobra o tamanho da matriz que podemos pesquisar. A fórmula geral para o tamanho da matriz é, portanto, onde é o número de iterações. Se você levar logs para a base 2 de cada lado, você recebe, que pela definição de logs se torna.

Resposta 30 (do Exercício 30)

Provavelmente é um flashback demais para a matemática do ensino médio, mas a fórmula para converter um logaritmo na base em um da base é:



Porque é uma constante, podemos ignorá-lo dentro de um resultado grande.

Resposta 31 (do Exercício 31)

Uma propriedade que podemos testar é que um pedido é bem -sucedido se o armazém tiver itens suficientes à mão. Podemos gerar pedidos para quantidades aleatórias de itens e verificar se uma tupla "ok" é retornada se o armazém tivesse estoque.

Resposta 32 (do Exercício 32)

Este é um bom uso de testes baseados em propriedades. Os testes de unidade podem se concentrar em casos individuais em que você elaborou o resultado por alguns outros meios, e os testes de propriedade podem se concentrar em coisas como:

Alguma caixa se sobrepõe?

Alguma parte de qualquer caixa excede a largura ou o comprimento do caminhão?

A densidade de embalagem (área usada por caixas é dividida pela área do leito do caminhão) menor ou igual a 1?

Se faz parte do requisito, a densidade de embalagem excede a densidade mínima aceitável?



Resposta 33 (do Exercício 33)

Essa afirmação parece um requisito real: pode haver restrições colocadas no aplicativo por seu ambiente.



Por si só, essa afirmação não é realmente um requisito. Mas para descobrir o que é realmente necessário, você precisa fazer a pergunta mágica: "Por quê?"

Pode ser que este seja um padrão corporativo; nesse caso, o requisito real deve ser algo como “All UI
Os elementos devem estar em conformidade com os padrões da interface do usuário do Megacorp, v12.76. ”

Pode ser que essa seja uma cor que a equipe de design gosta. Nesse caso, você deve pensar na maneira como a equipe de design também gosta de mudar de idéia e frase o requisito como "a cor de fundo de todas as janelas modais deve ser configurável. Conforme enviado, a cor será cinza". Ainda melhor seria a afirmação mais ampla “todos os elementos visuais do aplicativo (cores, fontes e idiomas) devem ser configuráveis.”

Ou pode simplesmente significar que o usuário precisa ser capaz de distinguir janelas modais e não modais. Se for esse o caso, são necessárias mais discussões.



Esta afirmação não é um requisito, é arquitetura. Quando se depara com algo assim, você precisa se aprofundar para descobrir o que o usuário está pensando. Isso é um problema de escala? Ou desempenho? Custo? Segurança? As respostas informarão seu design.



O requisito subjacente é provavelmente algo mais próximo de "o sistema impedirá que o usuário faça entradas inválidas em campos e alertará o usuário quando essas entradas forem feitas. ''



Essa declaração é provavelmente um requisito difícil, com base em alguma limitação de hardware.





E aqui está uma solução para o problema de quatro pontos:





Notas de rodapé


[85]

Obrigado por este pedaço de curiosidade vai para Avi Bryant (@avibryant)





Copyright © 2020 Pearson Education, Inc.